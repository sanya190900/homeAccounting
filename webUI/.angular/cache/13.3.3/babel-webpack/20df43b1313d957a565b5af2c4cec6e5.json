{"ast":null,"code":"/**\n * @license Highcharts JS v10.0.0 (2022-03-07)\n *\n * 3D features for Highcharts JS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n  if (typeof module === 'object' && module.exports) {\n    factory['default'] = factory;\n    module.exports = factory;\n  } else if (typeof define === 'function' && define.amd) {\n    define('highcharts/highcharts-3d', ['highcharts'], function (Highcharts) {\n      factory(Highcharts);\n      factory.Highcharts = Highcharts;\n      return factory;\n    });\n  } else {\n    factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n  }\n})(function (Highcharts) {\n  'use strict';\n\n  var _modules = Highcharts ? Highcharts._modules : {};\n\n  function _registerModule(obj, path, args, fn) {\n    if (!obj.hasOwnProperty(path)) {\n      obj[path] = fn.apply(null, args);\n\n      if (typeof CustomEvent === 'function') {\n        window.dispatchEvent(new CustomEvent('HighchartsModuleLoaded', {\n          detail: {\n            path: path,\n            module: obj[path]\n          }\n        }));\n      }\n    }\n  }\n\n  _registerModule(_modules, 'Extensions/Math3D.js', [_modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (H, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var pick = U.pick; // Mathematical Functionility\n\n    var deg2rad = H.deg2rad;\n    /* eslint-disable max-len */\n\n    /**\n     * Apply 3-D rotation\n     * Euler Angles (XYZ):\n     *     cosA = cos(Alfa|Roll)\n     *     cosB = cos(Beta|Pitch)\n     *     cosG = cos(Gamma|Yaw)\n     *\n     * Composite rotation:\n     * |          cosB * cosG             |           cosB * sinG            |    -sinB    |\n     * | sinA * sinB * cosG - cosA * sinG | sinA * sinB * sinG + cosA * cosG | sinA * cosB |\n     * | cosA * sinB * cosG + sinA * sinG | cosA * sinB * sinG - sinA * cosG | cosA * cosB |\n     *\n     * Now, Gamma/Yaw is not used (angle=0), so we assume cosG = 1 and sinG = 0, so\n     * we get:\n     * |     cosB    |   0    |   - sinB    |\n     * | sinA * sinB |  cosA  | sinA * cosB |\n     * | cosA * sinB | - sinA | cosA * cosB |\n     *\n     * But in browsers, y is reversed, so we get sinA => -sinA. The general result\n     * is:\n     * |      cosB     |   0    |    - sinB     |     | x |     | px |\n     * | - sinA * sinB |  cosA  | - sinA * cosB |  x  | y |  =  | py |\n     * |  cosA * sinB  |  sinA  |  cosA * cosB  |     | z |     | pz |\n     *\n     * @private\n     * @function rotate3D\n     */\n\n    /* eslint-enable max-len */\n\n    /**\n     * @private\n     * @param {number} x\n     *        X coordinate\n     * @param {number} y\n     *        Y coordinate\n     * @param {number} z\n     *        Z coordinate\n     * @param {Highcharts.Rotation3dObject} angles\n     *        Rotation angles\n     * @return {Highcharts.Rotation3dObject}\n     *         Rotated position\n     */\n\n    function rotate3D(x, y, z, angles) {\n      return {\n        x: angles.cosB * x - angles.sinB * z,\n        y: -angles.sinA * angles.sinB * x + angles.cosA * y - angles.cosB * angles.sinA * z,\n        z: angles.cosA * angles.sinB * x + angles.sinA * y + angles.cosA * angles.cosB * z\n      };\n    }\n    /**\n     * Perspective3D function is available in global Highcharts scope because is\n     * needed also outside of perspective() function (#8042).\n     * @private\n     * @function Highcharts.perspective3D\n     *\n     * @param {Highcharts.Position3DObject} coordinate\n     * 3D position\n     *\n     * @param {Highcharts.Position3DObject} origin\n     * 3D root position\n     *\n     * @param {number} distance\n     * Perspective distance\n     *\n     * @return {Highcharts.PositionObject}\n     * Perspective 3D Position\n     *\n     * @requires highcharts-3d\n     */\n\n\n    function perspective3D(coordinate, origin, distance) {\n      var projection = distance > 0 && distance < Number.POSITIVE_INFINITY ? distance / (coordinate.z + origin.z + distance) : 1;\n      return {\n        x: coordinate.x * projection,\n        y: coordinate.y * projection\n      };\n    }\n\n    H.perspective3D = perspective3D;\n    /**\n     * Transforms a given array of points according to the angles in chart.options.\n     *\n     * @private\n     * @function Highcharts.perspective\n     *\n     * @param {Array<Highcharts.Position3DObject>} points\n     * The array of points\n     *\n     * @param {Highcharts.Chart} chart\n     * The chart\n     *\n     * @param {boolean} [insidePlotArea]\n     * Whether to verify that the points are inside the plotArea\n     *\n     * @param {boolean} [useInvertedPersp]\n     * Whether to use inverted perspective in calculations\n     *\n     * @return {Array<Highcharts.Position3DObject>}\n     * An array of transformed points\n     *\n     * @requires highcharts-3d\n     */\n\n    function perspective(points, chart, insidePlotArea, useInvertedPersp) {\n      var options3d = chart.options.chart.options3d,\n\n      /* The useInvertedPersp argument is used for inverted charts with\n       * already inverted elements,\n      such as dataLabels or tooltip positions.\n       */\n      inverted = pick(useInvertedPersp, insidePlotArea ? chart.inverted : false),\n          origin = {\n        x: chart.plotWidth / 2,\n        y: chart.plotHeight / 2,\n        z: options3d.depth / 2,\n        vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n      },\n          scale = chart.scale3d || 1,\n          beta = deg2rad * options3d.beta * (inverted ? -1 : 1),\n          alpha = deg2rad * options3d.alpha * (inverted ? -1 : 1),\n          angles = {\n        cosA: Math.cos(alpha),\n        cosB: Math.cos(-beta),\n        sinA: Math.sin(alpha),\n        sinB: Math.sin(-beta)\n      };\n\n      if (!insidePlotArea) {\n        origin.x += chart.plotLeft;\n        origin.y += chart.plotTop;\n      } // Transform each point\n\n\n      return points.map(function (point) {\n        var rotated = rotate3D((inverted ? point.y : point.x) - origin.x, (inverted ? point.x : point.y) - origin.y, (point.z || 0) - origin.z, angles),\n            // Apply perspective\n        coordinate = perspective3D(rotated, origin, origin.vd); // Apply translation\n\n        coordinate.x = coordinate.x * scale + origin.x;\n        coordinate.y = coordinate.y * scale + origin.y;\n        coordinate.z = rotated.z * scale + origin.z;\n        return {\n          x: inverted ? coordinate.y : coordinate.x,\n          y: inverted ? coordinate.x : coordinate.y,\n          z: coordinate.z\n        };\n      });\n    }\n\n    H.perspective = perspective;\n    /**\n     * Calculate a distance from camera to points - made for calculating zIndex of\n     * scatter points.\n     *\n     * @private\n     * @function Highcharts.pointCameraDistance\n     *\n     * @param {Highcharts.Dictionary<number>} coordinates\n     * Coordinates of the specific point\n     *\n     * @param {Highcharts.Chart} chart\n     * Related chart\n     *\n     * @return {number}\n     * Distance from camera to point\n     *\n     * @requires highcharts-3d\n     */\n\n    function pointCameraDistance(coordinates, chart) {\n      var options3d = chart.options.chart.options3d,\n          cameraPosition = {\n        x: chart.plotWidth / 2,\n        y: chart.plotHeight / 2,\n        z: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0) + options3d.depth\n      },\n          // Added support for objects with plotX or x coordinates.\n      distance = Math.sqrt(Math.pow(cameraPosition.x - pick(coordinates.plotX, coordinates.x), 2) + Math.pow(cameraPosition.y - pick(coordinates.plotY, coordinates.y), 2) + Math.pow(cameraPosition.z - pick(coordinates.plotZ, coordinates.z), 2));\n      return distance;\n    }\n\n    H.pointCameraDistance = pointCameraDistance;\n    /**\n     * Calculate area of a 2D polygon using Shoelace algorithm\n     * https://en.wikipedia.org/wiki/Shoelace_formula\n     *\n     * @private\n     * @function Highcharts.shapeArea\n     *\n     * @param {Array<Highcharts.PositionObject>} vertexes\n     * 2D Polygon\n     *\n     * @return {number}\n     * Calculated area\n     *\n     * @requires highcharts-3d\n     */\n\n    function shapeArea(vertexes) {\n      var area = 0,\n          i,\n          j;\n\n      for (i = 0; i < vertexes.length; i++) {\n        j = (i + 1) % vertexes.length;\n        area += vertexes[i].x * vertexes[j].y - vertexes[j].x * vertexes[i].y;\n      }\n\n      return area / 2;\n    }\n\n    H.shapeArea = shapeArea;\n    /**\n     * Calculate area of a 3D polygon after perspective projection\n     *\n     * @private\n     * @function Highcharts.shapeArea3d\n     *\n     * @param {Array<Highcharts.Position3DObject>} vertexes\n     * 3D Polygon\n     *\n     * @param {Highcharts.Chart} chart\n     * Related chart\n     *\n     * @param {boolean} [insidePlotArea]\n     * Whether to verify that the points are inside the plotArea\n     *\n     * @return {number}\n     * Calculated area\n     *\n     * @requires highcharts-3d\n     */\n\n    function shapeArea3D(vertexes, chart, insidePlotArea) {\n      return shapeArea(perspective(vertexes, chart, insidePlotArea));\n    }\n\n    H.shapeArea3d = shapeArea3D;\n    var mathModule = {\n      perspective: perspective,\n      perspective3D: perspective3D,\n      pointCameraDistance: pointCameraDistance,\n      shapeArea: shapeArea,\n      shapeArea3D: shapeArea3D\n    };\n    return mathModule;\n  });\n\n  _registerModule(_modules, 'Core/Renderer/SVG/SVGElement3D.js', [_modules['Core/Color/Color.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Utilities.js']], function (Color, SVGElement, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extensions to the SVGRenderer class to enable 3D shapes\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var color = Color.parse;\n    var defined = U.defined,\n        merge = U.merge,\n        objectEach = U.objectEach,\n        pick = U.pick;\n    /* *\n     *\n     *  Constants\n     *\n     * */\n\n    var SVGElement3D = {};\n    SVGElement3D.base = {\n      /* eslint-disable valid-jsdoc */\n\n      /**\n       * The init is used by base - renderer.Element\n       * @private\n       */\n      initArgs: function (args) {\n        var elem3d = this,\n            renderer = elem3d.renderer,\n            paths = renderer[elem3d.pathType + 'Path'](args),\n            zIndexes = paths.zIndexes; // build parts\n\n        elem3d.parts.forEach(function (part) {\n          var attribs = {\n            'class': 'highcharts-3d-' + part,\n            zIndex: zIndexes[part] || 0\n          };\n\n          if (renderer.styledMode) {\n            if (part === 'top') {\n              attribs.filter = 'url(#highcharts-brighter)';\n            } else if (part === 'side') {\n              attribs.filter = 'url(#highcharts-darker)';\n            }\n          }\n\n          elem3d[part] = renderer.path(paths[part]).attr(attribs).add(elem3d);\n        });\n        elem3d.attr({\n          'stroke-linejoin': 'round',\n          zIndex: zIndexes.group\n        }); // store original destroy\n\n        elem3d.originalDestroy = elem3d.destroy;\n        elem3d.destroy = elem3d.destroyParts; // Store information if any side of element was rendered by force.\n\n        elem3d.forcedSides = paths.forcedSides;\n      },\n\n      /**\n       * Single property setter that applies options to each part\n       * @private\n       */\n      singleSetterForParts: function (prop, val, values, verb, duration, complete) {\n        var elem3d = this,\n            newAttr = {},\n            optionsToApply = [null, null, verb || 'attr', duration, complete],\n            hasZIndexes = values && values.zIndexes;\n\n        if (!values) {\n          newAttr[prop] = val;\n          optionsToApply[0] = newAttr;\n        } else {\n          // It is needed to deal with the whole group zIndexing\n          // in case of graph rotation\n          if (hasZIndexes && hasZIndexes.group) {\n            this.attr({\n              zIndex: hasZIndexes.group\n            });\n          }\n\n          objectEach(values, function (partVal, part) {\n            newAttr[part] = {};\n            newAttr[part][prop] = partVal; // include zIndexes if provided\n\n            if (hasZIndexes) {\n              newAttr[part].zIndex = values.zIndexes[part] || 0;\n            }\n          });\n          optionsToApply[1] = newAttr;\n        }\n\n        return elem3d.processParts.apply(elem3d, optionsToApply);\n      },\n\n      /**\n       * Calls function for each part. Used for attr, animate and destroy.\n       * @private\n       */\n      processParts: function (props, partsProps, verb, duration, complete) {\n        var elem3d = this;\n        elem3d.parts.forEach(function (part) {\n          // if different props for different parts\n          if (partsProps) {\n            props = pick(partsProps[part], false);\n          } // only if something to set, but allow undefined\n\n\n          if (props !== false) {\n            elem3d[part][verb](props, duration, complete);\n          }\n        });\n        return elem3d;\n      },\n\n      /**\n       * Destroy all parts\n       * @private\n       */\n      destroyParts: function () {\n        this.processParts(null, null, 'destroy');\n        return this.originalDestroy();\n      }\n      /* eslint-enable valid-jsdoc */\n\n    };\n    SVGElement3D.cuboid = merge(SVGElement3D.base, {\n      parts: ['front', 'top', 'side'],\n      pathType: 'cuboid',\n      attr: function (args, val, complete, continueAnimation) {\n        // Resolve setting attributes by string name\n        if (typeof args === 'string' && typeof val !== 'undefined') {\n          var key = args;\n          args = {};\n          args[key] = val;\n        }\n\n        if (args.shapeArgs || defined(args.x)) {\n          return this.singleSetterForParts('d', null, this.renderer[this.pathType + 'Path'](args.shapeArgs || args));\n        }\n\n        return SVGElement.prototype.attr.call(this, args, void 0, complete, continueAnimation);\n      },\n      animate: function (args, duration, complete) {\n        if (defined(args.x) && defined(args.y)) {\n          var paths = this.renderer[this.pathType + 'Path'](args),\n              forcedSides = paths.forcedSides;\n          this.singleSetterForParts('d', null, paths, 'animate', duration, complete);\n          this.attr({\n            zIndex: paths.zIndexes.group\n          }); // If sides that are forced to render changed, recalculate colors.\n\n          if (forcedSides !== this.forcedSides) {\n            this.forcedSides = forcedSides;\n\n            if (!this.renderer.styledMode) {\n              SVGElement3D.cuboid.fillSetter.call(this, this.fill);\n            }\n          }\n        } else {\n          SVGElement.prototype.animate.call(this, args, duration, complete);\n        }\n\n        return this;\n      },\n      fillSetter: function (fill) {\n        var elem3d = this;\n        elem3d.forcedSides = elem3d.forcedSides || [];\n        elem3d.singleSetterForParts('fill', null, {\n          front: fill,\n          // Do not change color if side was forced to render.\n          top: color(fill).brighten(elem3d.forcedSides.indexOf('top') >= 0 ? 0 : 0.1).get(),\n          side: color(fill).brighten(elem3d.forcedSides.indexOf('side') >= 0 ? 0 : -0.1).get()\n        }); // fill for animation getter (#6776)\n\n        elem3d.color = elem3d.fill = fill;\n        return elem3d;\n      }\n    });\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    return SVGElement3D;\n  });\n\n  _registerModule(_modules, 'Core/Renderer/SVG/SVGRenderer3D.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Extensions/Math3D.js'], _modules['Core/Renderer/SVG/SVGElement.js'], _modules['Core/Renderer/SVG/SVGElement3D.js'], _modules['Core/Renderer/SVG/SVGRenderer.js'], _modules['Core/Utilities.js']], function (A, Color, H, Math3D, SVGElement, SVGElement3D, SVGRenderer, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extensions to the SVGRenderer class to enable 3D shapes\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var animObject = A.animObject;\n    var color = Color.parse;\n    var charts = H.charts,\n        deg2rad = H.deg2rad;\n    var perspective = Math3D.perspective,\n        shapeArea = Math3D.shapeArea;\n    var defined = U.defined,\n        extend = U.extend,\n        merge = U.merge,\n        pick = U.pick;\n    /* *\n     *\n     *  Constants\n     *\n     * */\n\n    var cos = Math.cos,\n        sin = Math.sin,\n        PI = Math.PI,\n        dFactor = 4 * (Math.sqrt(2) - 1) / 3 / (PI / 2);\n    /* *\n     *\n     *  Functions\n     *\n     * */\n\n    /* eslint-disable valid-jsdoc */\n\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    var SVGRenderer3D =\n    /** @class */\n    function (_super) {\n      __extends(SVGRenderer3D, _super);\n\n      function SVGRenderer3D() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      /* *\n       *\n       *  Static Functions\n       *\n       * */\n\n      /** @private */\n\n\n      SVGRenderer3D.compose = function (SVGRendererClass) {\n        var svgRendererProto = SVGRendererClass.prototype,\n            svgRenderer3dProto = SVGRenderer3D.prototype;\n        svgRendererProto.elements3d = SVGElement3D;\n        svgRendererProto.arc3d = svgRenderer3dProto.arc3d;\n        svgRendererProto.arc3dPath = svgRenderer3dProto.arc3dPath;\n        svgRendererProto.cuboid = svgRenderer3dProto.cuboid;\n        svgRendererProto.cuboidPath = svgRenderer3dProto.cuboidPath;\n        svgRendererProto.element3d = svgRenderer3dProto.element3d;\n        svgRendererProto.face3d = svgRenderer3dProto.face3d;\n        svgRendererProto.polyhedron = svgRenderer3dProto.polyhedron;\n        svgRendererProto.toLinePath = svgRenderer3dProto.toLinePath;\n        svgRendererProto.toLineSegments = svgRenderer3dProto.toLineSegments;\n      };\n      /**\n       * Method to construct a curved path. Can 'wrap' around more then 180\n       * degrees.\n       * @private\n       */\n\n\n      SVGRenderer3D.curveTo = function (cx, cy, rx, ry, start, end, dx, dy) {\n        var result = [],\n            arcAngle = end - start;\n\n        if (end > start && end - start > Math.PI / 2 + 0.0001) {\n          result = result.concat(this.curveTo(cx, cy, rx, ry, start, start + Math.PI / 2, dx, dy));\n          result = result.concat(this.curveTo(cx, cy, rx, ry, start + Math.PI / 2, end, dx, dy));\n          return result;\n        }\n\n        if (end < start && start - end > Math.PI / 2 + 0.0001) {\n          result = result.concat(this.curveTo(cx, cy, rx, ry, start, start - Math.PI / 2, dx, dy));\n          result = result.concat(this.curveTo(cx, cy, rx, ry, start - Math.PI / 2, end, dx, dy));\n          return result;\n        }\n\n        return [['C', cx + rx * Math.cos(start) - rx * dFactor * arcAngle * Math.sin(start) + dx, cy + ry * Math.sin(start) + ry * dFactor * arcAngle * Math.cos(start) + dy, cx + rx * Math.cos(end) + rx * dFactor * arcAngle * Math.sin(end) + dx, cy + ry * Math.sin(end) - ry * dFactor * arcAngle * Math.cos(end) + dy, cx + rx * Math.cos(end) + dx, cy + ry * Math.sin(end) + dy]];\n      };\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /** @private */\n\n\n      SVGRenderer3D.prototype.toLinePath = function (points, closed) {\n        var result = []; // Put \"L x y\" for each point\n\n        points.forEach(function (point) {\n          result.push(['L', point.x, point.y]);\n        });\n\n        if (points.length) {\n          // Set the first element to M\n          result[0][0] = 'M'; // If it is a closed line, add Z\n\n          if (closed) {\n            result.push(['Z']);\n          }\n        }\n\n        return result;\n      };\n      /** @private */\n\n\n      SVGRenderer3D.prototype.toLineSegments = function (points) {\n        var result = [],\n            m = true;\n        points.forEach(function (point) {\n          result.push(m ? ['M', point.x, point.y] : ['L', point.x, point.y]);\n          m = !m;\n        });\n        return result;\n      };\n      /**\n       * A 3-D Face is defined by it's 3D vertexes, and is only visible if it's\n       * vertexes are counter-clockwise (Back-face culling). It is used as a\n       * polyhedron Element.\n       * @private\n       */\n\n\n      SVGRenderer3D.prototype.face3d = function (args) {\n        var renderer = this,\n            ret = this.createElement('path');\n        ret.vertexes = [];\n        ret.insidePlotArea = false;\n        ret.enabled = true;\n        /* eslint-disable no-invalid-this */\n\n        ret.attr = function (hash) {\n          if (typeof hash === 'object' && (defined(hash.enabled) || defined(hash.vertexes) || defined(hash.insidePlotArea))) {\n            this.enabled = pick(hash.enabled, this.enabled);\n            this.vertexes = pick(hash.vertexes, this.vertexes);\n            this.insidePlotArea = pick(hash.insidePlotArea, this.insidePlotArea);\n            delete hash.enabled;\n            delete hash.vertexes;\n            delete hash.insidePlotArea;\n            var chart = charts[renderer.chartIndex],\n                vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea),\n                path = renderer.toLinePath(vertexes2d, true),\n                area = shapeArea(vertexes2d);\n            hash.d = path;\n            hash.visibility = this.enabled && area > 0 ? 'visible' : 'hidden';\n          }\n\n          return SVGElement.prototype.attr.apply(this, arguments);\n        };\n\n        ret.animate = function (params) {\n          if (typeof params === 'object' && (defined(params.enabled) || defined(params.vertexes) || defined(params.insidePlotArea))) {\n            this.enabled = pick(params.enabled, this.enabled);\n            this.vertexes = pick(params.vertexes, this.vertexes);\n            this.insidePlotArea = pick(params.insidePlotArea, this.insidePlotArea);\n            delete params.enabled;\n            delete params.vertexes;\n            delete params.insidePlotArea;\n            var chart = charts[renderer.chartIndex],\n                vertexes2d = perspective(this.vertexes, chart, this.insidePlotArea),\n                path = renderer.toLinePath(vertexes2d, true),\n                area = shapeArea(vertexes2d),\n                visibility = this.enabled && area > 0 ? 'visible' : 'hidden';\n            params.d = path;\n            this.attr('visibility', visibility);\n          }\n\n          return SVGElement.prototype.animate.apply(this, arguments);\n        };\n        /* eslint-enable no-invalid-this */\n\n\n        return ret.attr(args);\n      };\n      /**\n       * A Polyhedron is a handy way of defining a group of 3-D faces. It's only\n       * attribute is `faces`, an array of attributes of each one of it's Face3D\n       * instances.\n       * @private\n       */\n\n\n      SVGRenderer3D.prototype.polyhedron = function (args) {\n        var renderer = this,\n            result = this.g(),\n            destroy = result.destroy;\n\n        if (!this.styledMode) {\n          result.attr({\n            'stroke-linejoin': 'round'\n          });\n        }\n\n        result.faces = [];\n        /* eslint-disable no-invalid-this */\n        // destroy all children\n\n        result.destroy = function () {\n          for (var i = 0; i < result.faces.length; i++) {\n            result.faces[i].destroy();\n          }\n\n          return destroy.call(this);\n        };\n\n        result.attr = function (hash, val, complete, continueAnimation) {\n          if (typeof hash === 'object' && defined(hash.faces)) {\n            while (result.faces.length > hash.faces.length) {\n              result.faces.pop().destroy();\n            }\n\n            while (result.faces.length < hash.faces.length) {\n              result.faces.push(renderer.face3d().add(result));\n            }\n\n            for (var i = 0; i < hash.faces.length; i++) {\n              if (renderer.styledMode) {\n                delete hash.faces[i].fill;\n              }\n\n              result.faces[i].attr(hash.faces[i], null, complete, continueAnimation);\n            }\n\n            delete hash.faces;\n          }\n\n          return SVGElement.prototype.attr.apply(this, arguments);\n        };\n\n        result.animate = function (params, duration, complete) {\n          if (params && params.faces) {\n            while (result.faces.length > params.faces.length) {\n              result.faces.pop().destroy();\n            }\n\n            while (result.faces.length < params.faces.length) {\n              result.faces.push(renderer.face3d().add(result));\n            }\n\n            for (var i = 0; i < params.faces.length; i++) {\n              result.faces[i].animate(params.faces[i], duration, complete);\n            }\n\n            delete params.faces;\n          }\n\n          return SVGElement.prototype.animate.apply(this, arguments);\n        };\n        /* eslint-enable no-invalid-this */\n\n\n        return result.attr(args);\n      };\n      /**\n       * return result, generalization\n       * @private\n       * @requires highcharts-3d\n       */\n\n\n      SVGRenderer3D.prototype.element3d = function (type, shapeArgs) {\n        // base\n        var ret = this.g(); // extend\n\n        extend(ret, this.elements3d[type]); // init\n\n        ret.initArgs(shapeArgs); // return\n\n        return ret;\n      };\n      /**\n       * generelized, so now use simply\n       * @private\n       */\n\n\n      SVGRenderer3D.prototype.cuboid = function (shapeArgs) {\n        return this.element3d('cuboid', shapeArgs);\n      };\n      /**\n       * Generates a cuboid path and zIndexes\n       * @private\n       */\n\n\n      SVGRenderer3D.prototype.cuboidPath = function (shapeArgs) {\n        var x = shapeArgs.x || 0,\n            y = shapeArgs.y || 0,\n            z = shapeArgs.z || 0,\n            // For side calculation (right/left)\n        // there is a need for height (and other shapeArgs arguments)\n        // to be at least 1px\n        h = shapeArgs.height || 0,\n            w = shapeArgs.width || 0,\n            d = shapeArgs.depth || 0,\n            chart = charts[this.chartIndex],\n            front,\n            back,\n            top,\n            bottom,\n            left,\n            right,\n            shape,\n            path1,\n            path2,\n            path3,\n            isFront,\n            isTop,\n            isRight,\n            options3d = chart.options.chart.options3d,\n            alpha = options3d.alpha,\n            // Priority for x axis is the biggest,\n        // because of x direction has biggest influence on zIndex\n        incrementX = 1000000,\n            // y axis has the smallest priority in case of our charts\n        // (needs to be set because of stacking)\n        incrementY = 10,\n            incrementZ = 100,\n            zIndex = 0,\n            // The 8 corners of the cube\n        pArr = [{\n          x: x,\n          y: y,\n          z: z\n        }, {\n          x: x + w,\n          y: y,\n          z: z\n        }, {\n          x: x + w,\n          y: y + h,\n          z: z\n        }, {\n          x: x,\n          y: y + h,\n          z: z\n        }, {\n          x: x,\n          y: y + h,\n          z: z + d\n        }, {\n          x: x + w,\n          y: y + h,\n          z: z + d\n        }, {\n          x: x + w,\n          y: y,\n          z: z + d\n        }, {\n          x: x,\n          y: y,\n          z: z + d\n        }],\n            forcedSides = [],\n            pickShape; // apply perspective\n\n        pArr = perspective(pArr, chart, shapeArgs.insidePlotArea);\n        /**\n         * helper method to decide which side is visible\n         * @private\n         */\n\n        function mapSidePath(i) {\n          // Added support for 0 value in columns, where height is 0\n          // but the shape is rendered.\n          // Height is used from 1st to 6th element of pArr\n          if (h === 0 && i > 1 && i < 6) {\n            // [2, 3, 4, 5]\n            return {\n              x: pArr[i].x,\n              // when height is 0 instead of cuboid we render plane\n              // so it is needed to add fake 10 height to imitate cuboid\n              // for side calculation\n              y: pArr[i].y + 10,\n              z: pArr[i].z\n            };\n          } // It is needed to calculate dummy sides (front/back) for breaking\n          // points in case of x and depth values. If column has side,\n          // it means that x values of front and back side are different.\n\n\n          if (pArr[0].x === pArr[7].x && i >= 4) {\n            // [4, 5, 6, 7]\n            return {\n              x: pArr[i].x + 10,\n              // when height is 0 instead of cuboid we render plane\n              // so it is needed to add fake 10 height to imitate cuboid\n              // for side calculation\n              y: pArr[i].y,\n              z: pArr[i].z\n            };\n          } // Added dummy depth\n\n\n          if (d === 0 && i < 2 || i > 5) {\n            // [0, 1, 6, 7]\n            return {\n              x: pArr[i].x,\n              // when height is 0 instead of cuboid we render plane\n              // so it is needed to add fake 10 height to imitate cuboid\n              // for side calculation\n              y: pArr[i].y,\n              z: pArr[i].z + 10\n            };\n          }\n\n          return pArr[i];\n        }\n        /**\n         * method creating the final side\n         * @private\n         */\n\n\n        function mapPath(i) {\n          return pArr[i];\n        }\n        /**\n         * First value - path with specific face\n         * Second  value - added information about side for later calculations.\n         * Possible second values are 0 for path1, 1 for path2 and -1 for no\n         * path chosen.\n         * Third value - string containing information about current side\n         * of cuboid for forcing side rendering.\n         * @private\n         */\n\n\n        pickShape = function (verticesIndex1, verticesIndex2, side) {\n          var ret = [[], -1],\n              // An array of vertices for cuboid face\n          face1 = verticesIndex1.map(mapPath),\n              face2 = verticesIndex2.map(mapPath),\n              // dummy face is calculated the same way as standard face, but\n          // if cuboid height is 0 additional height is added so it is\n          // possible to use this vertices array for visible face\n          // calculation\n          dummyFace1 = verticesIndex1.map(mapSidePath),\n              dummyFace2 = verticesIndex2.map(mapSidePath);\n\n          if (shapeArea(face1) < 0) {\n            ret = [face1, 0];\n          } else if (shapeArea(face2) < 0) {\n            ret = [face2, 1];\n          } else if (side) {\n            forcedSides.push(side);\n\n            if (shapeArea(dummyFace1) < 0) {\n              ret = [face1, 0];\n            } else if (shapeArea(dummyFace2) < 0) {\n              ret = [face2, 1];\n            } else {\n              ret = [face1, 0]; // force side calculation.\n            }\n          }\n\n          return ret;\n        }; // front or back\n\n\n        front = [3, 2, 1, 0];\n        back = [7, 6, 5, 4];\n        shape = pickShape(front, back, 'front');\n        path1 = shape[0];\n        isFront = shape[1]; // top or bottom\n\n        top = [1, 6, 7, 0];\n        bottom = [4, 5, 2, 3];\n        shape = pickShape(top, bottom, 'top');\n        path2 = shape[0];\n        isTop = shape[1]; // side\n\n        right = [1, 2, 5, 6];\n        left = [0, 7, 4, 3];\n        shape = pickShape(right, left, 'side');\n        path3 = shape[0];\n        isRight = shape[1];\n        /* New block used for calculating zIndex. It is basing on X, Y and Z\n        position of specific columns. All zIndexes (for X, Y and Z values) are\n        added to the final zIndex, where every value has different priority. The\n        biggest priority is in X and Z directions, the lowest index is for\n        stacked columns (Y direction and the same X and Z positions). Big\n        differences between priorities is made because we need to ensure that\n        even for big changes in Y and Z parameters all columns will be drawn\n        correctly. */\n\n        if (isRight === 1) {\n          // It is needed to connect value with current chart width\n          // for big chart size.\n          zIndex += incrementX * (chart.plotWidth - x);\n        } else if (!isRight) {\n          zIndex += incrementX * x;\n        }\n\n        zIndex += incrementY * (!isTop || // Numbers checked empirically\n        alpha >= 0 && alpha <= 180 || alpha < 360 && alpha > 357.5 ? chart.plotHeight - y : 10 + y);\n\n        if (isFront === 1) {\n          zIndex += incrementZ * z;\n        } else if (!isFront) {\n          zIndex += incrementZ * (1000 - z);\n        }\n\n        return {\n          front: this.toLinePath(path1, true),\n          top: this.toLinePath(path2, true),\n          side: this.toLinePath(path3, true),\n          zIndexes: {\n            group: Math.round(zIndex)\n          },\n          forcedSides: forcedSides,\n          // additional info about zIndexes\n          isFront: isFront,\n          isTop: isTop\n        }; // #4774\n      };\n      /** @private */\n\n\n      SVGRenderer3D.prototype.arc3d = function (attribs) {\n        var wrapper = this.g(),\n            renderer = wrapper.renderer,\n            customAttribs = ['x', 'y', 'r', 'innerR', 'start', 'end', 'depth'];\n        /**\n         * Get custom attributes. Don't mutate the original object and return an\n         * object with only custom attr.\n         * @private\n         */\n\n        function suckOutCustom(params) {\n          var hasCA = false,\n              ca = {},\n              key;\n          params = merge(params); // Don't mutate the original object\n\n          for (key in params) {\n            if (customAttribs.indexOf(key) !== -1) {\n              ca[key] = params[key];\n              delete params[key];\n              hasCA = true;\n            }\n          }\n\n          return hasCA ? [ca, params] : false;\n        }\n\n        attribs = merge(attribs);\n        attribs.alpha = (attribs.alpha || 0) * deg2rad;\n        attribs.beta = (attribs.beta || 0) * deg2rad; // Create the different sub sections of the shape\n\n        wrapper.top = renderer.path();\n        wrapper.side1 = renderer.path();\n        wrapper.side2 = renderer.path();\n        wrapper.inn = renderer.path();\n        wrapper.out = renderer.path();\n        /* eslint-disable no-invalid-this */\n        // Add all faces\n\n        wrapper.onAdd = function () {\n          var parent = wrapper.parentGroup,\n              className = wrapper.attr('class');\n          wrapper.top.add(wrapper); // These faces are added outside the wrapper group because the\n          // z-index relates to neighbour elements as well\n\n          ['out', 'inn', 'side1', 'side2'].forEach(function (face) {\n            wrapper[face].attr({\n              'class': className + ' highcharts-3d-side'\n            }).add(parent);\n          });\n        }; // Cascade to faces\n\n\n        ['addClass', 'removeClass'].forEach(function (fn) {\n          wrapper[fn] = function () {\n            var args = arguments;\n            ['top', 'out', 'inn', 'side1', 'side2'].forEach(function (face) {\n              wrapper[face][fn].apply(wrapper[face], args);\n            });\n          };\n        });\n        /**\n         * Compute the transformed paths and set them to the composite shapes\n         * @private\n         */\n\n        wrapper.setPaths = function (attribs) {\n          var paths = wrapper.renderer.arc3dPath(attribs),\n              zIndex = paths.zTop * 100;\n          wrapper.attribs = attribs;\n          wrapper.top.attr({\n            d: paths.top,\n            zIndex: paths.zTop\n          });\n          wrapper.inn.attr({\n            d: paths.inn,\n            zIndex: paths.zInn\n          });\n          wrapper.out.attr({\n            d: paths.out,\n            zIndex: paths.zOut\n          });\n          wrapper.side1.attr({\n            d: paths.side1,\n            zIndex: paths.zSide1\n          });\n          wrapper.side2.attr({\n            d: paths.side2,\n            zIndex: paths.zSide2\n          }); // show all children\n\n          wrapper.zIndex = zIndex;\n          wrapper.attr({\n            zIndex: zIndex\n          }); // Set the radial gradient center the first time\n\n          if (attribs.center) {\n            wrapper.top.setRadialReference(attribs.center);\n            delete attribs.center;\n          }\n        };\n\n        wrapper.setPaths(attribs);\n        /**\n         * Apply the fill to the top and a darker shade to the sides\n         * @private\n         */\n\n        wrapper.fillSetter = function (value) {\n          var darker = color(value).brighten(-0.1).get();\n          this.fill = value;\n          this.side1.attr({\n            fill: darker\n          });\n          this.side2.attr({\n            fill: darker\n          });\n          this.inn.attr({\n            fill: darker\n          });\n          this.out.attr({\n            fill: darker\n          });\n          this.top.attr({\n            fill: value\n          });\n          return this;\n        }; // Apply the same value to all. These properties cascade down to the\n        // children when set to the composite arc3d.\n\n\n        ['opacity', 'translateX', 'translateY', 'visibility'].forEach(function (setter) {\n          wrapper[setter + 'Setter'] = function (value, key) {\n            wrapper[key] = value;\n            ['out', 'inn', 'side1', 'side2', 'top'].forEach(function (el) {\n              wrapper[el].attr(key, value);\n            });\n          };\n        }); // Override attr to remove shape attributes and use those to set child\n        // paths\n\n        wrapper.attr = function (params) {\n          var ca, paramArr;\n\n          if (typeof params === 'object') {\n            paramArr = suckOutCustom(params);\n\n            if (paramArr) {\n              ca = paramArr[0];\n              arguments[0] = paramArr[1];\n              extend(wrapper.attribs, ca);\n              wrapper.setPaths(wrapper.attribs);\n            }\n          }\n\n          return SVGElement.prototype.attr.apply(wrapper, arguments);\n        }; // Override the animate function by sucking out custom parameters\n        // related to the shapes directly, and update the shapes from the\n        // animation step.\n\n\n        wrapper.animate = function (params, animation, complete) {\n          var paramArr,\n              from = this.attribs,\n              to,\n              anim,\n              randomProp = 'data-' + Math.random().toString(26).substring(2, 9); // Attribute-line properties connected to 3D. These shouldn't have\n          // been in the attribs collection in the first place.\n\n          delete params.center;\n          delete params.z;\n          delete params.alpha;\n          delete params.beta;\n          anim = animObject(pick(animation, this.renderer.globalAnimation));\n\n          if (anim.duration) {\n            paramArr = suckOutCustom(params); // Params need to have a property in order for the step to run\n            // (#5765, #7097, #7437)\n\n            wrapper[randomProp] = 0;\n            params[randomProp] = 1;\n            wrapper[randomProp + 'Setter'] = H.noop;\n\n            if (paramArr) {\n              to = paramArr[0]; // custom attr\n\n              anim.step = function (a, fx) {\n                /**\n                 * @private\n                 */\n                function interpolate(key) {\n                  return from[key] + (pick(to[key], from[key]) - from[key]) * fx.pos;\n                }\n\n                if (fx.prop === randomProp) {\n                  fx.elem.setPaths(merge(from, {\n                    x: interpolate('x'),\n                    y: interpolate('y'),\n                    r: interpolate('r'),\n                    innerR: interpolate('innerR'),\n                    start: interpolate('start'),\n                    end: interpolate('end'),\n                    depth: interpolate('depth')\n                  }));\n                }\n              };\n            }\n\n            animation = anim; // Only when duration (#5572)\n          }\n\n          return SVGElement.prototype.animate.call(this, params, animation, complete);\n        }; // destroy all children\n\n\n        wrapper.destroy = function () {\n          this.top.destroy();\n          this.out.destroy();\n          this.inn.destroy();\n          this.side1.destroy();\n          this.side2.destroy();\n          return SVGElement.prototype.destroy.call(this);\n        }; // hide all children\n\n\n        wrapper.hide = function () {\n          this.top.hide();\n          this.out.hide();\n          this.inn.hide();\n          this.side1.hide();\n          this.side2.hide();\n        };\n\n        wrapper.show = function (inherit) {\n          this.top.show(inherit);\n          this.out.show(inherit);\n          this.inn.show(inherit);\n          this.side1.show(inherit);\n          this.side2.show(inherit);\n        };\n        /* eslint-enable no-invalid-this */\n\n\n        return wrapper;\n      };\n      /**\n       * Generate the paths required to draw a 3D arc.\n       * @private\n       */\n\n\n      SVGRenderer3D.prototype.arc3dPath = function (shapeArgs) {\n        var cx = shapeArgs.x || 0,\n            // x coordinate of the center\n        cy = shapeArgs.y || 0,\n            // y coordinate of the center\n        start = shapeArgs.start || 0,\n            // start angle\n        end = (shapeArgs.end || 0) - 0.00001,\n            // end angle\n        r = shapeArgs.r || 0,\n            // radius\n        ir = shapeArgs.innerR || 0,\n            // inner radius\n        d = shapeArgs.depth || 0,\n            // depth\n        alpha = shapeArgs.alpha || 0,\n            // alpha rotation of the chart\n        beta = shapeArgs.beta || 0; // beta rotation of the chart\n        // Derived Variables\n\n        var cs = Math.cos(start),\n            // cosinus of the start angle\n        ss = Math.sin(start),\n            // sinus of the start angle\n        ce = Math.cos(end),\n            // cosinus of the end angle\n        se = Math.sin(end),\n            // sinus of the end angle\n        rx = r * Math.cos(beta),\n            // x-radius\n        ry = r * Math.cos(alpha),\n            // y-radius\n        irx = ir * Math.cos(beta),\n            // x-radius (inner)\n        iry = ir * Math.cos(alpha),\n            // y-radius (inner)\n        dx = d * Math.sin(beta),\n            // distance between top and bottom in x\n        dy = d * Math.sin(alpha); // distance between top and bottom in y\n        // TOP\n\n        var top = [['M', cx + rx * cs, cy + ry * ss]];\n        top = top.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, start, end, 0, 0));\n        top.push(['L', cx + irx * ce, cy + iry * se]);\n        top = top.concat(SVGRenderer3D.curveTo(cx, cy, irx, iry, end, start, 0, 0));\n        top.push(['Z']); // OUTSIDE\n\n        var b = beta > 0 ? Math.PI / 2 : 0,\n            a = alpha > 0 ? 0 : Math.PI / 2;\n        var start2 = start > -b ? start : end > -b ? -b : start,\n            end2 = end < PI - a ? end : start < PI - a ? PI - a : end,\n            midEnd = 2 * PI - a; // When slice goes over bottom middle, need to add both, left and right\n        // outer side. Additionally, when we cross right hand edge, create sharp\n        // edge. Outer shape/wall:\n        //\n        //            -------\n        //          /    ^    \\\n        //    4)   /   /   \\   \\  1)\n        //        /   /     \\   \\\n        //       /   /       \\   \\\n        // (c)=> ====         ==== <=(d)\n        //       \\   \\       /   /\n        //        \\   \\<=(a)/   /\n        //         \\   \\   /   / <=(b)\n        //    3)    \\    v    /  2)\n        //            -------\n        //\n        // (a) - inner side\n        // (b) - outer side\n        // (c) - left edge (sharp)\n        // (d) - right edge (sharp)\n        // 1..n - rendering order for startAngle = 0, when set to e.g 90, order\n        // changes clockwise (1->2, 2->3, n->1) and counterclockwise for\n        // negative startAngle\n\n        var out = [['M', cx + rx * cos(start2), cy + ry * sin(start2)]];\n        out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, start2, end2, 0, 0)); // When shape is wide, it can cross both, (c) and (d) edges, when using\n        // startAngle\n\n        if (end > midEnd && start < midEnd) {\n          // Go to outer side\n          out.push(['L', cx + rx * cos(end2) + dx, cy + ry * sin(end2) + dy]); // Curve to the right edge of the slice (d)\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, end2, midEnd, dx, dy)); // Go to the inner side\n\n          out.push(['L', cx + rx * cos(midEnd), cy + ry * sin(midEnd)]); // Curve to the true end of the slice\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, midEnd, end, 0, 0)); // Go to the outer side\n\n          out.push(['L', cx + rx * cos(end) + dx, cy + ry * sin(end) + dy]); // Go back to middle (d)\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, end, midEnd, dx, dy));\n          out.push(['L', cx + rx * cos(midEnd), cy + ry * sin(midEnd)]); // Go back to the left edge\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, midEnd, end2, 0, 0)); // But shape can cross also only (c) edge:\n        } else if (end > PI - a && start < PI - a) {\n          // Go to outer side\n          out.push(['L', cx + rx * Math.cos(end2) + dx, cy + ry * Math.sin(end2) + dy]); // Curve to the true end of the slice\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, end2, end, dx, dy)); // Go to the inner side\n\n          out.push(['L', cx + rx * Math.cos(end), cy + ry * Math.sin(end)]); // Go back to the artifical end2\n\n          out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, end, end2, 0, 0));\n        }\n\n        out.push(['L', cx + rx * Math.cos(end2) + dx, cy + ry * Math.sin(end2) + dy]);\n        out = out.concat(SVGRenderer3D.curveTo(cx, cy, rx, ry, end2, start2, dx, dy));\n        out.push(['Z']); // INSIDE\n\n        var inn = [['M', cx + irx * cs, cy + iry * ss]];\n        inn = inn.concat(SVGRenderer3D.curveTo(cx, cy, irx, iry, start, end, 0, 0));\n        inn.push(['L', cx + irx * Math.cos(end) + dx, cy + iry * Math.sin(end) + dy]);\n        inn = inn.concat(SVGRenderer3D.curveTo(cx, cy, irx, iry, end, start, dx, dy));\n        inn.push(['Z']); // SIDES\n\n        var side1 = [['M', cx + rx * cs, cy + ry * ss], ['L', cx + rx * cs + dx, cy + ry * ss + dy], ['L', cx + irx * cs + dx, cy + iry * ss + dy], ['L', cx + irx * cs, cy + iry * ss], ['Z']];\n        var side2 = [['M', cx + rx * ce, cy + ry * se], ['L', cx + rx * ce + dx, cy + ry * se + dy], ['L', cx + irx * ce + dx, cy + iry * se + dy], ['L', cx + irx * ce, cy + iry * se], ['Z']]; // correction for changed position of vanishing point caused by alpha\n        // and beta rotations\n\n        var angleCorr = Math.atan2(dy, -dx),\n            angleEnd = Math.abs(end + angleCorr),\n            angleStart = Math.abs(start + angleCorr),\n            angleMid = Math.abs((start + end) / 2 + angleCorr);\n        /**\n         * set to 0-PI range\n         * @private\n         */\n\n        function toZeroPIRange(angle) {\n          angle = angle % (2 * Math.PI);\n\n          if (angle > Math.PI) {\n            angle = 2 * Math.PI - angle;\n          }\n\n          return angle;\n        }\n\n        angleEnd = toZeroPIRange(angleEnd);\n        angleStart = toZeroPIRange(angleStart);\n        angleMid = toZeroPIRange(angleMid); // *1e5 is to compensate pInt in zIndexSetter\n\n        var incPrecision = 1e5,\n            a1 = angleMid * incPrecision,\n            a2 = angleStart * incPrecision,\n            a3 = angleEnd * incPrecision;\n        return {\n          top: top,\n          // max angle is PI, so this is always higher\n          zTop: Math.PI * incPrecision + 1,\n          out: out,\n          zOut: Math.max(a1, a2, a3),\n          inn: inn,\n          zInn: Math.max(a1, a2, a3),\n          side1: side1,\n          // to keep below zOut and zInn in case of same values\n          zSide1: a3 * 0.99,\n          side2: side2,\n          zSide2: a2 * 0.99\n        };\n      };\n\n      return SVGRenderer3D;\n    }(SVGRenderer);\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n\n    return SVGRenderer3D;\n  });\n\n  _registerModule(_modules, 'Core/Chart/Chart3D.js', [_modules['Core/Color/Color.js'], _modules['Extensions/Math3D.js'], _modules['Core/DefaultOptions.js'], _modules['Core/Utilities.js']], function (Color, Math3D, D, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extension for 3D charts\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var color = Color.parse;\n    var perspective = Math3D.perspective,\n        shapeArea3D = Math3D.shapeArea3D;\n    var genericDefaultOptions = D.defaultOptions;\n    var addEvent = U.addEvent,\n        isArray = U.isArray,\n        merge = U.merge,\n        pick = U.pick,\n        wrap = U.wrap;\n    var Chart3D;\n\n    (function (Chart3D) {\n      /* *\n       *\n       *  Interfaces\n       *\n       * */\n\n      /* *\n       *\n       *  Classes\n       *\n       * */\n      var Composition =\n      /** @class */\n      function () {\n        /* *\n         *\n         *  Constructors\n         *\n         * */\n        function Composition(chart) {\n          this.frame3d = void 0;\n          this.chart = chart;\n        }\n        /* *\n         *\n         *  Functions\n         *\n         * */\n\n\n        Composition.prototype.get3dFrame = function () {\n          var chart = this.chart,\n              options3d = chart.options.chart.options3d,\n              frameOptions = options3d.frame,\n              xm = chart.plotLeft,\n              xp = chart.plotLeft + chart.plotWidth,\n              ym = chart.plotTop,\n              yp = chart.plotTop + chart.plotHeight,\n              zm = 0,\n              zp = options3d.depth,\n              faceOrientation = function (vertexes) {\n            var area = shapeArea3D(vertexes, chart); // Give it 0.5 squared-pixel as a margin for rounding errors\n\n            if (area > 0.5) {\n              return 1;\n            }\n\n            if (area < -0.5) {\n              return -1;\n            }\n\n            return 0;\n          },\n              bottomOrientation = faceOrientation([{\n            x: xm,\n            y: yp,\n            z: zp\n          }, {\n            x: xp,\n            y: yp,\n            z: zp\n          }, {\n            x: xp,\n            y: yp,\n            z: zm\n          }, {\n            x: xm,\n            y: yp,\n            z: zm\n          }]),\n              topOrientation = faceOrientation([{\n            x: xm,\n            y: ym,\n            z: zm\n          }, {\n            x: xp,\n            y: ym,\n            z: zm\n          }, {\n            x: xp,\n            y: ym,\n            z: zp\n          }, {\n            x: xm,\n            y: ym,\n            z: zp\n          }]),\n              leftOrientation = faceOrientation([{\n            x: xm,\n            y: ym,\n            z: zm\n          }, {\n            x: xm,\n            y: ym,\n            z: zp\n          }, {\n            x: xm,\n            y: yp,\n            z: zp\n          }, {\n            x: xm,\n            y: yp,\n            z: zm\n          }]),\n              rightOrientation = faceOrientation([{\n            x: xp,\n            y: ym,\n            z: zp\n          }, {\n            x: xp,\n            y: ym,\n            z: zm\n          }, {\n            x: xp,\n            y: yp,\n            z: zm\n          }, {\n            x: xp,\n            y: yp,\n            z: zp\n          }]),\n              frontOrientation = faceOrientation([{\n            x: xm,\n            y: yp,\n            z: zm\n          }, {\n            x: xp,\n            y: yp,\n            z: zm\n          }, {\n            x: xp,\n            y: ym,\n            z: zm\n          }, {\n            x: xm,\n            y: ym,\n            z: zm\n          }]),\n              backOrientation = faceOrientation([{\n            x: xm,\n            y: ym,\n            z: zp\n          }, {\n            x: xp,\n            y: ym,\n            z: zp\n          }, {\n            x: xp,\n            y: yp,\n            z: zp\n          }, {\n            x: xm,\n            y: yp,\n            z: zp\n          }]),\n              defaultShowFront = false,\n              defaultShowBack = true;\n\n          var defaultShowBottom = false,\n              defaultShowTop = false,\n              defaultShowLeft = false,\n              defaultShowRight = false; // The 'default' criteria to visible faces of the frame is looking\n          // up every axis to decide whenever the left/right//top/bottom sides\n          // of the frame will be shown\n\n          [].concat(chart.xAxis, chart.yAxis, chart.zAxis).forEach(function (axis) {\n            if (axis) {\n              if (axis.horiz) {\n                if (axis.opposite) {\n                  defaultShowTop = true;\n                } else {\n                  defaultShowBottom = true;\n                }\n              } else {\n                if (axis.opposite) {\n                  defaultShowRight = true;\n                } else {\n                  defaultShowLeft = true;\n                }\n              }\n            }\n          });\n\n          var getFaceOptions = function (sources, faceOrientation, defaultVisible) {\n            var faceAttrs = ['size', 'color', 'visible'],\n                options = {};\n\n            for (var i = 0; i < faceAttrs.length; i++) {\n              var attr = faceAttrs[i];\n\n              for (var j = 0; j < sources.length; j++) {\n                if (typeof sources[j] === 'object') {\n                  var val = sources[j][attr];\n\n                  if (typeof val !== 'undefined' && val !== null) {\n                    options[attr] = val;\n                    break;\n                  }\n                }\n              }\n            }\n\n            var isVisible = defaultVisible;\n\n            if (options.visible === true || options.visible === false) {\n              isVisible = options.visible;\n            } else if (options.visible === 'auto') {\n              isVisible = faceOrientation > 0;\n            }\n\n            return {\n              size: pick(options.size, 1),\n              color: pick(options.color, 'none'),\n              frontFacing: faceOrientation > 0,\n              visible: isVisible\n            };\n          }; // docs @TODO: Add all frame options (left, right, top, bottom,\n          // front, back) to apioptions JSDoc once the new system is up.\n\n\n          var ret = {\n            axes: {},\n            // FIXME: Previously, left/right, top/bottom and front/back\n            // pairs shared size and color.\n            // For compatibility and consistency sake, when one face have\n            // size/color/visibility set, the opposite face will default to\n            // the same values. Also, left/right used to be called 'side',\n            // so that's also added as a fallback.\n            bottom: getFaceOptions([frameOptions.bottom, frameOptions.top, frameOptions], bottomOrientation, defaultShowBottom),\n            top: getFaceOptions([frameOptions.top, frameOptions.bottom, frameOptions], topOrientation, defaultShowTop),\n            left: getFaceOptions([frameOptions.left, frameOptions.right, frameOptions.side, frameOptions], leftOrientation, defaultShowLeft),\n            right: getFaceOptions([frameOptions.right, frameOptions.left, frameOptions.side, frameOptions], rightOrientation, defaultShowRight),\n            back: getFaceOptions([frameOptions.back, frameOptions.front, frameOptions], backOrientation, defaultShowBack),\n            front: getFaceOptions([frameOptions.front, frameOptions.back, frameOptions], frontOrientation, defaultShowFront)\n          }; // Decide the bast place to put axis title/labels based on the\n          // visible faces. Ideally, The labels can only be on the edge\n          // between a visible face and an invisble one. Also, the Y label\n          // should be one the left-most edge (right-most if opposite).\n\n          if (options3d.axisLabelPosition === 'auto') {\n            var isValidEdge = function (face1, face2) {\n              return face1.visible !== face2.visible || face1.visible && face2.visible && face1.frontFacing !== face2.frontFacing;\n            };\n\n            var yEdges = [];\n\n            if (isValidEdge(ret.left, ret.front)) {\n              yEdges.push({\n                y: (ym + yp) / 2,\n                x: xm,\n                z: zm,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            if (isValidEdge(ret.left, ret.back)) {\n              yEdges.push({\n                y: (ym + yp) / 2,\n                x: xm,\n                z: zp,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              });\n            }\n\n            if (isValidEdge(ret.right, ret.front)) {\n              yEdges.push({\n                y: (ym + yp) / 2,\n                x: xp,\n                z: zm,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              });\n            }\n\n            if (isValidEdge(ret.right, ret.back)) {\n              yEdges.push({\n                y: (ym + yp) / 2,\n                x: xp,\n                z: zp,\n                xDir: {\n                  x: -1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            var xBottomEdges = [];\n\n            if (isValidEdge(ret.bottom, ret.front)) {\n              xBottomEdges.push({\n                x: (xm + xp) / 2,\n                y: yp,\n                z: zm,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            if (isValidEdge(ret.bottom, ret.back)) {\n              xBottomEdges.push({\n                x: (xm + xp) / 2,\n                y: yp,\n                z: zp,\n                xDir: {\n                  x: -1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            var xTopEdges = [];\n\n            if (isValidEdge(ret.top, ret.front)) {\n              xTopEdges.push({\n                x: (xm + xp) / 2,\n                y: ym,\n                z: zm,\n                xDir: {\n                  x: 1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            if (isValidEdge(ret.top, ret.back)) {\n              xTopEdges.push({\n                x: (xm + xp) / 2,\n                y: ym,\n                z: zp,\n                xDir: {\n                  x: -1,\n                  y: 0,\n                  z: 0\n                }\n              });\n            }\n\n            var zBottomEdges = [];\n\n            if (isValidEdge(ret.bottom, ret.left)) {\n              zBottomEdges.push({\n                z: (zm + zp) / 2,\n                y: yp,\n                x: xm,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              });\n            }\n\n            if (isValidEdge(ret.bottom, ret.right)) {\n              zBottomEdges.push({\n                z: (zm + zp) / 2,\n                y: yp,\n                x: xp,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              });\n            }\n\n            var zTopEdges = [];\n\n            if (isValidEdge(ret.top, ret.left)) {\n              zTopEdges.push({\n                z: (zm + zp) / 2,\n                y: ym,\n                x: xm,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: -1\n                }\n              });\n            }\n\n            if (isValidEdge(ret.top, ret.right)) {\n              zTopEdges.push({\n                z: (zm + zp) / 2,\n                y: ym,\n                x: xp,\n                xDir: {\n                  x: 0,\n                  y: 0,\n                  z: 1\n                }\n              });\n            }\n\n            var pickEdge = function (edges, axis, mult) {\n              if (edges.length === 0) {\n                return null;\n              }\n\n              if (edges.length === 1) {\n                return edges[0];\n              }\n\n              var projections = perspective(edges, chart, false);\n              var best = 0;\n\n              for (var i = 1; i < projections.length; i++) {\n                if (mult * projections[i][axis] > mult * projections[best][axis]) {\n                  best = i;\n                } else if (mult * projections[i][axis] === mult * projections[best][axis] && projections[i].z < projections[best].z) {\n                  best = i;\n                }\n              }\n\n              return edges[best];\n            };\n\n            ret.axes = {\n              y: {\n                'left': pickEdge(yEdges, 'x', -1),\n                'right': pickEdge(yEdges, 'x', +1)\n              },\n              x: {\n                'top': pickEdge(xTopEdges, 'y', -1),\n                'bottom': pickEdge(xBottomEdges, 'y', +1)\n              },\n              z: {\n                'top': pickEdge(zTopEdges, 'y', -1),\n                'bottom': pickEdge(zBottomEdges, 'y', +1)\n              }\n            };\n          } else {\n            ret.axes = {\n              y: {\n                'left': {\n                  x: xm,\n                  z: zm,\n                  xDir: {\n                    x: 1,\n                    y: 0,\n                    z: 0\n                  }\n                },\n                'right': {\n                  x: xp,\n                  z: zm,\n                  xDir: {\n                    x: 0,\n                    y: 0,\n                    z: 1\n                  }\n                }\n              },\n              x: {\n                'top': {\n                  y: ym,\n                  z: zm,\n                  xDir: {\n                    x: 1,\n                    y: 0,\n                    z: 0\n                  }\n                },\n                'bottom': {\n                  y: yp,\n                  z: zm,\n                  xDir: {\n                    x: 1,\n                    y: 0,\n                    z: 0\n                  }\n                }\n              },\n              z: {\n                'top': {\n                  x: defaultShowLeft ? xp : xm,\n                  y: ym,\n                  xDir: defaultShowLeft ? {\n                    x: 0,\n                    y: 0,\n                    z: 1\n                  } : {\n                    x: 0,\n                    y: 0,\n                    z: -1\n                  }\n                },\n                'bottom': {\n                  x: defaultShowLeft ? xp : xm,\n                  y: yp,\n                  xDir: defaultShowLeft ? {\n                    x: 0,\n                    y: 0,\n                    z: 1\n                  } : {\n                    x: 0,\n                    y: 0,\n                    z: -1\n                  }\n                }\n              }\n            };\n          }\n\n          return ret;\n        };\n        /**\n         * Calculate scale of the 3D view. That is required to fit chart's 3D\n         * projection into the actual plotting area. Reported as #4933.\n         *\n         * **Note:**\n         * This function should ideally take the plot values instead of a chart\n         * object, but since the chart object is needed for perspective it is\n         * not practical. Possible to make both getScale and perspective more\n         * logical and also immutable.\n         *\n         * @private\n         * @function getScale\n         *\n         * @param {number} depth\n         * The depth of the chart\n         *\n         * @return {number}\n         * The scale to fit the 3D chart into the plotting area.\n         *\n         * @requires highcharts-3d\n         */\n\n\n        Composition.prototype.getScale = function (depth) {\n          var chart = this.chart,\n              plotLeft = chart.plotLeft,\n              plotRight = chart.plotWidth + plotLeft,\n              plotTop = chart.plotTop,\n              plotBottom = chart.plotHeight + plotTop,\n              originX = plotLeft + chart.plotWidth / 2,\n              originY = plotTop + chart.plotHeight / 2,\n              bbox3d = {\n            minX: Number.MAX_VALUE,\n            maxX: -Number.MAX_VALUE,\n            minY: Number.MAX_VALUE,\n            maxY: -Number.MAX_VALUE\n          };\n          var corners,\n              scale = 1; // Top left corners:\n\n          corners = [{\n            x: plotLeft,\n            y: plotTop,\n            z: 0\n          }, {\n            x: plotLeft,\n            y: plotTop,\n            z: depth\n          }]; // Top right corners:\n\n          [0, 1].forEach(function (i) {\n            corners.push({\n              x: plotRight,\n              y: corners[i].y,\n              z: corners[i].z\n            });\n          }); // All bottom corners:\n\n          [0, 1, 2, 3].forEach(function (i) {\n            corners.push({\n              x: corners[i].x,\n              y: plotBottom,\n              z: corners[i].z\n            });\n          }); // Calculate 3D corners:\n\n          corners = perspective(corners, chart, false); // Get bounding box of 3D element:\n\n          corners.forEach(function (corner) {\n            bbox3d.minX = Math.min(bbox3d.minX, corner.x);\n            bbox3d.maxX = Math.max(bbox3d.maxX, corner.x);\n            bbox3d.minY = Math.min(bbox3d.minY, corner.y);\n            bbox3d.maxY = Math.max(bbox3d.maxY, corner.y);\n          }); // Left edge:\n\n          if (plotLeft > bbox3d.minX) {\n            scale = Math.min(scale, 1 - Math.abs((plotLeft + originX) / (bbox3d.minX + originX)) % 1);\n          } // Right edge:\n\n\n          if (plotRight < bbox3d.maxX) {\n            scale = Math.min(scale, (plotRight - originX) / (bbox3d.maxX - originX));\n          } // Top edge:\n\n\n          if (plotTop > bbox3d.minY) {\n            if (bbox3d.minY < 0) {\n              scale = Math.min(scale, (plotTop + originY) / (-bbox3d.minY + plotTop + originY));\n            } else {\n              scale = Math.min(scale, 1 - (plotTop + originY) / (bbox3d.minY + originY) % 1);\n            }\n          } // Bottom edge:\n\n\n          if (plotBottom < bbox3d.maxY) {\n            scale = Math.min(scale, Math.abs((plotBottom - originY) / (bbox3d.maxY - originY)));\n          }\n\n          return scale;\n        };\n\n        return Composition;\n      }();\n\n      Chart3D.Composition = Composition;\n      /* *\n       *\n       *  Constants\n       *\n       * */\n\n      /**\n       * @optionparent\n       * @private\n       */\n\n      Chart3D.defaultOptions = {\n        chart: {\n          /**\n           * Options to render charts in 3 dimensions. This feature requires\n           * `highcharts-3d.js`, found in the download package or online at\n           * [code.highcharts.com/highcharts-3d.js](https://code.highcharts.com/highcharts-3d.js).\n           *\n           * @since    4.0\n           * @product  highcharts\n           * @requires highcharts-3d\n           */\n          options3d: {\n            /**\n             * Wether to render the chart using the 3D functionality.\n             *\n             * @since   4.0\n             * @product highcharts\n             */\n            enabled: false,\n\n            /**\n             * One of the two rotation angles for the chart.\n             *\n             * @since   4.0\n             * @product highcharts\n             */\n            alpha: 0,\n\n            /**\n             * One of the two rotation angles for the chart.\n             *\n             * @since   4.0\n             * @product highcharts\n             */\n            beta: 0,\n\n            /**\n             * The total depth of the chart.\n             *\n             * @since   4.0\n             * @product highcharts\n             */\n            depth: 100,\n\n            /**\n             * Whether the 3d box should automatically adjust to the chart\n             * plot area.\n             *\n             * @since   4.2.4\n             * @product highcharts\n             */\n            fitToPlot: true,\n\n            /**\n             * Defines the distance the viewer is standing in front of the\n             * chart, this setting is important to calculate the perspective\n             * effect in column and scatter charts. It is not used for 3D\n             * pie charts.\n             *\n             * @since   4.0\n             * @product highcharts\n             */\n            viewDistance: 25,\n\n            /**\n             * Set it to `\"auto\"` to automatically move the labels to the\n             * best edge.\n             *\n             * @type    {\"auto\"|null}\n             * @since   5.0.12\n             * @product highcharts\n             */\n            axisLabelPosition: null,\n\n            /**\n             * Provides the option to draw a frame around the charts by\n             * defining a bottom, front and back panel.\n             *\n             * @since    4.0\n             * @product  highcharts\n             * @requires highcharts-3d\n             */\n            frame: {\n              /**\n               * Whether the frames are visible.\n               */\n              visible: 'default',\n\n              /**\n               * General pixel thickness for the frame faces.\n               */\n              size: 1,\n\n              /**\n               * The bottom of the frame around a 3D chart.\n               *\n               * @since    4.0\n               * @product  highcharts\n               * @requires highcharts-3d\n               */\n\n              /**\n               * The color of the panel.\n               *\n               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n               * @default   transparent\n               * @since     4.0\n               * @product   highcharts\n               * @apioption chart.options3d.frame.bottom.color\n               */\n\n              /**\n               * The thickness of the panel.\n               *\n               * @type      {number}\n               * @default   1\n               * @since     4.0\n               * @product   highcharts\n               * @apioption chart.options3d.frame.bottom.size\n               */\n\n              /**\n               * Whether to display the frame. Possible values are `true`,\n               * `false`, `\"auto\"` to display only the frames behind the\n               * data, and `\"default\"` to display faces behind the data\n               * based on the axis layout, ignoring the point of view.\n               *\n               * @sample {highcharts} highcharts/3d/scatter-frame/\n               *         Auto frames\n               *\n               * @type      {boolean|\"default\"|\"auto\"}\n               * @default   default\n               * @since     5.0.12\n               * @product   highcharts\n               * @apioption chart.options3d.frame.bottom.visible\n               */\n\n              /**\n               * The bottom of the frame around a 3D chart.\n               */\n              bottom: {},\n\n              /**\n               * The top of the frame around a 3D chart.\n               *\n               * @extends chart.options3d.frame.bottom\n               */\n              top: {},\n\n              /**\n               * The left side of the frame around a 3D chart.\n               *\n               * @extends chart.options3d.frame.bottom\n               */\n              left: {},\n\n              /**\n               * The right of the frame around a 3D chart.\n               *\n               * @extends chart.options3d.frame.bottom\n               */\n              right: {},\n\n              /**\n               * The back side of the frame around a 3D chart.\n               *\n               * @extends chart.options3d.frame.bottom\n               */\n              back: {},\n\n              /**\n               * The front of the frame around a 3D chart.\n               *\n               * @extends chart.options3d.frame.bottom\n               */\n              front: {}\n            }\n          }\n        }\n      };\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /* eslint-disable no-invalid-this, valid-jsdoc */\n\n      /**\n       * @private\n       */\n\n      function compose(ChartClass, FxClass) {\n        var chartProto = ChartClass.prototype;\n        var fxProto = FxClass.prototype;\n        /**\n         * Shorthand to check the is3d flag.\n         * @private\n         * @return {boolean}\n         * Whether it is a 3D chart.\n         */\n\n        chartProto.is3d = function () {\n          return Boolean(this.options.chart.options3d && this.options.chart.options3d.enabled); // #4280\n        };\n\n        chartProto.propsRequireDirtyBox.push('chart.options3d');\n        chartProto.propsRequireUpdateSeries.push('chart.options3d');\n        /**\n         * Animation setter for matrix property.\n         * @private\n         */\n\n        fxProto.matrixSetter = function () {\n          var interpolated;\n\n          if (this.pos < 1 && (isArray(this.start) || isArray(this.end))) {\n            var start = this.start || [1, 0, 0, 1, 0, 0],\n                end = this.end || [1, 0, 0, 1, 0, 0];\n            interpolated = [];\n\n            for (var i = 0; i < 6; i++) {\n              interpolated.push(this.pos * end[i] + (1 - this.pos) * start[i]);\n            }\n          } else {\n            interpolated = this.end;\n          }\n\n          this.elem.attr(this.prop, interpolated, null, true);\n        };\n\n        merge(true, genericDefaultOptions, Chart3D.defaultOptions);\n        addEvent(ChartClass, 'init', onInit);\n        addEvent(ChartClass, 'addSeries', onAddSeries);\n        addEvent(ChartClass, 'afterDrawChartBox', onAfterDrawChartBox);\n        addEvent(ChartClass, 'afterGetContainer', onAfterGetContainer);\n        addEvent(ChartClass, 'afterInit', onAfterInit);\n        addEvent(ChartClass, 'afterSetChartSize', onAfterSetChartSize);\n        addEvent(ChartClass, 'beforeRedraw', onBeforeRedraw);\n        addEvent(ChartClass, 'beforeRender', onBeforeRender);\n        wrap(chartProto, 'isInsidePlot', wrapIsInsidePlot);\n        wrap(ChartClass, 'renderSeries', wrapRenderSeries);\n        wrap(ChartClass, 'setClassName', wrapSetClassName);\n      }\n\n      Chart3D.compose = compose;\n      /**\n       * Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to\n       * the real 'scatter3d' series type. (#8407)\n       * @private\n       */\n\n      function onAddSeries(e) {\n        if (this.is3d()) {\n          if (e.options.type === 'scatter') {\n            e.options.type = 'scatter3d';\n          }\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function onAfterDrawChartBox() {\n        if (this.chart3d && this.is3d()) {\n          var chart = this,\n              renderer = chart.renderer,\n              options3d = chart.options.chart.options3d,\n              frame = chart.chart3d.get3dFrame(),\n              xm = chart.plotLeft,\n              xp = chart.plotLeft + chart.plotWidth,\n              ym = chart.plotTop,\n              yp = chart.plotTop + chart.plotHeight,\n              zm = 0,\n              zp = options3d.depth,\n              xmm = xm - (frame.left.visible ? frame.left.size : 0),\n              xpp = xp + (frame.right.visible ? frame.right.size : 0),\n              ymm = ym - (frame.top.visible ? frame.top.size : 0),\n              ypp = yp + (frame.bottom.visible ? frame.bottom.size : 0),\n              zmm = zm - (frame.front.visible ? frame.front.size : 0),\n              zpp = zp + (frame.back.visible ? frame.back.size : 0),\n              verb = chart.hasRendered ? 'animate' : 'attr';\n          chart.chart3d.frame3d = frame;\n\n          if (!chart.frameShapes) {\n            chart.frameShapes = {\n              bottom: renderer.polyhedron().add(),\n              top: renderer.polyhedron().add(),\n              left: renderer.polyhedron().add(),\n              right: renderer.polyhedron().add(),\n              back: renderer.polyhedron().add(),\n              front: renderer.polyhedron().add()\n            };\n          }\n\n          chart.frameShapes.bottom[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-bottom',\n            zIndex: frame.bottom.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.bottom.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }],\n              enabled: frame.bottom.visible\n            }, {\n              fill: color(frame.bottom.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.bottom.visible\n            }, {\n              fill: color(frame.bottom.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.bottom.visible && !frame.left.visible\n            }, {\n              fill: color(frame.bottom.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.bottom.visible && !frame.right.visible\n            }, {\n              fill: color(frame.bottom.color).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.bottom.visible && !frame.front.visible\n            }, {\n              fill: color(frame.bottom.color).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.bottom.visible && !frame.back.visible\n            }]\n          });\n          chart.frameShapes.top[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-top',\n            zIndex: frame.top.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.top.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }],\n              enabled: frame.top.visible\n            }, {\n              fill: color(frame.top.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.top.visible\n            }, {\n              fill: color(frame.top.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.top.visible && !frame.left.visible\n            }, {\n              fill: color(frame.top.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.top.visible && !frame.right.visible\n            }, {\n              fill: color(frame.top.color).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.top.visible && !frame.front.visible\n            }, {\n              fill: color(frame.top.color).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.top.visible && !frame.back.visible\n            }]\n          });\n          chart.frameShapes.left[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-left',\n            zIndex: frame.left.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.left.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }],\n              enabled: frame.left.visible && !frame.bottom.visible\n            }, {\n              fill: color(frame.left.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }],\n              enabled: frame.left.visible && !frame.top.visible\n            }, {\n              fill: color(frame.left.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }],\n              enabled: frame.left.visible\n            }, {\n              fill: color(frame.left.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xm,\n                y: ym,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.left.visible\n            }, {\n              fill: color(frame.left.color).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.left.visible && !frame.front.visible\n            }, {\n              fill: color(frame.left.color).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.left.visible && !frame.back.visible\n            }]\n          });\n          chart.frameShapes.right[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-right',\n            zIndex: frame.right.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.right.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }],\n              enabled: frame.right.visible && !frame.bottom.visible\n            }, {\n              fill: color(frame.right.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }],\n              enabled: frame.right.visible && !frame.top.visible\n            }, {\n              fill: color(frame.right.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.right.visible\n            }, {\n              fill: color(frame.right.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }],\n              enabled: frame.right.visible\n            }, {\n              fill: color(frame.right.color).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.right.visible && !frame.front.visible\n            }, {\n              fill: color(frame.right.color).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.right.visible && !frame.back.visible\n            }]\n          });\n          chart.frameShapes.back[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-back',\n            zIndex: frame.back.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.back.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.back.visible && !frame.bottom.visible\n            }, {\n              fill: color(frame.back.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.back.visible && !frame.top.visible\n            }, {\n              fill: color(frame.back.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xm,\n                y: ym,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.back.visible && !frame.left.visible\n            }, {\n              fill: color(frame.back.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }],\n              enabled: frame.back.visible && !frame.right.visible\n            }, {\n              fill: color(frame.back.color).get(),\n              vertexes: [{\n                x: xm,\n                y: ym,\n                z: zp\n              }, {\n                x: xp,\n                y: ym,\n                z: zp\n              }, {\n                x: xp,\n                y: yp,\n                z: zp\n              }, {\n                x: xm,\n                y: yp,\n                z: zp\n              }],\n              enabled: frame.back.visible\n            }, {\n              fill: color(frame.back.color).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zpp\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zpp\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zpp\n              }],\n              enabled: frame.back.visible\n            }]\n          });\n          chart.frameShapes.front[verb]({\n            'class': 'highcharts-3d-frame highcharts-3d-frame-front',\n            zIndex: frame.front.frontFacing ? -1000 : 1000,\n            faces: [{\n              fill: color(frame.front.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.front.visible && !frame.bottom.visible\n            }, {\n              fill: color(frame.front.color).brighten(0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.front.visible && !frame.top.visible\n            }, {\n              fill: color(frame.front.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }],\n              enabled: frame.front.visible && !frame.left.visible\n            }, {\n              fill: color(frame.front.color).brighten(-0.1).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.front.visible && !frame.right.visible\n            }, {\n              fill: color(frame.front.color).get(),\n              vertexes: [{\n                x: xp,\n                y: ym,\n                z: zm\n              }, {\n                x: xm,\n                y: ym,\n                z: zm\n              }, {\n                x: xm,\n                y: yp,\n                z: zm\n              }, {\n                x: xp,\n                y: yp,\n                z: zm\n              }],\n              enabled: frame.front.visible\n            }, {\n              fill: color(frame.front.color).get(),\n              vertexes: [{\n                x: xpp,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ypp,\n                z: zmm\n              }, {\n                x: xmm,\n                y: ymm,\n                z: zmm\n              }, {\n                x: xpp,\n                y: ymm,\n                z: zmm\n              }],\n              enabled: frame.front.visible\n            }]\n          });\n        }\n      }\n      /**\n       * Add the required CSS classes for column sides (#6018)\n       * @private\n       */\n\n\n      function onAfterGetContainer() {\n        if (this.styledMode) {\n          // Add definitions used by brighter and darker faces of the cuboids.\n          [{\n            name: 'darker',\n            slope: 0.6\n          }, {\n            name: 'brighter',\n            slope: 1.4\n          }].forEach(function (cfg) {\n            this.renderer.definition({\n              tagName: 'filter',\n              attributes: {\n                id: 'highcharts-' + cfg.name\n              },\n              children: [{\n                tagName: 'feComponentTransfer',\n                children: [{\n                  tagName: 'feFuncR',\n                  attributes: {\n                    type: 'linear',\n                    slope: cfg.slope\n                  }\n                }, {\n                  tagName: 'feFuncG',\n                  attributes: {\n                    type: 'linear',\n                    slope: cfg.slope\n                  }\n                }, {\n                  tagName: 'feFuncB',\n                  attributes: {\n                    type: 'linear',\n                    slope: cfg.slope\n                  }\n                }]\n              }]\n            });\n          }, this);\n        }\n      }\n      /**\n       * Legacy support for HC < 6 to make 'scatter' series in a 3D chart route to\n       * the real 'scatter3d' series type. (#8407)\n       * @private\n       */\n\n\n      function onAfterInit() {\n        var options = this.options;\n\n        if (this.is3d()) {\n          (options.series || []).forEach(function (s) {\n            var type = s.type || options.chart.type || options.chart.defaultSeriesType;\n\n            if (type === 'scatter') {\n              s.type = 'scatter3d';\n            }\n          });\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function onAfterSetChartSize() {\n        var chart = this,\n            options3d = chart.options.chart.options3d;\n\n        if (chart.chart3d && chart.is3d()) {\n          // Add a 0-360 normalisation for alfa and beta angles in 3d graph\n          if (options3d) {\n            options3d.alpha = options3d.alpha % 360 + (options3d.alpha >= 0 ? 0 : 360);\n            options3d.beta = options3d.beta % 360 + (options3d.beta >= 0 ? 0 : 360);\n          }\n\n          var inverted = chart.inverted,\n              clipBox = chart.clipBox,\n              margin = chart.margin,\n              x = inverted ? 'y' : 'x',\n              y = inverted ? 'x' : 'y',\n              w = inverted ? 'height' : 'width',\n              h = inverted ? 'width' : 'height';\n          clipBox[x] = -(margin[3] || 0);\n          clipBox[y] = -(margin[0] || 0);\n          clipBox[w] = chart.chartWidth + (margin[3] || 0) + (margin[1] || 0);\n          clipBox[h] = chart.chartHeight + (margin[0] || 0) + (margin[2] || 0); // Set scale, used later in perspective method():\n          // getScale uses perspective, so scale3d has to be reset.\n\n          chart.scale3d = 1;\n\n          if (options3d.fitToPlot === true) {\n            chart.scale3d = chart.chart3d.getScale(options3d.depth);\n          } // Recalculate the 3d frame with every call of setChartSize,\n          // instead of doing it after every redraw(). It avoids ticks\n          // and axis title outside of chart.\n\n\n          chart.chart3d.frame3d = chart.chart3d.get3dFrame(); // #7942\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function onBeforeRedraw() {\n        if (this.is3d()) {\n          // Set to force a redraw of all elements\n          this.isDirtyBox = true;\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function onBeforeRender() {\n        if (this.chart3d && this.is3d()) {\n          this.chart3d.frame3d = this.chart3d.get3dFrame();\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function onInit() {\n        if (!this.chart3d) {\n          this.chart3d = new Composition(this);\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function wrapIsInsidePlot(proceed) {\n        return this.is3d() || proceed.apply(this, [].slice.call(arguments, 1));\n      }\n      /**\n       * Draw the series in the reverse order (#3803, #3917)\n       * @private\n       */\n\n\n      function wrapRenderSeries(proceed) {\n        var series,\n            i = this.series.length;\n\n        if (this.is3d()) {\n          while (i--) {\n            series = this.series[i];\n            series.translate();\n            series.render();\n          }\n        } else {\n          proceed.call(this);\n        }\n      }\n      /**\n       * @private\n       */\n\n\n      function wrapSetClassName(proceed) {\n        proceed.apply(this, [].slice.call(arguments, 1));\n\n        if (this.is3d()) {\n          this.container.className += ' highcharts-3d-chart';\n        }\n      }\n    })(Chart3D || (Chart3D = {}));\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    /* *\n     *\n     *  API Declarations\n     *\n     * */\n\n    /**\n     * Note: As of v5.0.12, `frame.left` or `frame.right` should be used instead.\n     *\n     * The side for the frame around a 3D chart.\n     *\n     * @deprecated\n     * @since     4.0\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption chart.options3d.frame.side\n     */\n\n    /**\n     * The color of the panel.\n     *\n     * @deprecated\n     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n     * @default   transparent\n     * @since     4.0\n     * @product   highcharts\n     * @apioption chart.options3d.frame.side.color\n     */\n\n    /**\n     * The thickness of the panel.\n     *\n     * @deprecated\n     * @type      {number}\n     * @default   1\n     * @since     4.0\n     * @product   highcharts\n     * @apioption chart.options3d.frame.side.size\n     */\n\n\n    ''; // keeps doclets above in JS file\n\n    return Chart3D;\n  });\n\n  _registerModule(_modules, 'Core/Axis/ZAxis.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Utilities.js']], function (Axis, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var addEvent = U.addEvent,\n        merge = U.merge,\n        pick = U.pick,\n        splat = U.splat;\n    /* eslint-disable valid-jsdoc */\n\n    /**\n     * 3D chart with support of z coordinates.\n     * @private\n     * @class\n     */\n\n    var ZChart =\n    /** @class */\n    function () {\n      function ZChart() {}\n      /* *\n       *\n       *  Static Functions\n       *\n       * */\n\n\n      ZChart.compose = function (ChartClass) {\n        addEvent(ChartClass, 'afterGetAxes', ZChart.onAfterGetAxes);\n        var chartProto = ChartClass.prototype;\n        chartProto.addZAxis = ZChart.wrapAddZAxis;\n        chartProto.collectionsWithInit.zAxis = [chartProto.addZAxis];\n        chartProto.collectionsWithUpdate.push('zAxis');\n      };\n      /**\n       * Get the Z axis in addition to the default X and Y.\n       * @private\n       */\n\n\n      ZChart.onAfterGetAxes = function () {\n        var chart = this;\n        var options = this.options;\n        var zAxisOptions = options.zAxis = splat(options.zAxis || {});\n\n        if (!chart.is3d()) {\n          return;\n        }\n\n        chart.zAxis = [];\n        zAxisOptions.forEach(function (axisOptions, i) {\n          axisOptions.index = i; // Z-Axis is shown horizontally, so it's kind of a X-Axis\n\n          axisOptions.isX = true;\n          chart.addZAxis(axisOptions).setScale();\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      ZChart.wrapAddZAxis = function (options) {\n        return new ZAxis(this, options);\n      };\n\n      return ZChart;\n    }();\n    /**\n     * 3D axis for z coordinates.\n     */\n\n\n    var ZAxis =\n    /** @class */\n    function (_super) {\n      __extends(ZAxis, _super);\n      /* *\n       *\n       *  Constructors\n       *\n       * */\n\n\n      function ZAxis(chart, userOptions) {\n        var _this = _super.call(this, chart, userOptions) || this;\n\n        _this.isZAxis = true;\n        return _this;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n\n      ZAxis.prototype.getSeriesExtremes = function () {\n        var axis = this;\n        var chart = axis.chart;\n        axis.hasVisibleSeries = false; // Reset properties in case we're redrawing (#3353)\n\n        axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = void 0;\n\n        if (axis.stacking) {\n          axis.stacking.buildStacks();\n        } // loop through this axis' series\n\n\n        axis.series.forEach(function (series) {\n          if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n            var seriesOptions = series.options,\n                zData = void 0,\n                threshold = seriesOptions.threshold;\n            axis.hasVisibleSeries = true; // Validate threshold in logarithmic axes\n\n            if (axis.positiveValuesOnly && threshold <= 0) {\n              threshold = void 0;\n            }\n\n            zData = series.zData;\n\n            if (zData.length) {\n              axis.dataMin = Math.min(pick(axis.dataMin, zData[0]), Math.min.apply(null, zData));\n              axis.dataMax = Math.max(pick(axis.dataMax, zData[0]), Math.max.apply(null, zData));\n            }\n          }\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      ZAxis.prototype.setAxisSize = function () {\n        var axis = this;\n        var chart = axis.chart;\n\n        _super.prototype.setAxisSize.call(this);\n\n        axis.width = axis.len = chart.options.chart.options3d && chart.options.chart.options3d.depth || 0;\n        axis.right = chart.chartWidth - axis.width - axis.left;\n      };\n      /**\n       * @private\n       */\n\n\n      ZAxis.prototype.setOptions = function (userOptions) {\n        userOptions = merge({\n          offset: 0,\n          lineWidth: 0\n        }, userOptions); // #14793, this used to be set on the prototype\n\n        this.isZAxis = true;\n\n        _super.prototype.setOptions.call(this, userOptions);\n\n        this.coll = 'zAxis';\n      };\n      /* *\n       *\n       *  Static Properties\n       *\n       * */\n\n\n      ZAxis.ZChartComposition = ZChart;\n      return ZAxis;\n    }(Axis);\n\n    return ZAxis;\n  });\n\n  _registerModule(_modules, 'Core/Axis/Tick3D.js', [_modules['Core/Utilities.js']], function (U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extenstion for 3d axes\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var addEvent = U.addEvent,\n        extend = U.extend,\n        wrap = U.wrap;\n    /* eslint-disable valid-jsdoc */\n\n    /**\n     * Tick with 3D support\n     * @private\n     * @class\n     */\n\n    var Tick3D =\n    /** @class */\n    function () {\n      function Tick3D() {}\n      /* *\n       *\n       *  Static Functions\n       *\n       * */\n\n      /**\n       * @private\n       */\n\n\n      Tick3D.compose = function (TickClass) {\n        addEvent(TickClass, 'afterGetLabelPosition', Tick3D.onAfterGetLabelPosition);\n        var tickProto = TickClass.prototype;\n        wrap(tickProto, 'getMarkPath', Tick3D.wrapGetMarkPath);\n      };\n      /**\n       * @private\n       */\n\n\n      Tick3D.onAfterGetLabelPosition = function (e) {\n        var axis3D = this.axis.axis3D;\n\n        if (axis3D) {\n          extend(e.pos, axis3D.fix3dPosition(e.pos));\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Tick3D.wrapGetMarkPath = function (proceed) {\n        var chart = this.axis.chart;\n        var axis3D = this.axis.axis3D;\n        var path = proceed.apply(this, [].slice.call(arguments, 1));\n\n        if (axis3D) {\n          var start = path[0];\n          var end = path[1];\n\n          if (start[0] === 'M' && end[0] === 'L') {\n            var pArr = [axis3D.fix3dPosition({\n              x: start[1],\n              y: start[2],\n              z: 0\n            }), axis3D.fix3dPosition({\n              x: end[1],\n              y: end[2],\n              z: 0\n            })];\n            return this.axis.chart.renderer.toLineSegments(pArr);\n          }\n        }\n\n        return path;\n      };\n\n      return Tick3D;\n    }();\n\n    return Tick3D;\n  });\n\n  _registerModule(_modules, 'Core/Axis/Axis3D.js', [_modules['Core/Globals.js'], _modules['Extensions/Math3D.js'], _modules['Core/Axis/Tick.js'], _modules['Core/Axis/Tick3D.js'], _modules['Core/Utilities.js']], function (H, Math3D, Tick, Tick3D, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extenstion for 3d axes\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var deg2rad = H.deg2rad;\n    var perspective = Math3D.perspective,\n        perspective3D = Math3D.perspective3D,\n        shapeArea = Math3D.shapeArea;\n    var addEvent = U.addEvent,\n        merge = U.merge,\n        pick = U.pick,\n        wrap = U.wrap;\n    /* *\n     *\n     *  Classes\n     *\n     * */\n\n    /* eslint-disable valid-jsdoc */\n\n    /**\n     * Adds 3D support to axes.\n     * @private\n     * @class\n     */\n\n    var Axis3DAdditions =\n    /** @class */\n    function () {\n      /* *\n       *\n       *  Constructors\n       *\n       * */\n\n      /**\n       * @private\n       */\n      function Axis3DAdditions(axis) {\n        this.axis = axis;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /**\n       * @private\n       * @param {Highcharts.Axis} axis\n       * Related axis.\n       * @param {Highcharts.Position3DObject} pos\n       * Position to fix.\n       * @param {boolean} [isTitle]\n       * Whether this is a title position.\n       * @return {Highcharts.Position3DObject}\n       * Fixed position.\n       */\n\n\n      Axis3DAdditions.prototype.fix3dPosition = function (pos, isTitle) {\n        var axis3D = this;\n        var axis = axis3D.axis;\n        var chart = axis.chart; // Do not do this if the chart is not 3D\n\n        if (axis.coll === 'colorAxis' || !chart.chart3d || !chart.is3d()) {\n          return pos;\n        }\n\n        var alpha = deg2rad * chart.options.chart.options3d.alpha,\n            beta = deg2rad * chart.options.chart.options3d.beta,\n            positionMode = pick(isTitle && axis.options.title.position3d, axis.options.labels.position3d),\n            skew = pick(isTitle && axis.options.title.skew3d, axis.options.labels.skew3d),\n            frame = chart.chart3d.frame3d,\n            plotLeft = chart.plotLeft,\n            plotRight = chart.plotWidth + plotLeft,\n            plotTop = chart.plotTop,\n            plotBottom = chart.plotHeight + plotTop;\n        var offsetX = 0,\n            offsetY = 0,\n            vecX,\n            vecY = {\n          x: 0,\n          y: 1,\n          z: 0\n        },\n            // Indicates that we are labelling an X or Z axis on the \"back\" of\n        // the chart\n        reverseFlap = false;\n        pos = axis.axis3D.swapZ({\n          x: pos.x,\n          y: pos.y,\n          z: 0\n        });\n\n        if (axis.isZAxis) {\n          // Z Axis\n          if (axis.opposite) {\n            if (frame.axes.z.top === null) {\n              return {};\n            }\n\n            offsetY = pos.y - plotTop;\n            pos.x = frame.axes.z.top.x;\n            pos.y = frame.axes.z.top.y;\n            vecX = frame.axes.z.top.xDir;\n            reverseFlap = !frame.top.frontFacing;\n          } else {\n            if (frame.axes.z.bottom === null) {\n              return {};\n            }\n\n            offsetY = pos.y - plotBottom;\n            pos.x = frame.axes.z.bottom.x;\n            pos.y = frame.axes.z.bottom.y;\n            vecX = frame.axes.z.bottom.xDir;\n            reverseFlap = !frame.bottom.frontFacing;\n          }\n        } else if (axis.horiz) {\n          // X Axis\n          if (axis.opposite) {\n            if (frame.axes.x.top === null) {\n              return {};\n            }\n\n            offsetY = pos.y - plotTop;\n            pos.y = frame.axes.x.top.y;\n            pos.z = frame.axes.x.top.z;\n            vecX = frame.axes.x.top.xDir;\n            reverseFlap = !frame.top.frontFacing;\n          } else {\n            if (frame.axes.x.bottom === null) {\n              return {};\n            }\n\n            offsetY = pos.y - plotBottom;\n            pos.y = frame.axes.x.bottom.y;\n            pos.z = frame.axes.x.bottom.z;\n            vecX = frame.axes.x.bottom.xDir;\n            reverseFlap = !frame.bottom.frontFacing;\n          }\n        } else {\n          // Y Axis\n          if (axis.opposite) {\n            if (frame.axes.y.right === null) {\n              return {};\n            }\n\n            offsetX = pos.x - plotRight;\n            pos.x = frame.axes.y.right.x;\n            pos.z = frame.axes.y.right.z;\n            vecX = frame.axes.y.right.xDir; // Rotate 90 on opposite edge\n\n            vecX = {\n              x: vecX.z,\n              y: vecX.y,\n              z: -vecX.x\n            };\n          } else {\n            if (frame.axes.y.left === null) {\n              return {};\n            }\n\n            offsetX = pos.x - plotLeft;\n            pos.x = frame.axes.y.left.x;\n            pos.z = frame.axes.y.left.z;\n            vecX = frame.axes.y.left.xDir;\n          }\n        }\n\n        if (positionMode === 'chart') {// Labels preserve their direction relative to the chart\n          // nothing to do\n        } else if (positionMode === 'flap') {\n          // Labels are rotated around the axis direction to face the screen\n          if (!axis.horiz) {\n            // Y Axis\n            vecX = {\n              x: Math.cos(beta),\n              y: 0,\n              z: Math.sin(beta)\n            };\n          } else {\n            // X and Z Axis\n            var sin = Math.sin(alpha);\n            var cos = Math.cos(alpha);\n\n            if (axis.opposite) {\n              sin = -sin;\n            }\n\n            if (reverseFlap) {\n              sin = -sin;\n            }\n\n            vecY = {\n              x: vecX.z * sin,\n              y: cos,\n              z: -vecX.x * sin\n            };\n          }\n        } else if (positionMode === 'ortho') {\n          // Labels will be rotated to be ortogonal to the axis\n          if (!axis.horiz) {\n            // Y Axis\n            vecX = {\n              x: Math.cos(beta),\n              y: 0,\n              z: Math.sin(beta)\n            };\n          } else {\n            // X and Z Axis\n            var sina = Math.sin(alpha);\n            var cosa = Math.cos(alpha);\n            var sinb = Math.sin(beta);\n            var cosb = Math.cos(beta);\n            var vecZ = {\n              x: sinb * cosa,\n              y: -sina,\n              z: -cosa * cosb\n            };\n            vecY = {\n              x: vecX.y * vecZ.z - vecX.z * vecZ.y,\n              y: vecX.z * vecZ.x - vecX.x * vecZ.z,\n              z: vecX.x * vecZ.y - vecX.y * vecZ.x\n            };\n            var scale = 1 / Math.sqrt(vecY.x * vecY.x + vecY.y * vecY.y + vecY.z * vecY.z);\n\n            if (reverseFlap) {\n              scale = -scale;\n            }\n\n            vecY = {\n              x: scale * vecY.x,\n              y: scale * vecY.y,\n              z: scale * vecY.z\n            };\n          }\n        } else {\n          // positionMode  == 'offset'\n          // Labels will be skewd to maintain vertical / horizontal offsets\n          // from axis\n          if (!axis.horiz) {\n            // Y Axis\n            vecX = {\n              x: Math.cos(beta),\n              y: 0,\n              z: Math.sin(beta)\n            };\n          } else {\n            // X and Z Axis\n            vecY = {\n              x: Math.sin(beta) * Math.sin(alpha),\n              y: Math.cos(alpha),\n              z: -Math.cos(beta) * Math.sin(alpha)\n            };\n          }\n        }\n\n        pos.x += offsetX * vecX.x + offsetY * vecY.x;\n        pos.y += offsetX * vecX.y + offsetY * vecY.y;\n        pos.z += offsetX * vecX.z + offsetY * vecY.z;\n        var projected = perspective([pos], axis.chart)[0];\n\n        if (skew) {\n          // Check if the label text would be mirrored\n          var isMirrored = shapeArea(perspective([pos, {\n            x: pos.x + vecX.x,\n            y: pos.y + vecX.y,\n            z: pos.z + vecX.z\n          }, {\n            x: pos.x + vecY.x,\n            y: pos.y + vecY.y,\n            z: pos.z + vecY.z\n          }], axis.chart)) < 0;\n\n          if (isMirrored) {\n            vecX = {\n              x: -vecX.x,\n              y: -vecX.y,\n              z: -vecX.z\n            };\n          }\n\n          var pointsProjected = perspective([{\n            x: pos.x,\n            y: pos.y,\n            z: pos.z\n          }, {\n            x: pos.x + vecX.x,\n            y: pos.y + vecX.y,\n            z: pos.z + vecX.z\n          }, {\n            x: pos.x + vecY.x,\n            y: pos.y + vecY.y,\n            z: pos.z + vecY.z\n          }], axis.chart);\n          projected.matrix = [pointsProjected[1].x - pointsProjected[0].x, pointsProjected[1].y - pointsProjected[0].y, pointsProjected[2].x - pointsProjected[0].x, pointsProjected[2].y - pointsProjected[0].y, projected.x, projected.y];\n          projected.matrix[4] -= projected.x * projected.matrix[0] + projected.y * projected.matrix[2];\n          projected.matrix[5] -= projected.x * projected.matrix[1] + projected.y * projected.matrix[3];\n        }\n\n        return projected;\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3DAdditions.prototype.swapZ = function (p, insidePlotArea) {\n        var axis = this.axis;\n\n        if (axis.isZAxis) {\n          var plotLeft = insidePlotArea ? 0 : axis.chart.plotLeft;\n          return {\n            x: plotLeft + p.z,\n            y: p.y,\n            z: p.x - plotLeft\n          };\n        }\n\n        return p;\n      };\n\n      return Axis3DAdditions;\n    }();\n    /**\n     * Axis with 3D support.\n     * @private\n     * @class\n     */\n\n\n    var Axis3D =\n    /** @class */\n    function () {\n      function Axis3D() {}\n      /* *\n       *\n       *  Static Functions\n       *\n       * */\n\n      /**\n       * Extends axis class with 3D support.\n       * @private\n       */\n\n\n      Axis3D.compose = function (AxisClass) {\n        merge(true, AxisClass.defaultOptions, Axis3D.defaultOptions);\n        AxisClass.keepProps.push('axis3D');\n        addEvent(AxisClass, 'init', Axis3D.onInit);\n        addEvent(AxisClass, 'afterSetOptions', Axis3D.onAfterSetOptions);\n        addEvent(AxisClass, 'drawCrosshair', Axis3D.onDrawCrosshair);\n        var axisProto = AxisClass.prototype;\n        wrap(axisProto, 'getLinePath', Axis3D.wrapGetLinePath);\n        wrap(axisProto, 'getPlotBandPath', Axis3D.wrapGetPlotBandPath);\n        wrap(axisProto, 'getPlotLinePath', Axis3D.wrapGetPlotLinePath);\n        wrap(axisProto, 'getSlotWidth', Axis3D.wrapGetSlotWidth);\n        wrap(axisProto, 'getTitlePosition', Axis3D.wrapGetTitlePosition);\n        Tick3D.compose(Tick);\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.onAfterSetOptions = function () {\n        var axis = this;\n        var chart = axis.chart;\n        var options = axis.options;\n\n        if (chart.is3d && chart.is3d() && axis.coll !== 'colorAxis') {\n          options.tickWidth = pick(options.tickWidth, 0);\n          options.gridLineWidth = pick(options.gridLineWidth, 1);\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.onDrawCrosshair = function (e) {\n        var axis = this;\n\n        if (axis.chart.is3d() && axis.coll !== 'colorAxis') {\n          if (e.point) {\n            e.point.crosshairPos = axis.isXAxis ? e.point.axisXpos : axis.len - e.point.axisYpos;\n          }\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.onInit = function () {\n        var axis = this;\n\n        if (!axis.axis3D) {\n          axis.axis3D = new Axis3DAdditions(axis);\n        }\n      };\n      /**\n       * Do not draw axislines in 3D.\n       * @private\n       */\n\n\n      Axis3D.wrapGetLinePath = function (proceed) {\n        var axis = this; // Do not do this if the chart is not 3D\n\n        if (!axis.chart.is3d() || axis.coll === 'colorAxis') {\n          return proceed.apply(axis, [].slice.call(arguments, 1));\n        }\n\n        return [];\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.wrapGetPlotBandPath = function (proceed) {\n        // Do not do this if the chart is not 3D\n        if (!this.chart.is3d() || this.coll === 'colorAxis') {\n          return proceed.apply(this, [].slice.call(arguments, 1));\n        }\n\n        var args = arguments,\n            from = args[1],\n            to = args[2],\n            path = [],\n            fromPath = this.getPlotLinePath({\n          value: from\n        }),\n            toPath = this.getPlotLinePath({\n          value: to\n        });\n\n        if (fromPath && toPath) {\n          for (var i = 0; i < fromPath.length; i += 2) {\n            var fromStartSeg = fromPath[i],\n                fromEndSeg = fromPath[i + 1],\n                toStartSeg = toPath[i],\n                toEndSeg = toPath[i + 1];\n\n            if (fromStartSeg[0] === 'M' && fromEndSeg[0] === 'L' && toStartSeg[0] === 'M' && toEndSeg[0] === 'L') {\n              path.push(fromStartSeg, fromEndSeg, toEndSeg, // lineTo instead of moveTo\n              ['L', toStartSeg[1], toStartSeg[2]], ['Z']);\n            }\n          }\n        }\n\n        return path;\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.wrapGetPlotLinePath = function (proceed) {\n        var axis = this,\n            axis3D = axis.axis3D,\n            chart = axis.chart,\n            path = proceed.apply(axis, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D\n\n        if (axis.coll === 'colorAxis' || !chart.chart3d || !chart.is3d()) {\n          return path;\n        }\n\n        if (path === null) {\n          return path;\n        }\n\n        var options3d = chart.options.chart.options3d,\n            d = axis.isZAxis ? chart.plotWidth : options3d.depth,\n            frame = chart.chart3d.frame3d,\n            startSegment = path[0],\n            endSegment = path[1];\n        var pArr,\n            pathSegments = [];\n\n        if (startSegment[0] === 'M' && endSegment[0] === 'L') {\n          pArr = [axis3D.swapZ({\n            x: startSegment[1],\n            y: startSegment[2],\n            z: 0\n          }), axis3D.swapZ({\n            x: startSegment[1],\n            y: startSegment[2],\n            z: d\n          }), axis3D.swapZ({\n            x: endSegment[1],\n            y: endSegment[2],\n            z: 0\n          }), axis3D.swapZ({\n            x: endSegment[1],\n            y: endSegment[2],\n            z: d\n          })];\n\n          if (!this.horiz) {\n            // Y-Axis\n            if (frame.front.visible) {\n              pathSegments.push(pArr[0], pArr[2]);\n            }\n\n            if (frame.back.visible) {\n              pathSegments.push(pArr[1], pArr[3]);\n            }\n\n            if (frame.left.visible) {\n              pathSegments.push(pArr[0], pArr[1]);\n            }\n\n            if (frame.right.visible) {\n              pathSegments.push(pArr[2], pArr[3]);\n            }\n          } else if (this.isZAxis) {\n            // Z-Axis\n            if (frame.left.visible) {\n              pathSegments.push(pArr[0], pArr[2]);\n            }\n\n            if (frame.right.visible) {\n              pathSegments.push(pArr[1], pArr[3]);\n            }\n\n            if (frame.top.visible) {\n              pathSegments.push(pArr[0], pArr[1]);\n            }\n\n            if (frame.bottom.visible) {\n              pathSegments.push(pArr[2], pArr[3]);\n            }\n          } else {\n            // X-Axis\n            if (frame.front.visible) {\n              pathSegments.push(pArr[0], pArr[2]);\n            }\n\n            if (frame.back.visible) {\n              pathSegments.push(pArr[1], pArr[3]);\n            }\n\n            if (frame.top.visible) {\n              pathSegments.push(pArr[0], pArr[1]);\n            }\n\n            if (frame.bottom.visible) {\n              pathSegments.push(pArr[2], pArr[3]);\n            }\n          }\n\n          pathSegments = perspective(pathSegments, this.chart, false);\n        }\n\n        return chart.renderer.toLineSegments(pathSegments);\n      };\n      /**\n       * Wrap getSlotWidth function to calculate individual width value for each\n       * slot (#8042).\n       * @private\n       */\n\n\n      Axis3D.wrapGetSlotWidth = function (proceed, tick) {\n        var axis = this,\n            chart = axis.chart,\n            ticks = axis.ticks,\n            gridGroup = axis.gridGroup;\n\n        if (axis.categories && chart.frameShapes && chart.is3d() && gridGroup && tick && tick.label) {\n          var firstGridLine = gridGroup.element.childNodes[0].getBBox(),\n              frame3DLeft = chart.frameShapes.left.getBBox(),\n              options3d = chart.options.chart.options3d,\n              origin_1 = {\n            x: chart.plotWidth / 2,\n            y: chart.plotHeight / 2,\n            z: options3d.depth / 2,\n            vd: pick(options3d.depth, 1) * pick(options3d.viewDistance, 0)\n          },\n              tickId = tick.pos,\n              prevTick = ticks[tickId - 1],\n              nextTick = ticks[tickId + 1];\n          var labelPos = void 0,\n              prevLabelPos = void 0,\n              nextLabelPos = void 0; // Check whether the tick is not the first one and previous tick\n          // exists, then calculate position of previous label.\n\n          if (tickId !== 0 && prevTick && prevTick.label && prevTick.label.xy) {\n            prevLabelPos = perspective3D({\n              x: prevTick.label.xy.x,\n              y: prevTick.label.xy.y,\n              z: null\n            }, origin_1, origin_1.vd);\n          } // If next label position is defined, then recalculate its position\n          // basing on the perspective.\n\n\n          if (nextTick && nextTick.label && nextTick.label.xy) {\n            nextLabelPos = perspective3D({\n              x: nextTick.label.xy.x,\n              y: nextTick.label.xy.y,\n              z: null\n            }, origin_1, origin_1.vd);\n          }\n\n          labelPos = {\n            x: tick.label.xy.x,\n            y: tick.label.xy.y,\n            z: null\n          };\n          labelPos = perspective3D(labelPos, origin_1, origin_1.vd); // If tick is first one, check whether next label position is\n          // already calculated, then return difference between the first and\n          // the second label. If there is no next label position calculated,\n          // return the difference between the first grid line and left 3d\n          // frame.\n\n          return Math.abs(prevLabelPos ? labelPos.x - prevLabelPos.x : nextLabelPos ? nextLabelPos.x - labelPos.x : firstGridLine.x - frame3DLeft.x);\n        }\n\n        return proceed.apply(axis, [].slice.call(arguments, 1));\n      };\n      /**\n       * @private\n       */\n\n\n      Axis3D.wrapGetTitlePosition = function (proceed) {\n        var pos = proceed.apply(this, [].slice.call(arguments, 1));\n        return this.axis3D ? this.axis3D.fix3dPosition(pos, true) : pos;\n      };\n      /* *\n       *\n       *  Static Properties\n       *\n       * */\n\n      /**\n       * @optionparent xAxis\n       */\n\n\n      Axis3D.defaultOptions = {\n        labels: {\n          /**\n           * Defines how the labels are be repositioned according to the 3D\n           * chart orientation.\n           *\n           * - `'offset'`: Maintain a fixed horizontal/vertical distance from\n           *   the tick marks, despite the chart orientation. This is the\n           *   backwards compatible behavior, and causes skewing of X and Z\n           *   axes.\n           *\n           * - `'chart'`: Preserve 3D position relative to the chart. This\n           *   looks nice, but hard to read if the text isn't forward-facing.\n           *\n           * - `'flap'`: Rotated text along the axis to compensate for the\n           *   chart orientation. This tries to maintain text as legible as\n           *   possible on all orientations.\n           *\n           * - `'ortho'`: Rotated text along the axis direction so that the\n           *   labels are orthogonal to the axis. This is very similar to\n           *   `'flap'`, but prevents skewing the labels (X and Y scaling are\n           *   still present).\n           *\n           * @sample highcharts/3d/skewed-labels/\n           *         Skewed labels\n           *\n           * @since      5.0.15\n           * @validvalue ['offset', 'chart', 'flap', 'ortho']\n           * @product    highcharts\n           * @requires   highcharts-3d\n           */\n          position3d: 'offset',\n\n          /**\n           * If enabled, the axis labels will skewed to follow the\n           * perspective.\n           *\n           * This will fix overlapping labels and titles, but texts become\n           * less legible due to the distortion.\n           *\n           * The final appearance depends heavily on `labels.position3d`.\n           *\n           * @sample highcharts/3d/skewed-labels/\n           *         Skewed labels\n           *\n           * @since    5.0.15\n           * @product  highcharts\n           * @requires highcharts-3d\n           */\n          skew3d: false\n        },\n        title: {\n          /**\n           * Defines how the title is repositioned according to the 3D chart\n           * orientation.\n           *\n           * - `'offset'`: Maintain a fixed horizontal/vertical distance from\n           *   the tick marks, despite the chart orientation. This is the\n           *   backwards compatible behavior, and causes skewing of X and Z\n           *   axes.\n           *\n           * - `'chart'`: Preserve 3D position relative to the chart. This\n           *   looks nice, but hard to read if the text isn't forward-facing.\n           *\n           * - `'flap'`: Rotated text along the axis to compensate for the\n           *   chart orientation. This tries to maintain text as legible as\n           *   possible on all orientations.\n           *\n           * - `'ortho'`: Rotated text along the axis direction so that the\n           *   labels are orthogonal to the axis. This is very similar to\n           *   `'flap'`, but prevents skewing the labels (X and Y scaling are\n           *   still present).\n           *\n           * - `undefined`: Will use the config from `labels.position3d`\n           *\n           * @sample highcharts/3d/skewed-labels/\n           *         Skewed labels\n           *\n           * @type     {\"offset\"|\"chart\"|\"flap\"|\"ortho\"|null}\n           * @since    5.0.15\n           * @product  highcharts\n           * @requires highcharts-3d\n           */\n          position3d: null,\n\n          /**\n           * If enabled, the axis title will skewed to follow the perspective.\n           *\n           * This will fix overlapping labels and titles, but texts become\n           * less legible due to the distortion.\n           *\n           * The final appearance depends heavily on `title.position3d`.\n           *\n           * A `null` value will use the config from `labels.skew3d`.\n           *\n           * @sample highcharts/3d/skewed-labels/\n           *         Skewed labels\n           *\n           * @type     {boolean|null}\n           * @since    5.0.15\n           * @product  highcharts\n           * @requires highcharts-3d\n           */\n          skew3d: null\n        }\n      };\n      return Axis3D;\n    }();\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n\n    return Axis3D;\n  });\n\n  _registerModule(_modules, 'Core/Series/Series3D.js', [_modules['Extensions/Math3D.js'], _modules['Core/Series/Series.js'], _modules['Core/Utilities.js']], function (Math3D, Series, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Extension to the Series object in 3D charts.\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var perspective = Math3D.perspective;\n    var addEvent = U.addEvent,\n        extend = U.extend,\n        merge = U.merge,\n        pick = U.pick,\n        isNumber = U.isNumber;\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    var Series3D =\n    /** @class */\n    function (_super) {\n      __extends(Series3D, _super);\n\n      function Series3D() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /* eslint-disable valid-jsdoc */\n\n\n      Series3D.prototype.translate = function () {\n        _super.prototype.translate.apply(this, arguments);\n\n        if (this.chart.is3d()) {\n          this.translate3dPoints();\n        }\n      };\n      /**\n       * Translate the plotX, plotY properties and add plotZ.\n       * @private\n       */\n\n\n      Series3D.prototype.translate3dPoints = function () {\n        var series = this,\n            seriesOptions = series.options,\n            chart = series.chart,\n            zAxis = pick(series.zAxis, chart.options.zAxis[0]),\n            rawPoints = [],\n            rawPoint,\n            projectedPoints,\n            projectedPoint,\n            zValue,\n            i,\n            rawPointsX = [],\n            stack = seriesOptions.stacking ? isNumber(seriesOptions.stack) ? seriesOptions.stack : 0 : series.index || 0;\n        series.zPadding = stack * (seriesOptions.depth || 0 + (seriesOptions.groupZPadding || 1));\n\n        for (i = 0; i < series.data.length; i++) {\n          rawPoint = series.data[i];\n\n          if (zAxis && zAxis.translate) {\n            zValue = zAxis.logarithmic && zAxis.val2lin ? zAxis.val2lin(rawPoint.z) : rawPoint.z; // #4562\n\n            rawPoint.plotZ = zAxis.translate(zValue);\n            rawPoint.isInside = rawPoint.isInside ? zValue >= zAxis.min && zValue <= zAxis.max : false;\n          } else {\n            rawPoint.plotZ = series.zPadding;\n          }\n\n          rawPoint.axisXpos = rawPoint.plotX;\n          rawPoint.axisYpos = rawPoint.plotY;\n          rawPoint.axisZpos = rawPoint.plotZ;\n          rawPoints.push({\n            x: rawPoint.plotX,\n            y: rawPoint.plotY,\n            z: rawPoint.plotZ\n          });\n          rawPointsX.push(rawPoint.plotX || 0);\n        }\n\n        series.rawPointsX = rawPointsX;\n        projectedPoints = perspective(rawPoints, chart, true);\n\n        for (i = 0; i < series.data.length; i++) {\n          rawPoint = series.data[i];\n          projectedPoint = projectedPoints[i];\n          rawPoint.plotX = projectedPoint.x;\n          rawPoint.plotY = projectedPoint.y;\n          rawPoint.plotZ = projectedPoint.z;\n        }\n      };\n      /* *\n       *\n       *  Static Properties\n       *\n       * */\n\n\n      Series3D.defaultOptions = merge(Series.defaultOptions);\n      return Series3D;\n    }(Series);\n    /* *\n     *\n     *  Compatibility\n     *\n     * */\n\n    /* eslint-disable no-invalid-this */\n\n\n    addEvent(Series, 'afterTranslate', function () {\n      if (this.chart.is3d()) {\n        this.translate3dPoints();\n      }\n    });\n    /* eslint-enable no-invalid-this */\n\n    extend(Series.prototype, {\n      translate3dPoints: Series3D.prototype.translate3dPoints\n    });\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    return Series3D;\n  });\n\n  _registerModule(_modules, 'Series/Column3D/Column3DComposition.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Core/Series/Series.js'], _modules['Extensions/Math3D.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Extensions/Stacking.js'], _modules['Core/Utilities.js']], function (ColumnSeries, H, Series, Math3D, SeriesRegistry, StackItem, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var columnProto = ColumnSeries.prototype;\n    var svg = H.svg;\n    var perspective = Math3D.perspective;\n    var addEvent = U.addEvent,\n        pick = U.pick,\n        wrap = U.wrap;\n    /* *\n     *\n     *  Functions\n     *\n     * */\n\n    /* eslint-disable no-invalid-this */\n\n    /**\n     * @private\n     * @param {Highcharts.Chart} chart\n     * Chart with stacks\n     * @param {string} stacking\n     * Stacking option\n     */\n\n    function retrieveStacks(chart, stacking) {\n      var series = chart.series,\n          stacks = {\n        totalStacks: 0\n      };\n      var stackNumber,\n          i = 1;\n      series.forEach(function (s) {\n        stackNumber = pick(s.options.stack, stacking ? 0 : series.length - 1 - s.index); // #3841, #4532\n\n        if (!stacks[stackNumber]) {\n          stacks[stackNumber] = {\n            series: [s],\n            position: i\n          };\n          i++;\n        } else {\n          stacks[stackNumber].series.push(s);\n        }\n      });\n      stacks.totalStacks = i + 1;\n      return stacks;\n    }\n\n    wrap(columnProto, 'translate', function (proceed) {\n      proceed.apply(this, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D\n\n      if (this.chart.is3d()) {\n        this.translate3dShapes();\n      }\n    }); // Don't use justifyDataLabel when point is outsidePlot\n\n    wrap(Series.prototype, 'justifyDataLabel', function (proceed) {\n      return !arguments[2].outside3dPlot ? proceed.apply(this, [].slice.call(arguments, 1)) : false;\n    });\n\n    columnProto.translate3dPoints = function () {};\n\n    columnProto.translate3dShapes = function () {\n      var series = this,\n          chart = series.chart,\n          seriesOptions = series.options,\n          depth = seriesOptions.depth,\n          stack = seriesOptions.stacking ? seriesOptions.stack || 0 : series.index,\n          // #4743\n      z = stack * (depth + (seriesOptions.groupZPadding || 1)),\n          borderCrisp = series.borderWidth % 2 ? 0.5 : 0,\n          point2dPos; // Position of point in 2D, used for 3D position calculation\n\n      if (chart.inverted && !series.yAxis.reversed) {\n        borderCrisp *= -1;\n      }\n\n      if (seriesOptions.grouping !== false) {\n        z = 0;\n      }\n\n      z += seriesOptions.groupZPadding || 1;\n      series.data.forEach(function (point) {\n        // #7103 Reset outside3dPlot flag\n        point.outside3dPlot = null;\n\n        if (point.y !== null) {\n          var shapeArgs_1 = point.shapeArgs,\n              tooltipPos = point.tooltipPos,\n              // Array for final shapeArgs calculation.\n          // We are checking two dimensions (x and y).\n          dimensions = [['x', 'width'], ['y', 'height']],\n              borderlessBase_1; // Crisped rects can have +/- 0.5 pixels offset.\n          // #3131 We need to check if column is inside plotArea.\n\n          dimensions.forEach(function (d) {\n            borderlessBase_1 = shapeArgs_1[d[0]] - borderCrisp;\n\n            if (borderlessBase_1 < 0) {\n              // If borderLessBase is smaller than 0, it is needed to set\n              // its value to 0 or 0.5 depending on borderWidth\n              // borderWidth may be even or odd.\n              shapeArgs_1[d[1]] += shapeArgs_1[d[0]] + borderCrisp;\n              shapeArgs_1[d[0]] = -borderCrisp;\n              borderlessBase_1 = 0;\n            }\n\n            if (borderlessBase_1 + shapeArgs_1[d[1]] > series[d[0] + 'Axis'].len && // Do not change height/width of column if 0 (#6708)\n            shapeArgs_1[d[1]] !== 0) {\n              shapeArgs_1[d[1]] = series[d[0] + 'Axis'].len - shapeArgs_1[d[0]];\n            }\n\n            if ( // Do not remove columns with zero height/width.\n            shapeArgs_1[d[1]] !== 0 && (shapeArgs_1[d[0]] >= series[d[0] + 'Axis'].len || shapeArgs_1[d[0]] + shapeArgs_1[d[1]] <= borderCrisp)) {\n              // Set args to 0 if column is outside the chart.\n              for (var key in shapeArgs_1) {\n                // eslint-disable-line guard-for-in\n                // #13840\n                shapeArgs_1[key] = key === 'y' ? -9999 : 0;\n              } // #7103 outside3dPlot flag is set on Points which are\n              // currently outside of plot.\n\n\n              point.outside3dPlot = true;\n            }\n          }); // Change from 2d to 3d\n\n          if (point.shapeType === 'rect') {\n            point.shapeType = 'cuboid';\n          }\n\n          shapeArgs_1.z = z;\n          shapeArgs_1.depth = depth;\n          shapeArgs_1.insidePlotArea = true; // Point's position in 2D\n\n          point2dPos = {\n            x: shapeArgs_1.x + shapeArgs_1.width / 2,\n            y: shapeArgs_1.y,\n            z: z + depth / 2 // The center of column in Z dimension\n\n          }; // Recalculate point positions for inverted graphs\n\n          if (chart.inverted) {\n            point2dPos.x = shapeArgs_1.height;\n            point2dPos.y = point.clientX;\n          } // Calculate and store point's position in 3D,\n          // using perspective method.\n\n\n          point.plot3d = perspective([point2dPos], chart, true, false)[0]; // Translate the tooltip position in 3d space\n\n          tooltipPos = perspective([{\n            x: tooltipPos[0],\n            y: tooltipPos[1],\n            z: z + depth / 2 // The center of column in Z dimension\n\n          }], chart, true, false)[0];\n          point.tooltipPos = [tooltipPos.x, tooltipPos.y];\n        }\n      }); // store for later use #4067\n\n      series.z = z;\n    };\n\n    wrap(columnProto, 'animate', function (proceed) {\n      if (!this.chart.is3d()) {\n        proceed.apply(this, [].slice.call(arguments, 1));\n      } else {\n        var args = arguments,\n            init = args[1],\n            yAxis_1 = this.yAxis,\n            series_1 = this,\n            reversed_1 = this.yAxis.reversed;\n\n        if (svg) {\n          // VML is too slow anyway\n          if (init) {\n            series_1.data.forEach(function (point) {\n              if (point.y !== null) {\n                point.height = point.shapeArgs.height;\n                point.shapey = point.shapeArgs.y; // #2968\n\n                point.shapeArgs.height = 1;\n\n                if (!reversed_1) {\n                  if (point.stackY) {\n                    point.shapeArgs.y = point.plotY + yAxis_1.translate(point.stackY);\n                  } else {\n                    point.shapeArgs.y = point.plotY + (point.negative ? -point.height : point.height);\n                  }\n                }\n              }\n            });\n          } else {\n            // run the animation\n            series_1.data.forEach(function (point) {\n              if (point.y !== null) {\n                point.shapeArgs.height = point.height;\n                point.shapeArgs.y = point.shapey; // #2968\n                // null value do not have a graphic\n\n                if (point.graphic) {\n                  point.graphic[point.outside3dPlot ? 'attr' : 'animate'](point.shapeArgs, series_1.options.animation);\n                }\n              }\n            }); // redraw datalabels to the correct position\n\n            this.drawDataLabels();\n          }\n        }\n      }\n    }); // In case of 3d columns there is no sense to add this columns to a specific\n    // series group - if series is added to a group all columns will have the same\n    // zIndex in comparison with different series.\n\n    wrap(columnProto, 'plotGroup', function (proceed, prop, _name, _visibility, _zIndex, parent) {\n      if (prop !== 'dataLabelsGroup') {\n        if (this.chart.is3d()) {\n          if (this[prop]) {\n            delete this[prop];\n          }\n\n          if (parent) {\n            if (!this.chart.columnGroup) {\n              this.chart.columnGroup = this.chart.renderer.g('columnGroup').add(parent);\n            }\n\n            this[prop] = this.chart.columnGroup;\n            this.chart.columnGroup.attr(this.getPlotBox());\n            this[prop].survive = true;\n\n            if (prop === 'group' || prop === 'markerGroup') {\n              arguments[3] = 'visible'; // For 3D column group and markerGroup should be visible\n            }\n          }\n        }\n      }\n\n      return proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    }); // When series is not added to group it is needed to change setVisible method to\n    // allow correct Legend funcionality. This wrap is basing on pie chart series.\n\n    wrap(columnProto, 'setVisible', function (proceed, vis) {\n      var series = this;\n\n      if (series.chart.is3d()) {\n        series.data.forEach(function (point) {\n          point.visible = point.options.visible = vis = typeof vis === 'undefined' ? !pick(series.visible, point.visible) : vis;\n          series.options.data[series.data.indexOf(point)] = point.options;\n\n          if (point.graphic) {\n            point.graphic.attr({\n              visibility: vis ? 'visible' : 'hidden'\n            });\n          }\n        });\n      }\n\n      proceed.apply(this, Array.prototype.slice.call(arguments, 1));\n    });\n    addEvent(ColumnSeries, 'afterInit', function () {\n      if (this.chart.is3d()) {\n        var series = this,\n            seriesOptions = this.options,\n            grouping = seriesOptions.grouping,\n            stacking = seriesOptions.stacking,\n            reversedStacks = this.yAxis.options.reversedStacks,\n            z = 0; // @todo grouping === true ?\n\n        if (!(typeof grouping !== 'undefined' && !grouping)) {\n          var stacks = retrieveStacks(this.chart, stacking),\n              stack = seriesOptions.stack || 0,\n              i = // position within the stack\n          void 0; // position within the stack\n\n          for (i = 0; i < stacks[stack].series.length; i++) {\n            if (stacks[stack].series[i] === this) {\n              break;\n            }\n          }\n\n          z = 10 * (stacks.totalStacks - stacks[stack].position) + (reversedStacks ? i : -i); // #4369\n          // In case when axis is reversed, columns are also reversed inside\n          // the group (#3737)\n\n          if (!this.xAxis.reversed) {\n            z = stacks.totalStacks * 10 - z;\n          }\n        }\n\n        seriesOptions.depth = seriesOptions.depth || 25;\n        series.z = series.z || 0;\n        seriesOptions.zIndex = z;\n      }\n    }); // eslint-disable-next-line valid-jsdoc\n\n    /**\n     * @private\n     */\n\n    function pointAttribs(proceed) {\n      var attr = proceed.apply(this, [].slice.call(arguments, 1));\n\n      if (this.chart.is3d && this.chart.is3d()) {\n        // Set the fill color to the fill color to provide a smooth edge\n        attr.stroke = this.options.edgeColor || attr.fill;\n        attr['stroke-width'] = pick(this.options.edgeWidth, 1); // #4055\n      }\n\n      return attr;\n    } // eslint-disable-next-line valid-jsdoc\n\n    /**\n     * In 3D mode, all column-series are rendered in one main group. Because of that\n     * we need to apply inactive state on all points.\n     * @private\n     */\n\n\n    function setState(proceed, state, inherit) {\n      var is3d = this.chart.is3d && this.chart.is3d();\n\n      if (is3d) {\n        this.options.inactiveOtherPoints = true;\n      }\n\n      proceed.call(this, state, inherit);\n\n      if (is3d) {\n        this.options.inactiveOtherPoints = false;\n      }\n    } // eslint-disable-next-line valid-jsdoc\n\n    /**\n     * In 3D mode, simple checking for a new shape to animate is not enough.\n     * Additionally check if graphic is a group of elements\n     * @private\n     */\n\n\n    function hasNewShapeType(proceed) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      return this.series.chart.is3d() ? this.graphic && this.graphic.element.nodeName !== 'g' : proceed.apply(this, args);\n    }\n\n    wrap(columnProto, 'pointAttribs', pointAttribs);\n    wrap(columnProto, 'setState', setState);\n    wrap(columnProto.pointClass.prototype, 'hasNewShapeType', hasNewShapeType);\n\n    if (SeriesRegistry.seriesTypes.columnRange) {\n      var columnRangeProto = SeriesRegistry.seriesTypes.columnrange.prototype;\n      wrap(columnRangeProto, 'pointAttribs', pointAttribs);\n      wrap(columnRangeProto, 'setState', setState);\n      wrap(columnRangeProto.pointClass.prototype, 'hasNewShapeType', hasNewShapeType);\n      columnRangeProto.plotGroup = columnProto.plotGroup;\n      columnRangeProto.setVisible = columnProto.setVisible;\n    }\n\n    wrap(Series.prototype, 'alignDataLabel', function (proceed, point, dataLabel, options, alignTo) {\n      var chart = this.chart; // In 3D we need to pass point.outsidePlot option to the justifyDataLabel\n      // method for disabling justifying dataLabels in columns outside plot\n\n      options.outside3dPlot = point.outside3dPlot; // Only do this for 3D columns and it's derived series\n\n      if (chart.is3d() && this.is('column')) {\n        var series = this,\n            seriesOptions = series.options,\n            inside = pick(options.inside, !!series.options.stacking),\n            options3d = chart.options.chart.options3d,\n            xOffset = point.pointWidth / 2 || 0;\n        var dLPosition = {\n          x: alignTo.x + xOffset,\n          y: alignTo.y,\n          z: series.z + seriesOptions.depth / 2\n        };\n\n        if (chart.inverted) {\n          // Inside dataLabels are positioned according to above\n          // logic and there is no need to position them using\n          // non-3D algorighm (that use alignTo.width)\n          if (inside) {\n            alignTo.width = 0;\n            dLPosition.x += point.shapeArgs.height / 2;\n          } // When chart is upside down\n          // (alpha angle between 180 and 360 degrees)\n          // it is needed to add column width to calculated value.\n\n\n          if (options3d.alpha >= 90 && options3d.alpha <= 270) {\n            dLPosition.y += point.shapeArgs.width;\n          }\n        } // dLPosition is recalculated for 3D graphs\n\n\n        dLPosition = perspective([dLPosition], chart, true, false)[0];\n        alignTo.x = dLPosition.x - xOffset; // #7103 If point is outside of plotArea, hide data label.\n\n        alignTo.y = point.outside3dPlot ? -9e9 : dLPosition.y;\n      }\n\n      proceed.apply(this, [].slice.call(arguments, 1));\n    }); // Added stackLabels position calculation for 3D charts.\n\n    wrap(StackItem.prototype, 'getStackBox', function (proceed, chart, stackItem, x, y, xWidth, h, axis) {\n      var stackBox = proceed.apply(this, [].slice.call(arguments, 1)); // Only do this for 3D graph\n\n      if (chart.is3d() && stackItem.base) {\n        // First element of stackItem.base is an index of base series.\n        var baseSeriesInd = +stackItem.base.split(',')[0];\n        var columnSeries = chart.series[baseSeriesInd];\n        var options3d = chart.options.chart.options3d; // Only do this if base series is a column or inherited type,\n        // use its barW, z and depth parameters\n        // for correct stackLabels position calculation\n\n        if (columnSeries && columnSeries instanceof SeriesRegistry.seriesTypes.column) {\n          var dLPosition = {\n            x: stackBox.x + (chart.inverted ? h : xWidth / 2),\n            y: stackBox.y,\n            z: columnSeries.options.depth / 2\n          };\n\n          if (chart.inverted) {\n            // Do not use default offset calculation logic\n            // for 3D inverted stackLabels.\n            stackBox.width = 0; // When chart is upside down\n            // (alpha angle between 180 and 360 degrees)\n            // it is needed to add column width to calculated value.\n\n            if (options3d.alpha >= 90 && options3d.alpha <= 270) {\n              dLPosition.y += xWidth;\n            }\n          }\n\n          dLPosition = perspective([dLPosition], chart, true, false)[0];\n          stackBox.x = dLPosition.x - xWidth / 2;\n          stackBox.y = dLPosition.y;\n        }\n      }\n\n      return stackBox;\n    });\n    /*\n        @merge v6.2\n        @todo\n        EXTENSION FOR 3D CYLINDRICAL COLUMNS\n        Not supported\n    */\n\n    /*\n    let defaultOptions = H.getOptions();\n    defaultOptions.plotOptions.cylinder =\n        merge(defaultOptions.plotOptions.column);\n    let CylinderSeries = extendClass(seriesTypes.column, {\n        type: 'cylinder'\n    });\n    seriesTypes.cylinder = CylinderSeries;\n     wrap(seriesTypes.cylinder.prototype, 'translate', function (proceed) {\n        proceed.apply(this, [].slice.call(arguments, 1));\n         // Do not do this if the chart is not 3D\n        if (!this.chart.is3d()) {\n            return;\n        }\n         let series = this,\n            chart = series.chart,\n            options = chart.options,\n            cylOptions = options.plotOptions.cylinder,\n            options3d = options.chart.options3d,\n            depth = cylOptions.depth || 0,\n            alpha = chart.alpha3d;\n         let z = cylOptions.stacking ?\n            (this.options.stack || 0) * depth :\n            series._i * depth;\n        z += depth / 2;\n         if (cylOptions.grouping !== false) { z = 0; }\n         each(series.data, function (point) {\n            let shapeArgs = point.shapeArgs,\n                deg2rad = H.deg2rad;\n            point.shapeType = 'arc3d';\n            shapeArgs.x += depth / 2;\n            shapeArgs.z = z;\n            shapeArgs.start = 0;\n            shapeArgs.end = 2 * PI;\n            shapeArgs.r = depth * 0.95;\n            shapeArgs.innerR = 0;\n            shapeArgs.depth =\n                shapeArgs.height * (1 / sin((90 - alpha) * deg2rad)) - z;\n            shapeArgs.alpha = 90 - alpha;\n            shapeArgs.beta = 0;\n        });\n    });\n    */\n\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    /* *\n     *\n     *  API Options\n     *\n     * */\n\n    /**\n     * Depth of the columns in a 3D column chart.\n     *\n     * @type      {number}\n     * @default   25\n     * @since     4.0\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption plotOptions.column.depth\n     */\n\n    /**\n     * 3D columns only. The color of the edges. Similar to `borderColor`, except it\n     * defaults to the same color as the column.\n     *\n     * @type      {Highcharts.ColorString}\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption plotOptions.column.edgeColor\n     */\n\n    /**\n     * 3D columns only. The width of the colored edges.\n     *\n     * @type      {number}\n     * @default   1\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption plotOptions.column.edgeWidth\n     */\n\n    /**\n     * The spacing between columns on the Z Axis in a 3D chart.\n     *\n     * @type      {number}\n     * @default   1\n     * @since     4.0\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption plotOptions.column.groupZPadding\n     */\n\n    ''; // keeps doclets above in transpiled file\n\n    return ColumnSeries;\n  });\n\n  _registerModule(_modules, 'Series/Pie3D/Pie3DPoint.js', [_modules['Core/Series/SeriesRegistry.js']], function (SeriesRegistry) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  3D pie series\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var PiePoint = SeriesRegistry.seriesTypes.pie.prototype.pointClass;\n    /* *\n     *\n     *  Constants\n     *\n     * */\n\n    var superHaloPath = PiePoint.prototype.haloPath;\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    var Pie3DPoint =\n    /** @class */\n    function (_super) {\n      __extends(Pie3DPoint, _super);\n\n      function Pie3DPoint() {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.series = void 0;\n        return _this;\n        /* eslint-enable valid-jsdoc */\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /* eslint-disable valid-jsdoc */\n\n      /**\n       * @private\n       */\n\n\n      Pie3DPoint.prototype.haloPath = function () {\n        return this.series.chart.is3d() ? [] : superHaloPath.apply(this, arguments);\n      };\n\n      return Pie3DPoint;\n    }(PiePoint);\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n\n    return Pie3DPoint;\n  });\n\n  _registerModule(_modules, 'Series/Pie3D/Pie3DSeries.js', [_modules['Core/Globals.js'], _modules['Series/Pie3D/Pie3DPoint.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (H, Pie3DPoint, SeriesRegistry, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  3D pie series\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var deg2rad = H.deg2rad,\n        svg = H.svg;\n    var PieSeries = SeriesRegistry.seriesTypes.pie;\n    var extend = U.extend,\n        pick = U.pick;\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    var Pie3DSeries =\n    /** @class */\n    function (_super) {\n      __extends(Pie3DSeries, _super);\n\n      function Pie3DSeries() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n      /* eslint-disable valid-jsdoc */\n\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.addPoint = function () {\n        _super.prototype.addPoint.apply(this, arguments);\n\n        if (this.chart.is3d()) {\n          // destroy (and rebuild) everything!!!\n          this.update(this.userOptions, true); // #3845 pass the old options\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.animate = function (init) {\n        if (!this.chart.is3d()) {\n          _super.prototype.animate.apply(this, arguments);\n        } else {\n          var animation = this.options.animation,\n              attribs = void 0,\n              center = this.center,\n              group = this.group,\n              markerGroup = this.markerGroup;\n\n          if (svg) {\n            // VML is too slow anyway\n            if (animation === true) {\n              animation = {};\n            } // Initialize the animation\n\n\n            if (init) {\n              // Scale down the group and place it in the center\n              group.oldtranslateX = pick(group.oldtranslateX, group.translateX);\n              group.oldtranslateY = pick(group.oldtranslateY, group.translateY);\n              attribs = {\n                translateX: center[0],\n                translateY: center[1],\n                scaleX: 0.001,\n                scaleY: 0.001\n              };\n              group.attr(attribs);\n\n              if (markerGroup) {\n                markerGroup.attrSetters = group.attrSetters;\n                markerGroup.attr(attribs);\n              } // Run the animation\n\n            } else {\n              attribs = {\n                translateX: group.oldtranslateX,\n                translateY: group.oldtranslateY,\n                scaleX: 1,\n                scaleY: 1\n              };\n              group.animate(attribs, animation);\n\n              if (markerGroup) {\n                markerGroup.animate(attribs, animation);\n              }\n            }\n          }\n        }\n      };\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.drawDataLabels = function () {\n        if (this.chart.is3d()) {\n          var series = this,\n              chart = series.chart,\n              options3d_1 = chart.options.chart.options3d;\n          series.data.forEach(function (point) {\n            var shapeArgs = point.shapeArgs,\n                r = shapeArgs.r,\n                // #3240 issue with datalabels for 0 and null values\n            a1 = (shapeArgs.alpha || options3d_1.alpha) * deg2rad,\n                b1 = (shapeArgs.beta || options3d_1.beta) * deg2rad,\n                a2 = (shapeArgs.start + shapeArgs.end) / 2,\n                labelPosition = point.labelPosition,\n                connectorPosition = labelPosition.connectorPosition,\n                yOffset = -r * (1 - Math.cos(a1)) * Math.sin(a2),\n                xOffset = r * (Math.cos(b1) - 1) * Math.cos(a2); // Apply perspective on label positions\n\n            [labelPosition.natural, connectorPosition.breakAt, connectorPosition.touchingSliceAt].forEach(function (coordinates) {\n              coordinates.x += xOffset;\n              coordinates.y += yOffset;\n            });\n          });\n        }\n\n        _super.prototype.drawDataLabels.apply(this, arguments);\n      };\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.pointAttribs = function (point) {\n        var attr = _super.prototype.pointAttribs.apply(this, arguments),\n            options = this.options;\n\n        if (this.chart.is3d() && !this.chart.styledMode) {\n          attr.stroke = options.edgeColor || point.color || this.color;\n          attr['stroke-width'] = pick(options.edgeWidth, 1);\n        }\n\n        return attr;\n      };\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.translate = function () {\n        _super.prototype.translate.apply(this, arguments); // Do not do this if the chart is not 3D\n\n\n        if (!this.chart.is3d()) {\n          return;\n        }\n\n        var series = this,\n            seriesOptions = series.options,\n            depth = seriesOptions.depth || 0,\n            options3d = series.chart.options.chart.options3d,\n            alpha = options3d.alpha,\n            beta = options3d.beta,\n            z = seriesOptions.stacking ? (seriesOptions.stack || 0) * depth : series._i * depth;\n        z += depth / 2;\n\n        if (seriesOptions.grouping !== false) {\n          z = 0;\n        }\n\n        series.data.forEach(function (point) {\n          var shapeArgs = point.shapeArgs,\n              angle;\n          point.shapeType = 'arc3d';\n          shapeArgs.z = z;\n          shapeArgs.depth = depth * 0.75;\n          shapeArgs.alpha = alpha;\n          shapeArgs.beta = beta;\n          shapeArgs.center = series.center;\n          angle = (shapeArgs.end + shapeArgs.start) / 2;\n          point.slicedTranslation = {\n            translateX: Math.round(Math.cos(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad)),\n            translateY: Math.round(Math.sin(angle) * seriesOptions.slicedOffset * Math.cos(alpha * deg2rad))\n          };\n        });\n      };\n      /**\n       * @private\n       */\n\n\n      Pie3DSeries.prototype.drawTracker = function () {\n        _super.prototype.drawTracker.apply(this, arguments); // Do not do this if the chart is not 3D\n\n\n        if (!this.chart.is3d()) {\n          return;\n        }\n\n        this.points.forEach(function (point) {\n          if (point.graphic) {\n            ['out', 'inn', 'side1', 'side2'].forEach(function (face) {\n              if (point.graphic) {\n                point.graphic[face].element.point = point;\n              }\n            });\n          }\n        });\n      };\n\n      return Pie3DSeries;\n    }(PieSeries);\n\n    extend(Pie3DSeries.prototype, {\n      pointClass: Pie3DPoint\n    });\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    /* *\n     *\n     *  API Options\n     *\n     * */\n\n    /**\n     * The thickness of a 3D pie.\n     *\n     * @type      {number}\n     * @default   0\n     * @since     4.0\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption plotOptions.pie.depth\n     */\n\n    ''; // keeps doclets above after transpilation\n\n    return Pie3DSeries;\n  });\n\n  _registerModule(_modules, 'Series/Pie3D/Pie3DComposition.js', [_modules['Series/Pie3D/Pie3DPoint.js'], _modules['Series/Pie3D/Pie3DSeries.js'], _modules['Core/Series/SeriesRegistry.js']], function (Pie3DPoint, Pie3DSeries, SeriesRegistry) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  3D pie series\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n\n    /* *\n     *\n     *  Imports\n     *\n     * */\n\n    /* *\n     *\n     *  Composition\n     *\n     * */\n    SeriesRegistry.seriesTypes.pie.prototype.pointClass.prototype.haloPath = Pie3DPoint.prototype.haloPath;\n    SeriesRegistry.seriesTypes.pie = Pie3DSeries;\n  });\n\n  _registerModule(_modules, 'Series/Scatter3D/Scatter3DPoint.js', [_modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Utilities.js']], function (ScatterSeries, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Scatter 3D series.\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var defined = U.defined;\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    var Scatter3DPoint =\n    /** @class */\n    function (_super) {\n      __extends(Scatter3DPoint, _super);\n\n      function Scatter3DPoint() {\n        /* *\n         *\n         *  Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.options = void 0;\n        _this.series = void 0;\n        return _this;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n\n      Scatter3DPoint.prototype.applyOptions = function () {\n        _super.prototype.applyOptions.apply(this, arguments);\n\n        if (!defined(this.z)) {\n          this.z = 0;\n        }\n\n        return this;\n      };\n\n      return Scatter3DPoint;\n    }(ScatterSeries.prototype.pointClass);\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n\n    return Scatter3DPoint;\n  });\n\n  _registerModule(_modules, 'Series/Scatter3D/Scatter3DSeries.js', [_modules['Extensions/Math3D.js'], _modules['Series/Scatter3D/Scatter3DPoint.js'], _modules['Series/Scatter/ScatterSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Math3D, Scatter3DPoint, ScatterSeries, SeriesRegistry, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Torstein Honsi\n     *\n     *  Scatter 3D series.\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var __extends = this && this.__extends || function () {\n      var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        };\n\n        return extendStatics(d, b);\n      };\n\n      return function (d, b) {\n        extendStatics(d, b);\n\n        function __() {\n          this.constructor = d;\n        }\n\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n      };\n    }();\n\n    var pointCameraDistance = Math3D.pointCameraDistance;\n    var extend = U.extend,\n        merge = U.merge;\n    /* *\n     *\n     *  Class\n     *\n     * */\n\n    /**\n     * @private\n     * @class\n     * @name Highcharts.seriesTypes.scatter3d\n     *\n     * @augments Highcharts.Series\n     */\n\n    var Scatter3DSeries =\n    /** @class */\n    function (_super) {\n      __extends(Scatter3DSeries, _super);\n\n      function Scatter3DSeries() {\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /* *\n         *\n         *  Properties\n         *\n         * */\n\n\n        _this.data = void 0;\n        _this.options = void 0;\n        _this.points = void 0;\n        return _this;\n      }\n      /* *\n       *\n       *  Functions\n       *\n       * */\n\n\n      Scatter3DSeries.prototype.pointAttribs = function (point) {\n        var attribs = _super.prototype.pointAttribs.apply(this, arguments);\n\n        if (this.chart.is3d() && point) {\n          attribs.zIndex = pointCameraDistance(point, this.chart);\n        }\n\n        return attribs;\n      };\n      /**\n       * A 3D scatter plot uses x, y and z coordinates to display values for three\n       * variables for a set of data.\n       *\n       * @sample {highcharts} highcharts/3d/scatter/\n       *         Simple 3D scatter\n       * @sample {highcharts} highcharts/demo/3d-scatter-draggable\n       *         Draggable 3d scatter\n       *\n       * @extends      plotOptions.scatter\n       * @excluding    dragDrop, cluster, boostThreshold, boostBlending\n       * @product      highcharts\n       * @requires     highcharts-3d\n       * @optionparent plotOptions.scatter3d\n       */\n\n\n      Scatter3DSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n        tooltip: {\n          pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>z: <b>{point.z}</b><br/>'\n        }\n      });\n      return Scatter3DSeries;\n    }(ScatterSeries);\n\n    extend(Scatter3DSeries.prototype, {\n      axisTypes: ['xAxis', 'yAxis', 'zAxis'],\n      // Require direct touch rather than using the k-d-tree, because the\n      // k-d-tree currently doesn't take the xyz coordinate system into\n      // account (#4552)\n      directTouch: true,\n      parallelArrays: ['x', 'y', 'z'],\n      pointArrayMap: ['x', 'y', 'z'],\n      pointClass: Scatter3DPoint\n    });\n    SeriesRegistry.registerSeriesType('scatter3d', Scatter3DSeries);\n    /* *\n     *\n     *  Default Export\n     *\n     * */\n\n    /* *\n     *\n     *  API Options\n     *\n     * */\n\n    /**\n     * A `scatter3d` series. If the [type](#series.scatter3d.type) option is\n     * not specified, it is inherited from [chart.type](#chart.type).\n     *\n     * scatter3d](#plotOptions.scatter3d).\n     *\n     * @extends   series,plotOptions.scatter3d\n     * @excluding boostThreshold, boostBlending\n     * @product   highcharts\n     * @requires  highcharts-3d\n     * @apioption series.scatter3d\n     */\n\n    /**\n     * An array of data points for the series. For the `scatter3d` series\n     * type, points can be given in the following ways:\n     *\n     * 1.  An array of arrays with 3 values. In this case, the values correspond\n     * to `x,y,z`. If the first value is a string, it is applied as the name\n     * of the point, and the `x` value is inferred.\n     *\n     *  ```js\n     *     data: [\n     *         [0, 0, 1],\n     *         [1, 8, 7],\n     *         [2, 9, 2]\n     *     ]\n     *  ```\n     *\n     * 3.  An array of objects with named values. The following snippet shows only a\n     * few settings, see the complete options set below. If the total number of data\n     * points exceeds the series'\n     * [turboThreshold](#series.scatter3d.turboThreshold), this option is not\n     * available.\n     *\n     *  ```js\n     *     data: [{\n     *         x: 1,\n     *         y: 2,\n     *         z: 24,\n     *         name: \"Point2\",\n     *         color: \"#00FF00\"\n     *     }, {\n     *         x: 1,\n     *         y: 4,\n     *         z: 12,\n     *         name: \"Point1\",\n     *         color: \"#FF00FF\"\n     *     }]\n     *  ```\n     *\n     * @sample {highcharts} highcharts/chart/reflow-true/\n     *         Numerical values\n     * @sample {highcharts} highcharts/series/data-array-of-arrays/\n     *         Arrays of numeric x and y\n     * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n     *         Arrays of datetime x and y\n     * @sample {highcharts} highcharts/series/data-array-of-name-value/\n     *         Arrays of point.name and y\n     * @sample {highcharts} highcharts/series/data-array-of-objects/\n     *         Config objects\n     *\n     * @type      {Array<Array<number>|*>}\n     * @extends   series.scatter.data\n     * @product   highcharts\n     * @apioption series.scatter3d.data\n     */\n\n    /**\n     * The z value for each data point.\n     *\n     * @type      {number}\n     * @product   highcharts\n     * @apioption series.scatter3d.data.z\n     */\n\n    ''; // adds doclets above to transpiled file\n\n    return Scatter3DSeries;\n  });\n\n  _registerModule(_modules, 'Series/Area3DSeries.js', [_modules['Extensions/Math3D.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Math3D, SeriesRegistry, U) {\n    /* *\n     *\n     *  (c) 2010-2021 Grzegorz Blachliski\n     *\n     *  License: www.highcharts.com/license\n     *\n     *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n     *\n     * */\n    var perspective = Math3D.perspective;\n    var _a = SeriesRegistry.seriesTypes,\n        AreaSeriesClass = _a.area,\n        LineSeriesClass = _a.line;\n    var pick = U.pick,\n        wrap = U.wrap;\n    /* eslint-disable no-invalid-this */\n\n    wrap(AreaSeriesClass.prototype, 'getGraphPath', function (proceed) {\n      var series = this,\n          svgPath = proceed.apply(series, [].slice.call(arguments, 1)); // Do not do this if the chart is not 3D\n\n      if (!series.chart.is3d()) {\n        return svgPath;\n      }\n\n      var getGraphPath = LineSeriesClass.prototype.getGraphPath,\n          graphPath = [],\n          options = series.options,\n          stacking = options.stacking,\n          bottomPath,\n          bottomPoints = [],\n          graphPoints = [],\n          i,\n          areaPath,\n          connectNulls = pick( // #10574\n      options.connectNulls, stacking === 'percent'),\n          translatedThreshold = Math.round( // #10909\n      series.yAxis.getThreshold(options.threshold)),\n          options3d;\n\n      if (series.rawPointsX) {\n        for (var i_1 = 0; i_1 < series.points.length; i_1++) {\n          bottomPoints.push({\n            x: series.rawPointsX[i_1],\n            y: options.stacking ? series.points[i_1].yBottom : translatedThreshold,\n            z: series.zPadding\n          });\n        }\n      }\n\n      options3d = series.chart.options.chart.options3d;\n      bottomPoints = perspective(bottomPoints, series.chart, true).map(function (point) {\n        return {\n          plotX: point.x,\n          plotY: point.y,\n          plotZ: point.z\n        };\n      });\n\n      if (series.group && options3d && options3d.depth && options3d.beta) {\n        // Markers should take the global zIndex of series group.\n        if (series.markerGroup) {\n          series.markerGroup.add(series.group);\n          series.markerGroup.attr({\n            translateX: 0,\n            translateY: 0\n          });\n        }\n\n        series.group.attr({\n          zIndex: Math.max(1, options3d.beta > 270 || options3d.beta < 90 ? options3d.depth - Math.round(series.zPadding || 0) : Math.round(series.zPadding || 0))\n        });\n      }\n\n      bottomPoints.reversed = true;\n      bottomPath = getGraphPath.call(series, bottomPoints, true, true);\n\n      if (bottomPath[0] && bottomPath[0][0] === 'M') {\n        bottomPath[0] = ['L', bottomPath[0][1], bottomPath[0][2]];\n      }\n\n      if (series.areaPath) {\n        // Remove previously used bottomPath and add the new one.\n        areaPath = series.areaPath.splice(0, series.areaPath.length / 2).concat(bottomPath); // Use old xMap in the new areaPath\n\n        areaPath.xMap = series.areaPath.xMap;\n        series.areaPath = areaPath;\n        graphPath = getGraphPath.call(series, graphPoints, false, connectNulls);\n      }\n\n      return svgPath;\n    });\n  });\n\n  _registerModule(_modules, 'masters/highcharts-3d.src.js', [_modules['Core/Globals.js'], _modules['Core/Renderer/SVG/SVGRenderer3D.js'], _modules['Core/Chart/Chart3D.js'], _modules['Core/Axis/ZAxis.js'], _modules['Core/Axis/Axis3D.js']], function (Highcharts, SVGRenderer3D, Chart3D, ZAxis, Axis3D) {\n    var G = Highcharts; // Compositions\n\n    SVGRenderer3D.compose(G.SVGRenderer);\n    Chart3D.compose(G.Chart, G.Fx);\n    ZAxis.ZChartComposition.compose(G.Chart);\n    Axis3D.compose(G.Axis);\n  });\n});","map":null,"metadata":{},"sourceType":"script"}