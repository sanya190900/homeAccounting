{"ast":null,"code":"/*\n Highcharts JS v10.0.0 (2022-03-07)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (d) {\n  \"object\" === typeof module && module.exports ? (d[\"default\"] = d, module.exports = d) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts-more\", [\"highcharts\"], function (A) {\n    d(A);\n    d.Highcharts = A;\n    return d;\n  }) : d(\"undefined\" !== typeof Highcharts ? Highcharts : void 0);\n})(function (d) {\n  function A(d, e, l, a) {\n    d.hasOwnProperty(e) || (d[e] = a.apply(null, l), \"function\" === typeof CustomEvent && window.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: e,\n        module: d[e]\n      }\n    })));\n  }\n\n  d = d ? d._modules : {};\n  A(d, \"Extensions/Pane.js\", [d[\"Core/Chart/Chart.js\"], d[\"Series/CenteredUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Pointer.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a, c) {\n    function t(b, m, n) {\n      return Math.sqrt(Math.pow(b - n[0], 2) + Math.pow(m - n[1], 2)) <= n[2] / 2;\n    }\n\n    var p = c.addEvent,\n        k = c.extend,\n        x = c.merge,\n        w = c.pick,\n        b = c.splat;\n    d.prototype.collectionsWithUpdate.push(\"pane\");\n\n    c = function () {\n      function g(b, g) {\n        this.options = this.chart = this.center = this.background = void 0;\n        this.coll = \"pane\";\n        this.defaultOptions = {\n          center: [\"50%\", \"50%\"],\n          size: \"85%\",\n          innerSize: \"0%\",\n          startAngle: 0\n        };\n        this.defaultBackgroundOptions = {\n          shape: \"circle\",\n          borderWidth: 1,\n          borderColor: \"#cccccc\",\n          backgroundColor: {\n            linearGradient: {\n              x1: 0,\n              y1: 0,\n              x2: 0,\n              y2: 1\n            },\n            stops: [[0, \"#ffffff\"], [1, \"#e6e6e6\"]]\n          },\n          from: -Number.MAX_VALUE,\n          innerRadius: 0,\n          to: Number.MAX_VALUE,\n          outerRadius: \"105%\"\n        };\n        this.init(b, g);\n      }\n\n      g.prototype.init = function (b, g) {\n        this.chart = g;\n        this.background = [];\n        g.pane.push(this);\n        this.setOptions(b);\n      };\n\n      g.prototype.setOptions = function (b) {\n        this.options = x(this.defaultOptions, this.chart.angular ? {\n          background: {}\n        } : void 0, b);\n      };\n\n      g.prototype.render = function () {\n        var g = this.options,\n            n = this.options.background,\n            q = this.chart.renderer;\n        this.group || (this.group = q.g(\"pane-group\").attr({\n          zIndex: g.zIndex || 0\n        }).add());\n        this.updateCenter();\n        if (n) for (n = b(n), g = Math.max(n.length, this.background.length || 0), q = 0; q < g; q++) n[q] && this.axis ? this.renderBackground(x(this.defaultBackgroundOptions, n[q]), q) : this.background[q] && (this.background[q] = this.background[q].destroy(), this.background.splice(q, 1));\n      };\n\n      g.prototype.renderBackground = function (b, g) {\n        var n = \"animate\",\n            m = {\n          \"class\": \"highcharts-pane \" + (b.className || \"\")\n        };\n        this.chart.styledMode || k(m, {\n          fill: b.backgroundColor,\n          stroke: b.borderColor,\n          \"stroke-width\": b.borderWidth\n        });\n        this.background[g] || (this.background[g] = this.chart.renderer.path().add(this.group), n = \"attr\");\n        this.background[g][n]({\n          d: this.axis.getPlotBandPath(b.from, b.to, b)\n        }).attr(m);\n      };\n\n      g.prototype.updateCenter = function (b) {\n        this.center = (b || this.axis || {}).center = e.getCenter.call(this);\n      };\n\n      g.prototype.update = function (b, g) {\n        x(!0, this.options, b);\n        this.setOptions(this.options);\n        this.render();\n        this.chart.axes.forEach(function (b) {\n          b.pane === this && (b.pane = null, b.update({}, g));\n        }, this);\n      };\n\n      return g;\n    }();\n\n    d.prototype.getHoverPane = function (b) {\n      var g = this,\n          n;\n      b && g.pane.forEach(function (q) {\n        var m = b.chartX - g.plotLeft,\n            a = b.chartY - g.plotTop;\n        t(g.inverted ? a : m, g.inverted ? m : a, q.center) && (n = q);\n      });\n      return n;\n    };\n\n    p(d, \"afterIsInsidePlot\", function (b) {\n      this.polar && (b.isInsidePlot = this.pane.some(function (g) {\n        return t(b.x, b.y, g.center);\n      }));\n    });\n    p(a, \"beforeGetHoverData\", function (b) {\n      var g = this.chart;\n      g.polar ? (g.hoverPane = g.getHoverPane(b), b.filter = function (n) {\n        return n.visible && !(!b.shared && n.directTouch) && w(n.options.enableMouseTracking, !0) && (!g.hoverPane || n.xAxis.pane === g.hoverPane);\n      }) : g.hoverPane = void 0;\n    });\n    p(a, \"afterGetHoverData\", function (b) {\n      var g = this.chart;\n      b.hoverPoint && b.hoverPoint.plotX && b.hoverPoint.plotY && g.hoverPane && !t(b.hoverPoint.plotX, b.hoverPoint.plotY, g.hoverPane.center) && (b.hoverPoint = void 0);\n    });\n    l.Pane = c;\n    return l.Pane;\n  });\n  A(d, \"Core/Axis/RadialAxis.js\", [d[\"Core/Axis/AxisDefaults.js\"], d[\"Core/DefaultOptions.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = e.defaultOptions,\n        t = l.noop,\n        p = a.addEvent,\n        k = a.correctFloat,\n        x = a.defined,\n        w = a.extend,\n        b = a.fireEvent,\n        g = a.merge,\n        m = a.pick,\n        n = a.relativeLength,\n        q = a.wrap,\n        H;\n\n    (function (a) {\n      function e() {\n        this.autoConnect = this.isCircular && \"undefined\" === typeof m(this.userMax, this.options.max) && k(this.endAngleRad - this.startAngleRad) === k(2 * Math.PI);\n        !this.isCircular && this.chart.inverted && this.max++;\n        this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);\n      }\n\n      function y() {\n        var h = this;\n        return function () {\n          if (h.isRadial && h.tickPositions && h.options.labels && !0 !== h.options.labels.allowOverlap) return h.tickPositions.map(function (f) {\n            return h.ticks[f] && h.ticks[f].label;\n          }).filter(function (h) {\n            return !!h;\n          });\n        };\n      }\n\n      function z() {\n        return t;\n      }\n\n      function f(h, f, b) {\n        var r = this.pane.center,\n            u = h.value;\n\n        if (this.isCircular) {\n          if (x(u)) h.point && (g = h.point.shapeArgs || {}, g.start && (u = this.chart.inverted ? this.translate(h.point.rectPlotY, !0) : h.point.x));else {\n            var g = h.chartX || 0;\n            var v = h.chartY || 0;\n            u = this.translate(Math.atan2(v - b, g - f) - this.startAngleRad, !0);\n          }\n          h = this.getPosition(u);\n          g = h.x;\n          v = h.y;\n        } else x(u) || (g = h.chartX, v = h.chartY), x(g) && x(v) && (b = r[1] + this.chart.plotTop, u = this.translate(Math.min(Math.sqrt(Math.pow(g - f, 2) + Math.pow(v - b, 2)), r[2] / 2) - r[3] / 2, !0));\n\n        return [u, g || 0, v || 0];\n      }\n\n      function h(h, f, b) {\n        h = this.pane.center;\n        var r = this.chart,\n            u = this.left || 0,\n            g = this.top || 0,\n            v = m(f, h[2] / 2 - this.offset);\n        \"undefined\" === typeof b && (b = this.horiz ? 0 : this.center && -this.center[3] / 2);\n        b && (v += b);\n        this.isCircular || \"undefined\" !== typeof f ? (f = this.chart.renderer.symbols.arc(u + h[0], g + h[1], v, v, {\n          start: this.startAngleRad,\n          end: this.endAngleRad,\n          open: !0,\n          innerR: 0\n        }), f.xBounds = [u + h[0]], f.yBounds = [g + h[1] - v]) : (f = this.postTranslate(this.angleRad, v), f = [[\"M\", this.center[0] + r.plotLeft, this.center[1] + r.plotTop], [\"L\", f.x, f.y]]);\n        return f;\n      }\n\n      function u() {\n        this.constructor.prototype.getOffset.call(this);\n        this.chart.axisOffset[this.side] = 0;\n      }\n\n      function r(h, f, b) {\n        var r = this.chart,\n            u = function (h) {\n          if (\"string\" === typeof h) {\n            var f = parseInt(h, 10);\n            y.test(h) && (f = f * B / 100);\n            return f;\n          }\n\n          return h;\n        },\n            g = this.center,\n            v = this.startAngleRad,\n            B = g[2] / 2,\n            n = Math.min(this.offset, 0),\n            q = this.left || 0,\n            a = this.top || 0,\n            y = /%$/,\n            z = this.isCircular,\n            c = m(u(b.outerRadius), B),\n            k = u(b.innerRadius);\n\n        u = m(u(b.thickness), 10);\n        if (\"polygon\" === this.options.gridLineInterpolation) n = this.getPlotLinePath({\n          value: h\n        }).concat(this.getPlotLinePath({\n          value: f,\n          reverse: !0\n        }));else {\n          h = Math.max(h, this.min);\n          f = Math.min(f, this.max);\n          h = this.translate(h);\n          f = this.translate(f);\n          z || (c = h || 0, k = f || 0);\n          if (\"circle\" !== b.shape && z) b = v + (h || 0), v += f || 0;else {\n            b = -Math.PI / 2;\n            v = 1.5 * Math.PI;\n            var E = !0;\n          }\n          c -= n;\n          n = r.renderer.symbols.arc(q + g[0], a + g[1], c, c, {\n            start: Math.min(b, v),\n            end: Math.max(b, v),\n            innerR: m(k, c - (u - n)),\n            open: E\n          });\n          z && (z = (v + b) / 2, q = q + g[0] + g[2] / 2 * Math.cos(z), n.xBounds = z > -Math.PI / 2 && z < Math.PI / 2 ? [q, r.plotWidth] : [0, q], n.yBounds = [a + g[1] + g[2] / 2 * Math.sin(z)], n.yBounds[0] += z > -Math.PI && 0 > z || z > Math.PI ? -10 : 10);\n        }\n        return n;\n      }\n\n      function B(h) {\n        var f = this,\n            b = this.pane.center,\n            r = this.chart,\n            u = r.inverted,\n            g = h.reverse,\n            v = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {},\n            B = v.innerRadius || \"0%\",\n            q = v.outerRadius || \"100%\",\n            a = b[0] + r.plotLeft,\n            z = b[1] + r.plotTop,\n            c = this.height,\n            y = h.isCrosshair;\n        v = b[3] / 2;\n        var m = h.value,\n            k;\n        var E = this.getPosition(m);\n        var e = E.x;\n        E = E.y;\n        y && (E = this.getCrosshairPosition(h, a, z), m = E[0], e = E[1], E = E[2]);\n        if (this.isCircular) m = Math.sqrt(Math.pow(e - a, 2) + Math.pow(E - z, 2)), g = \"string\" === typeof B ? n(B, 1) : B / m, r = \"string\" === typeof q ? n(q, 1) : q / m, b && v && (v /= m, g < v && (g = v), r < v && (r = v)), b = [[\"M\", a + g * (e - a), z - g * (z - E)], [\"L\", e - (1 - r) * (e - a), E + (1 - r) * (z - E)]];else if ((m = this.translate(m)) && (0 > m || m > c) && (m = 0), \"circle\" === this.options.gridLineInterpolation) b = this.getLinePath(0, m, v);else if (b = [], r[u ? \"yAxis\" : \"xAxis\"].forEach(function (h) {\n          h.pane === f.pane && (k = h);\n        }), k) for (a = k.tickPositions, k.autoConnect && (a = a.concat([a[0]])), g && (a = a.slice().reverse()), m && (m += v), z = 0; z < a.length; z++) v = k.getPosition(a[z], m), b.push(z ? [\"L\", v.x, v.y] : [\"M\", v.x, v.y]);\n        return b;\n      }\n\n      function v(h, f) {\n        h = this.translate(h);\n        return this.postTranslate(this.isCircular ? h : this.angleRad, m(this.isCircular ? f : 0 > h ? 0 : h, this.center[2] / 2) - this.offset);\n      }\n\n      function E() {\n        var h = this.center,\n            f = this.chart,\n            b = this.options.title;\n        return {\n          x: f.plotLeft + h[0] + (b.x || 0),\n          y: f.plotTop + h[1] - {\n            high: .5,\n            middle: .25,\n            low: 0\n          }[b.align] * h[2] + (b.y || 0)\n        };\n      }\n\n      function l(b) {\n        b.beforeSetTickPositions = e;\n        b.createLabelCollector = y;\n        b.getCrosshairPosition = f;\n        b.getLinePath = h;\n        b.getOffset = u;\n        b.getPlotBandPath = r;\n        b.getPlotLinePath = B;\n        b.getPosition = v;\n        b.getTitlePosition = E;\n        b.postTranslate = O;\n        b.setAxisSize = A;\n        b.setAxisTranslation = P;\n        b.setOptions = Q;\n      }\n\n      function L() {\n        var h = this.chart,\n            f = this.options,\n            b = this.pane,\n            r = b && b.options;\n        h.angular && this.isXAxis || !b || !h.angular && !h.polar || (this.angleRad = (f.angle || 0) * Math.PI / 180, this.startAngleRad = (r.startAngle - 90) * Math.PI / 180, this.endAngleRad = (m(r.endAngle, r.startAngle + 360) - 90) * Math.PI / 180, this.offset = f.offset || 0);\n      }\n\n      function H(h) {\n        this.isRadial && (h.align = void 0, h.preventDefault());\n      }\n\n      function K() {\n        if (this.chart && this.chart.labelCollectors) {\n          var h = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;\n          0 <= h && this.chart.labelCollectors.splice(h, 1);\n        }\n      }\n\n      function C(h) {\n        var f = this.chart,\n            b = f.inverted,\n            r = f.angular,\n            u = f.polar,\n            v = this.isXAxis,\n            B = this.coll,\n            n = r && v,\n            a = f.options;\n        h = h.userOptions.pane || 0;\n        h = this.pane = f.pane && f.pane[h];\n        var q;\n        if (\"colorAxis\" === B) this.isRadial = !1;else {\n          if (r) {\n            if (n ? (this.isHidden = !0, this.createLabelCollector = z, this.getOffset = t, this.render = this.redraw = G, this.setTitle = this.setCategories = this.setScale = t) : l(this), q = !v) this.defaultPolarOptions = R;\n          } else u && (l(this), this.defaultPolarOptions = (q = this.horiz) ? S : g(\"xAxis\" === B ? d.defaultXAxisOptions : d.defaultYAxisOptions, T), b && \"yAxis\" === B && (this.defaultPolarOptions.stackLabels = d.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = !0));\n\n          r || u ? (this.isRadial = !0, a.chart.zoomType = null, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && f.labelCollectors.push(this.labelCollector)) : this.isRadial = !1;\n          h && q && (h.axis = this);\n          this.isCircular = q;\n        }\n      }\n\n      function U() {\n        this.isRadial && this.beforeSetTickPositions();\n      }\n\n      function J(h) {\n        var f = this.label;\n\n        if (f) {\n          var b = this.axis,\n              r = f.getBBox(),\n              u = b.options.labels,\n              v = (b.translate(this.pos) + b.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360,\n              g = Math.round(v),\n              B = x(u.y) ? 0 : .3 * -r.height,\n              a = u.y,\n              q = 20,\n              z = u.align,\n              c = \"end\",\n              y = 0 > g ? g + 360 : g,\n              E = y,\n              k = 0,\n              e = 0;\n\n          if (b.isRadial) {\n            var l = b.getPosition(this.pos, b.center[2] / 2 + n(m(u.distance, -25), b.center[2] / 2, -b.center[2] / 2));\n            \"auto\" === u.rotation ? f.attr({\n              rotation: v\n            }) : x(a) || (a = b.chart.renderer.fontMetrics(f.styles && f.styles.fontSize).b - r.height / 2);\n            x(z) || (b.isCircular ? (r.width > b.len * b.tickInterval / (b.max - b.min) && (q = 0), z = v > q && v < 180 - q ? \"left\" : v > 180 + q && v < 360 - q ? \"right\" : \"center\") : z = \"center\", f.attr({\n              align: z\n            }));\n\n            if (\"auto\" === z && 2 === b.tickPositions.length && b.isCircular) {\n              90 < y && 180 > y ? y = 180 - y : 270 < y && 360 >= y && (y = 540 - y);\n              180 < E && 360 >= E && (E = 360 - E);\n              if (b.pane.options.startAngle === g || b.pane.options.startAngle === g + 360 || b.pane.options.startAngle === g - 360) c = \"start\";\n              z = -90 <= g && 90 >= g || -360 <= g && -270 >= g || 270 <= g && 360 >= g ? \"start\" === c ? \"right\" : \"left\" : \"start\" === c ? \"left\" : \"right\";\n              70 < E && 110 > E && (z = \"center\");\n              15 > y || 180 <= y && 195 > y ? k = .3 * r.height : 15 <= y && 35 >= y ? k = \"start\" === c ? 0 : .75 * r.height : 195 <= y && 215 >= y ? k = \"start\" === c ? .75 * r.height : 0 : 35 < y && 90 >= y ? k = \"start\" === c ? .25 * -r.height : r.height : 215 < y && 270 >= y && (k = \"start\" === c ? r.height : .25 * -r.height);\n              15 > E ? e = \"start\" === c ? .15 * -r.height : .15 * r.height : 165 < E && 180 >= E && (e = \"start\" === c ? .15 * r.height : .15 * -r.height);\n              f.attr({\n                align: z\n              });\n              f.translate(e, k + B);\n            }\n\n            h.pos.x = l.x + (u.x || 0);\n            h.pos.y = l.y + (a || 0);\n          }\n        }\n      }\n\n      function V(h) {\n        this.axis.getPosition && w(h.pos, this.axis.getPosition(this.pos));\n      }\n\n      function O(h, f) {\n        var b = this.chart,\n            r = this.center;\n        h = this.startAngleRad + h;\n        return {\n          x: b.plotLeft + r[0] + Math.cos(h) * f,\n          y: b.plotTop + r[1] + Math.sin(h) * f\n        };\n      }\n\n      function G() {\n        this.isDirty = !1;\n      }\n\n      function A() {\n        this.constructor.prototype.setAxisSize.call(this);\n\n        if (this.isRadial) {\n          this.pane.updateCenter(this);\n          var h = this.center = this.pane.center.slice();\n          if (this.isCircular) this.sector = this.endAngleRad - this.startAngleRad;else {\n            var f = this.postTranslate(this.angleRad, h[3] / 2);\n            h[0] = f.x - this.chart.plotLeft;\n            h[1] = f.y - this.chart.plotTop;\n          }\n          this.len = this.width = this.height = (h[2] - h[3]) * m(this.sector, 1) / 2;\n        }\n      }\n\n      function P() {\n        this.constructor.prototype.setAxisTranslation.call(this);\n        this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);\n      }\n\n      function Q(h) {\n        h = this.options = g(this.constructor.defaultOptions, this.defaultPolarOptions, c[this.coll], h);\n        h.plotBands || (h.plotBands = []);\n        b(this, \"afterSetOptions\");\n      }\n\n      function W(h, f, b, r, u, g, v) {\n        var B = this.axis;\n        B.isRadial ? (h = B.getPosition(this.pos, B.center[2] / 2 + r), f = [\"M\", f, b, \"L\", h.x, h.y]) : f = h.call(this, f, b, r, u, g, v);\n        return f;\n      }\n\n      var N = [],\n          S = {\n        gridLineWidth: 1,\n        labels: {\n          align: void 0,\n          distance: 15,\n          x: 0,\n          y: void 0,\n          style: {\n            textOverflow: \"none\"\n          }\n        },\n        maxPadding: 0,\n        minPadding: 0,\n        showLastLabel: !1,\n        tickLength: 0\n      },\n          R = {\n        labels: {\n          align: \"center\",\n          x: 0,\n          y: void 0\n        },\n        minorGridLineWidth: 0,\n        minorTickInterval: \"auto\",\n        minorTickLength: 10,\n        minorTickPosition: \"inside\",\n        minorTickWidth: 1,\n        tickLength: 10,\n        tickPosition: \"inside\",\n        tickWidth: 2,\n        title: {\n          rotation: 0\n        },\n        zIndex: 2\n      },\n          T = {\n        gridLineInterpolation: \"circle\",\n        gridLineWidth: 1,\n        labels: {\n          align: \"right\",\n          x: -3,\n          y: -2\n        },\n        showLastLabel: !1,\n        title: {\n          x: 4,\n          text: null,\n          rotation: 90\n        }\n      };\n\n      a.compose = function (h, f) {\n        -1 === N.indexOf(h) && (N.push(h), p(h, \"afterInit\", L), p(h, \"autoLabelAlign\", H), p(h, \"destroy\", K), p(h, \"init\", C), p(h, \"initialAxisTranslation\", U));\n        -1 === N.indexOf(f) && (N.push(f), p(f, \"afterGetLabelPosition\", J), p(f, \"afterGetPosition\", V), q(f.prototype, \"getMarkPath\", W));\n        return h;\n      };\n    })(H || (H = {}));\n\n    return H;\n  });\n  A(d, \"Series/AreaRange/AreaRangePoint.js\", [d[\"Series/Area/AreaSeries.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, k) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, g) {\n          b.__proto__ = g;\n        } || function (b, g) {\n          for (var a in g) g.hasOwnProperty(a) && (b[a] = g[a]);\n        };\n\n        return a(c, k);\n      };\n\n      return function (c, k) {\n        function b() {\n          this.constructor = c;\n        }\n\n        a(c, k);\n        c.prototype = null === k ? Object.create(k) : (b.prototype = k.prototype, new b());\n      };\n    }(),\n        c = e.prototype,\n        t = l.defined,\n        p = l.isNumber;\n\n    return function (k) {\n      function e() {\n        var a = null !== k && k.apply(this, arguments) || this;\n        a.high = void 0;\n        a.low = void 0;\n        a.options = void 0;\n        a.plotHigh = void 0;\n        a.plotLow = void 0;\n        a.plotHighX = void 0;\n        a.plotLowX = void 0;\n        a.plotX = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(e, k);\n\n      e.prototype.setState = function () {\n        var a = this.state,\n            b = this.series,\n            g = b.chart.polar;\n        t(this.plotHigh) || (this.plotHigh = b.yAxis.toPixels(this.high, !0));\n        t(this.plotLow) || (this.plotLow = this.plotY = b.yAxis.toPixels(this.low, !0));\n        b.stateMarkerGraphic && (b.lowerStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.upperStateMarkerGraphic);\n        this.graphic = this.upperGraphic;\n        this.plotY = this.plotHigh;\n        g && (this.plotX = this.plotHighX);\n        c.setState.apply(this, arguments);\n        this.state = a;\n        this.plotY = this.plotLow;\n        this.graphic = this.lowerGraphic;\n        g && (this.plotX = this.plotLowX);\n        b.stateMarkerGraphic && (b.upperStateMarkerGraphic = b.stateMarkerGraphic, b.stateMarkerGraphic = b.lowerStateMarkerGraphic, b.lowerStateMarkerGraphic = void 0);\n        c.setState.apply(this, arguments);\n      };\n\n      e.prototype.haloPath = function () {\n        var a = this.series.chart.polar,\n            b = [];\n        this.plotY = this.plotLow;\n        a && (this.plotX = this.plotLowX);\n        this.isInside && (b = c.haloPath.apply(this, arguments));\n        this.plotY = this.plotHigh;\n        a && (this.plotX = this.plotHighX);\n        this.isTopInside && (b = b.concat(c.haloPath.apply(this, arguments)));\n        return b;\n      };\n\n      e.prototype.isValid = function () {\n        return p(this.low) && p(this.high);\n      };\n\n      return e;\n    }(d.prototype.pointClass);\n  });\n  A(d, \"Series/AreaRange/AreaRangeSeries.js\", [d[\"Series/AreaRange/AreaRangePoint.js\"], d[\"Series/Area/AreaSeries.js\"], d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/Series.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a, c, t, p) {\n    var k = this && this.__extends || function () {\n      var b = function (g, a) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, f) {\n          b.__proto__ = f;\n        } || function (b, f) {\n          for (var h in f) f.hasOwnProperty(h) && (b[h] = f[h]);\n        };\n\n        return b(g, a);\n      };\n\n      return function (g, a) {\n        function n() {\n          this.constructor = g;\n        }\n\n        b(g, a);\n        g.prototype = null === a ? Object.create(a) : (n.prototype = a.prototype, new n());\n      };\n    }(),\n        x = e.prototype,\n        w = l.prototype;\n\n    l = a.noop;\n    var b = c.prototype,\n        g = p.defined,\n        m = p.extend,\n        n = p.isArray,\n        q = p.pick,\n        H = p.merge;\n\n    c = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.lowerStateMarkerGraphic = void 0;\n        b.xAxis = void 0;\n        return b;\n      }\n\n      k(c, a);\n\n      c.prototype.toYData = function (b) {\n        return [b.low, b.high];\n      };\n\n      c.prototype.highToXY = function (b) {\n        var g = this.chart,\n            f = this.xAxis.postTranslate(b.rectPlotX || 0, this.yAxis.len - b.plotHigh);\n        b.plotHighX = f.x - g.plotLeft;\n        b.plotHigh = f.y - g.plotTop;\n        b.plotLowX = b.plotX;\n      };\n\n      c.prototype.translate = function () {\n        var b = this,\n            g = b.yAxis;\n        x.translate.apply(b);\n        b.points.forEach(function (f) {\n          var h = f.high,\n              u = f.plotY;\n          f.isNull ? f.plotY = null : (f.plotLow = u, f.plotHigh = g.translate(b.dataModify ? b.dataModify.modifyValue(h) : h, 0, 1, 0, 1), b.dataModify && (f.yBottom = f.plotHigh));\n        });\n        this.chart.polar && this.points.forEach(function (f) {\n          b.highToXY(f);\n          f.tooltipPos = [(f.plotHighX + f.plotLowX) / 2, (f.plotHigh + f.plotLow) / 2];\n        });\n      };\n\n      c.prototype.getGraphPath = function (b) {\n        var g = [],\n            f = [],\n            h,\n            u = x.getGraphPath;\n        var r = this.options;\n        var a = this.chart.polar,\n            v = a && !1 !== r.connectEnds,\n            n = r.connectNulls,\n            c = r.step;\n        b = b || this.points;\n\n        for (h = b.length; h--;) {\n          var m = b[h];\n          var k = a ? {\n            plotX: m.rectPlotX,\n            plotY: m.yBottom,\n            doCurve: !1\n          } : {\n            plotX: m.plotX,\n            plotY: m.plotY,\n            doCurve: !1\n          };\n          m.isNull || v || n || b[h + 1] && !b[h + 1].isNull || f.push(k);\n          var e = {\n            polarPlotY: m.polarPlotY,\n            rectPlotX: m.rectPlotX,\n            yBottom: m.yBottom,\n            plotX: q(m.plotHighX, m.plotX),\n            plotY: m.plotHigh,\n            isNull: m.isNull\n          };\n          f.push(e);\n          g.push(e);\n          m.isNull || v || n || b[h - 1] && !b[h - 1].isNull || f.push(k);\n        }\n\n        b = u.call(this, b);\n        c && (!0 === c && (c = \"left\"), r.step = {\n          left: \"right\",\n          center: \"center\",\n          right: \"left\"\n        }[c]);\n        g = u.call(this, g);\n        f = u.call(this, f);\n        r.step = c;\n        r = [].concat(b, g);\n        !this.chart.polar && f[0] && \"M\" === f[0][0] && (f[0] = [\"L\", f[0][1], f[0][2]]);\n        this.graphPath = r;\n        this.areaPath = b.concat(f);\n        r.isArea = !0;\n        r.xMap = b.xMap;\n        this.areaPath.xMap = b.xMap;\n        return r;\n      };\n\n      c.prototype.drawDataLabels = function () {\n        var g = this.points,\n            a = g.length,\n            f,\n            h = [],\n            u = this.options.dataLabels,\n            r,\n            B = this.chart.inverted;\n\n        if (u) {\n          if (n(u)) {\n            var v = u[0] || {\n              enabled: !1\n            };\n            var c = u[1] || {\n              enabled: !1\n            };\n          } else v = m({}, u), v.x = u.xHigh, v.y = u.yHigh, c = m({}, u), c.x = u.xLow, c.y = u.yLow;\n\n          if (v.enabled || this._hasPointLabels) {\n            for (f = a; f--;) if (r = g[f]) {\n              var q = v.inside ? r.plotHigh < r.plotLow : r.plotHigh > r.plotLow;\n              r.y = r.high;\n              r._plotY = r.plotY;\n              r.plotY = r.plotHigh;\n              h[f] = r.dataLabel;\n              r.dataLabel = r.dataLabelUpper;\n              r.below = q;\n              B ? v.align || (v.align = q ? \"right\" : \"left\") : v.verticalAlign || (v.verticalAlign = q ? \"top\" : \"bottom\");\n            }\n\n            this.options.dataLabels = v;\n            b.drawDataLabels && b.drawDataLabels.apply(this, arguments);\n\n            for (f = a; f--;) if (r = g[f]) r.dataLabelUpper = r.dataLabel, r.dataLabel = h[f], delete r.dataLabels, r.y = r.low, r.plotY = r._plotY;\n          }\n\n          if (c.enabled || this._hasPointLabels) {\n            for (f = a; f--;) if (r = g[f]) q = c.inside ? r.plotHigh < r.plotLow : r.plotHigh > r.plotLow, r.below = !q, B ? c.align || (c.align = q ? \"left\" : \"right\") : c.verticalAlign || (c.verticalAlign = q ? \"bottom\" : \"top\");\n\n            this.options.dataLabels = c;\n            b.drawDataLabels && b.drawDataLabels.apply(this, arguments);\n          }\n\n          if (v.enabled) for (f = a; f--;) if (r = g[f]) r.dataLabels = [r.dataLabelUpper, r.dataLabel].filter(function (h) {\n            return !!h;\n          });\n          this.options.dataLabels = u;\n        }\n      };\n\n      c.prototype.alignDataLabel = function () {\n        w.alignDataLabel.apply(this, arguments);\n      };\n\n      c.prototype.drawPoints = function () {\n        var a = this.points.length,\n            c;\n        b.drawPoints.apply(this, arguments);\n\n        for (c = 0; c < a;) {\n          var f = this.points[c];\n          f.origProps = {\n            plotY: f.plotY,\n            plotX: f.plotX,\n            isInside: f.isInside,\n            negative: f.negative,\n            zone: f.zone,\n            y: f.y\n          };\n          f.lowerGraphic = f.graphic;\n          f.graphic = f.upperGraphic;\n          f.plotY = f.plotHigh;\n          g(f.plotHighX) && (f.plotX = f.plotHighX);\n          f.y = q(f.high, f.origProps.y);\n          f.negative = f.y < (this.options.threshold || 0);\n          this.zones.length && (f.zone = f.getZone());\n          this.chart.polar || (f.isInside = f.isTopInside = \"undefined\" !== typeof f.plotY && 0 <= f.plotY && f.plotY <= this.yAxis.len && 0 <= f.plotX && f.plotX <= this.xAxis.len);\n          c++;\n        }\n\n        b.drawPoints.apply(this, arguments);\n\n        for (c = 0; c < a;) f = this.points[c], f.upperGraphic = f.graphic, f.graphic = f.lowerGraphic, f.origProps && (m(f, f.origProps), delete f.origProps), c++;\n      };\n\n      c.defaultOptions = H(e.defaultOptions, {\n        lineWidth: 1,\n        threshold: null,\n        tooltip: {\n          pointFormat: '<span style=\"color:{series.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        trackByArea: !0,\n        dataLabels: {\n          align: void 0,\n          verticalAlign: void 0,\n          xLow: 0,\n          xHigh: 0,\n          yLow: 0,\n          yHigh: 0\n        }\n      });\n      return c;\n    }(e);\n\n    m(c.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"low\",\n      deferTranslatePolar: !0,\n      pointClass: d,\n      setStackedPoints: l\n    });\n    t.registerSeriesType(\"arearange\", c);\n    \"\";\n    return c;\n  });\n  A(d, \"Series/AreaSplineRange/AreaSplineRangeSeries.js\", [d[\"Series/AreaRange/AreaRangeSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, k) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, g) {\n          b.__proto__ = g;\n        } || function (b, g) {\n          for (var a in g) g.hasOwnProperty(a) && (b[a] = g[a]);\n        };\n\n        return a(c, k);\n      };\n\n      return function (c, k) {\n        function b() {\n          this.constructor = c;\n        }\n\n        a(c, k);\n        c.prototype = null === k ? Object.create(k) : (b.prototype = k.prototype, new b());\n      };\n    }(),\n        c = e.seriesTypes.spline,\n        t = l.merge;\n\n    l = l.extend;\n\n    var p = function (c) {\n      function k() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.data = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      a(k, c);\n      k.defaultOptions = t(d.defaultOptions);\n      return k;\n    }(d);\n\n    l(p.prototype, {\n      getPointSpline: c.prototype.getPointSpline\n    });\n    e.registerSeriesType(\"areasplinerange\", p);\n    \"\";\n    return p;\n  });\n  A(d, \"Series/BoxPlot/BoxPlotSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function g() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());\n      };\n    }();\n\n    e = e.noop;\n    var t = a.extend,\n        p = a.merge,\n        k = a.pick;\n\n    a = function (a) {\n      function e() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      c(e, a);\n\n      e.prototype.pointAttribs = function () {\n        return {};\n      };\n\n      e.prototype.translate = function () {\n        var b = this.yAxis,\n            g = this.pointArrayMap;\n        a.prototype.translate.apply(this);\n        this.points.forEach(function (a) {\n          g.forEach(function (g) {\n            null !== a[g] && (a[g + \"Plot\"] = b.translate(a[g], 0, 1, 0, 1));\n          });\n          a.plotHigh = a.highPlot;\n        });\n      };\n\n      e.prototype.drawPoints = function () {\n        var b = this,\n            g = b.options,\n            a = b.chart,\n            c = a.renderer,\n            q,\n            e,\n            l,\n            d,\n            y,\n            z,\n            f = 0,\n            h,\n            u,\n            r,\n            B,\n            v = !1 !== b.doQuartiles,\n            E,\n            p = b.options.whiskerLength;\n        b.points.forEach(function (n) {\n          var m = n.graphic,\n              H = m ? \"animate\" : \"attr\",\n              t = n.shapeArgs,\n              x = {},\n              I = {},\n              w = {},\n              L = {},\n              M = n.color || b.color;\n          \"undefined\" !== typeof n.plotY && (h = Math.round(t.width), u = Math.floor(t.x), r = u + h, B = Math.round(h / 2), q = Math.floor(v ? n.q1Plot : n.lowPlot), e = Math.floor(v ? n.q3Plot : n.lowPlot), l = Math.floor(n.highPlot), d = Math.floor(n.lowPlot), m || (n.graphic = m = c.g(\"point\").add(b.group), n.stem = c.path().addClass(\"highcharts-boxplot-stem\").add(m), p && (n.whiskers = c.path().addClass(\"highcharts-boxplot-whisker\").add(m)), v && (n.box = c.path(void 0).addClass(\"highcharts-boxplot-box\").add(m)), n.medianShape = c.path(void 0).addClass(\"highcharts-boxplot-median\").add(m)), a.styledMode || (I.stroke = n.stemColor || g.stemColor || M, I[\"stroke-width\"] = k(n.stemWidth, g.stemWidth, g.lineWidth), I.dashstyle = n.stemDashStyle || g.stemDashStyle || g.dashStyle, n.stem.attr(I), p && (w.stroke = n.whiskerColor || g.whiskerColor || M, w[\"stroke-width\"] = k(n.whiskerWidth, g.whiskerWidth, g.lineWidth), w.dashstyle = n.whiskerDashStyle || g.whiskerDashStyle || g.dashStyle, n.whiskers.attr(w)), v && (x.fill = n.fillColor || g.fillColor || M, x.stroke = g.lineColor || M, x[\"stroke-width\"] = g.lineWidth || 0, x.dashstyle = n.boxDashStyle || g.boxDashStyle || g.dashStyle, n.box.attr(x)), L.stroke = n.medianColor || g.medianColor || M, L[\"stroke-width\"] = k(n.medianWidth, g.medianWidth, g.lineWidth), L.dashstyle = n.medianDashStyle || g.medianDashStyle || g.dashStyle, n.medianShape.attr(L)), z = n.stem.strokeWidth() % 2 / 2, f = u + B + z, m = [[\"M\", f, e], [\"L\", f, l], [\"M\", f, q], [\"L\", f, d]], n.stem[H]({\n            d: m\n          }), v && (z = n.box.strokeWidth() % 2 / 2, q = Math.floor(q) + z, e = Math.floor(e) + z, u += z, r += z, m = [[\"M\", u, e], [\"L\", u, q], [\"L\", r, q], [\"L\", r, e], [\"L\", u, e], [\"Z\"]], n.box[H]({\n            d: m\n          })), p && (z = n.whiskers.strokeWidth() % 2 / 2, l += z, d += z, E = /%$/.test(p) ? B * parseFloat(p) / 100 : p / 2, m = [[\"M\", f - E, l], [\"L\", f + E, l], [\"M\", f - E, d], [\"L\", f + E, d]], n.whiskers[H]({\n            d: m\n          })), y = Math.round(n.medianPlot), z = n.medianShape.strokeWidth() % 2 / 2, y += z, m = [[\"M\", u, y], [\"L\", r, y]], n.medianShape[H]({\n            d: m\n          }));\n        });\n      };\n\n      e.prototype.toYData = function (b) {\n        return [b.low, b.q1, b.median, b.q3, b.high];\n      };\n\n      e.defaultOptions = p(d.defaultOptions, {\n        threshold: null,\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'\n        },\n        whiskerLength: \"50%\",\n        fillColor: \"#ffffff\",\n        lineWidth: 1,\n        medianWidth: 2,\n        whiskerWidth: 2\n      });\n      return e;\n    }(d);\n\n    t(a.prototype, {\n      pointArrayMap: [\"low\", \"q1\", \"median\", \"q3\", \"high\"],\n      pointValKey: \"high\",\n      drawDataLabels: e,\n      setStackedPoints: e\n    });\n    l.registerSeriesType(\"boxplot\", a);\n    \"\";\n    return a;\n  });\n  A(d, \"Series/Bubble/BubbleLegendDefaults.js\", [], function () {\n    return {\n      borderColor: void 0,\n      borderWidth: 2,\n      className: void 0,\n      color: void 0,\n      connectorClassName: void 0,\n      connectorColor: void 0,\n      connectorDistance: 60,\n      connectorWidth: 1,\n      enabled: !1,\n      labels: {\n        className: void 0,\n        allowOverlap: !1,\n        format: \"\",\n        formatter: void 0,\n        align: \"right\",\n        style: {\n          fontSize: \"10px\",\n          color: \"#000000\"\n        },\n        x: 0,\n        y: 0\n      },\n      maxSize: 60,\n      minSize: 10,\n      legendIndex: 0,\n      ranges: {\n        value: void 0,\n        borderColor: void 0,\n        color: void 0,\n        connectorColor: void 0\n      },\n      sizeBy: \"area\",\n      sizeByAbsoluteValue: !1,\n      zIndex: 1,\n      zThreshold: 0\n    };\n  });\n  A(d, \"Series/Bubble/BubbleLegendItem.js\", [d[\"Core/Color/Color.js\"], d[\"Core/FormatUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = d.parse,\n        t = l.noop,\n        p = a.arrayMax,\n        k = a.arrayMin,\n        x = a.isNumber,\n        w = a.merge,\n        b = a.pick,\n        g = a.stableSort;\n    \"\";\n    return function () {\n      function a(b, a) {\n        this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legendSymbol = this.legendItemWidth = this.legendItemHeight = this.legendItem = this.legendGroup = this.legend = this.fontMetrics = this.chart = void 0;\n        this.setState = t;\n        this.init(b, a);\n      }\n\n      a.prototype.init = function (b, a) {\n        this.options = b;\n        this.visible = !0;\n        this.chart = a.chart;\n        this.legend = a;\n      };\n\n      a.prototype.addToLegend = function (b) {\n        b.splice(this.options.legendIndex, 0, this);\n      };\n\n      a.prototype.drawLegendSymbol = function (a) {\n        var c = this.chart,\n            n = this.options,\n            e = b(a.options.itemDistance, 20),\n            k = n.ranges,\n            m = n.connectorDistance;\n        this.fontMetrics = c.renderer.fontMetrics(n.labels.style.fontSize);\n        k && k.length && x(k[0].value) ? (g(k, function (b, f) {\n          return f.value - b.value;\n        }), this.ranges = k, this.setOptions(), this.render(), a = this.getMaxLabelSize(), k = this.ranges[0].radius, c = 2 * k, m = m - k + a.width, m = 0 < m ? m : 0, this.maxLabel = a, this.movementX = \"left\" === n.labels.align ? m : 0, this.legendItemWidth = c + m + e, this.legendItemHeight = c + this.fontMetrics.h / 2) : a.options.bubbleLegend.autoRanges = !0;\n      };\n\n      a.prototype.setOptions = function () {\n        var a = this.ranges,\n            g = this.options,\n            k = this.chart.series[g.seriesIndex],\n            e = this.legend.baseline,\n            m = {\n          zIndex: g.zIndex,\n          \"stroke-width\": g.borderWidth\n        },\n            l = {\n          zIndex: g.zIndex,\n          \"stroke-width\": g.connectorWidth\n        },\n            z = {\n          align: this.legend.options.rtl || \"left\" === g.labels.align ? \"right\" : \"left\",\n          zIndex: g.zIndex\n        },\n            f = k.options.marker.fillOpacity,\n            h = this.chart.styledMode;\n        a.forEach(function (u, r) {\n          h || (m.stroke = b(u.borderColor, g.borderColor, k.color), m.fill = b(u.color, g.color, 1 !== f ? c(k.color).setOpacity(f).get(\"rgba\") : k.color), l.stroke = b(u.connectorColor, g.connectorColor, k.color));\n          a[r].radius = this.getRangeRadius(u.value);\n          a[r] = w(a[r], {\n            center: a[0].radius - a[r].radius + e\n          });\n          h || w(!0, a[r], {\n            bubbleAttribs: w(m),\n            connectorAttribs: w(l),\n            labelAttribs: z\n          });\n        }, this);\n      };\n\n      a.prototype.getRangeRadius = function (b) {\n        var a = this.options;\n        return this.chart.series[this.options.seriesIndex].getRadius.call(this, a.ranges[a.ranges.length - 1].value, a.ranges[0].value, a.minSize, a.maxSize, b);\n      };\n\n      a.prototype.render = function () {\n        var b = this.chart.renderer,\n            a = this.options.zThreshold;\n        this.symbols || (this.symbols = {\n          connectors: [],\n          bubbleItems: [],\n          labels: []\n        });\n        this.legendSymbol = b.g(\"bubble-legend\");\n        this.legendItem = b.g(\"bubble-legend-item\");\n        this.legendSymbol.translateX = 0;\n        this.legendSymbol.translateY = 0;\n        this.ranges.forEach(function (b) {\n          b.value >= a && this.renderRange(b);\n        }, this);\n        this.legendSymbol.add(this.legendItem);\n        this.legendItem.add(this.legendGroup);\n        this.hideOverlappingLabels();\n      };\n\n      a.prototype.renderRange = function (b) {\n        var a = this.options,\n            g = a.labels,\n            c = this.chart,\n            n = c.series[a.seriesIndex],\n            k = c.renderer,\n            e = this.symbols;\n        c = e.labels;\n        var f = b.center,\n            h = Math.abs(b.radius),\n            u = a.connectorDistance || 0,\n            r = g.align,\n            B = a.connectorWidth,\n            v = this.ranges[0].radius || 0,\n            m = f - h - a.borderWidth / 2 + B / 2,\n            l = this.fontMetrics;\n        l = l.f / 2 - (l.h - l.f) / 2;\n        var d = k.styledMode;\n        u = this.legend.options.rtl || \"left\" === r ? -u : u;\n        \"center\" === r && (u = 0, a.connectorDistance = 0, b.labelAttribs.align = \"center\");\n        r = m + a.labels.y;\n        var p = v + u + a.labels.x;\n        e.bubbleItems.push(k.circle(v, f + ((m % 1 ? 1 : .5) - (B % 2 ? 0 : .5)), h).attr(d ? {} : b.bubbleAttribs).addClass((d ? \"highcharts-color-\" + n.colorIndex + \" \" : \"\") + \"highcharts-bubble-legend-symbol \" + (a.className || \"\")).add(this.legendSymbol));\n        e.connectors.push(k.path(k.crispLine([[\"M\", v, m], [\"L\", v + u, m]], a.connectorWidth)).attr(d ? {} : b.connectorAttribs).addClass((d ? \"highcharts-color-\" + this.options.seriesIndex + \" \" : \"\") + \"highcharts-bubble-legend-connectors \" + (a.connectorClassName || \"\")).add(this.legendSymbol));\n        b = k.text(this.formatLabel(b), p, r + l).attr(d ? {} : b.labelAttribs).css(d ? {} : g.style).addClass(\"highcharts-bubble-legend-labels \" + (a.labels.className || \"\")).add(this.legendSymbol);\n        c.push(b);\n        b.placed = !0;\n        b.alignAttr = {\n          x: p,\n          y: r + l\n        };\n      };\n\n      a.prototype.getMaxLabelSize = function () {\n        var b, a;\n        this.symbols.labels.forEach(function (g) {\n          a = g.getBBox(!0);\n          b = b ? a.width > b.width ? a : b : a;\n        });\n        return b || {};\n      };\n\n      a.prototype.formatLabel = function (b) {\n        var a = this.options,\n            g = a.labels.formatter;\n        a = a.labels.format;\n        var c = this.chart.numberFormatter;\n        return a ? e.format(a, b) : g ? g.call(b) : c(b.value, 1);\n      };\n\n      a.prototype.hideOverlappingLabels = function () {\n        var b = this.chart,\n            a = this.symbols;\n        !this.options.labels.allowOverlap && a && (b.hideOverlappingLabels(a.labels), a.labels.forEach(function (b, g) {\n          b.newOpacity ? b.newOpacity !== b.oldOpacity && a.connectors[g].show() : a.connectors[g].hide();\n        }));\n      };\n\n      a.prototype.getRanges = function () {\n        var a = this.legend.bubbleLegend,\n            g = a.options.ranges,\n            c,\n            e = Number.MAX_VALUE,\n            m = -Number.MAX_VALUE;\n        a.chart.series.forEach(function (a) {\n          a.isBubble && !a.ignoreSeries && (c = a.zData.filter(x), c.length && (e = b(a.options.zMin, Math.min(e, Math.max(k(c), !1 === a.options.displayNegative ? a.options.zThreshold : -Number.MAX_VALUE))), m = b(a.options.zMax, Math.max(m, p(c)))));\n        });\n        var l = e === m ? [{\n          value: m\n        }] : [{\n          value: e\n        }, {\n          value: (e + m) / 2\n        }, {\n          value: m,\n          autoRanges: !0\n        }];\n        g.length && g[0].radius && l.reverse();\n        l.forEach(function (b, f) {\n          g && g[f] && (l[f] = w(g[f], b));\n        });\n        return l;\n      };\n\n      a.prototype.predictBubbleSizes = function () {\n        var b = this.chart,\n            a = this.fontMetrics,\n            g = b.legend.options,\n            c = g.floating,\n            k = (g = \"horizontal\" === g.layout) ? b.legend.lastLineHeight : 0,\n            e = b.plotSizeX,\n            m = b.plotSizeY,\n            f = b.series[this.options.seriesIndex],\n            h = f.getPxExtremes();\n        b = Math.ceil(h.minPxSize);\n        h = Math.ceil(h.maxPxSize);\n        var u = Math.min(m, e);\n        f = f.options.maxSize;\n        if (c || !/%$/.test(f)) a = h;else if (f = parseFloat(f), a = (u + k - a.h / 2) * f / 100 / (f / 100 + 1), g && m - a >= e || !g && e - a >= m) a = h;\n        return [b, Math.ceil(a)];\n      };\n\n      a.prototype.updateRanges = function (b, a) {\n        var g = this.legend.options.bubbleLegend;\n        g.minSize = b;\n        g.maxSize = a;\n        g.ranges = this.getRanges();\n      };\n\n      a.prototype.correctSizes = function () {\n        var b = this.legend,\n            a = this.chart.series[this.options.seriesIndex].getPxExtremes();\n        1 < Math.abs(Math.ceil(a.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, a.maxPxSize), b.render());\n      };\n\n      return a;\n    }();\n  });\n  A(d, \"Series/Bubble/BubbleLegendComposition.js\", [d[\"Series/Bubble/BubbleLegendDefaults.js\"], d[\"Series/Bubble/BubbleLegendItem.js\"], d[\"Core/DefaultOptions.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = l.setOptions,\n        t = a.addEvent,\n        p = a.objectEach,\n        k = a.wrap,\n        x;\n\n    (function (a) {\n      function b(b, a, c) {\n        var f = this.legend,\n            h = 0 <= g(this);\n\n        if (f && f.options.enabled && f.bubbleLegend && f.options.bubbleLegend.autoRanges && h) {\n          var u = f.bubbleLegend.options;\n          h = f.bubbleLegend.predictBubbleSizes();\n          f.bubbleLegend.updateRanges(h[0], h[1]);\n          u.placed || (f.group.placed = !1, f.allItems.forEach(function (h) {\n            h.legendGroup.translateY = null;\n          }));\n          f.render();\n          this.getMargins();\n          this.axes.forEach(function (h) {\n            h.visible && h.render();\n            u.placed || (h.setScale(), h.updateNames(), p(h.ticks, function (h) {\n              h.isNew = !0;\n              h.isNewLabel = !0;\n            }));\n          });\n          u.placed = !0;\n          this.getMargins();\n          b.call(this, a, c);\n          f.bubbleLegend.correctSizes();\n          x(f, m(f));\n        } else b.call(this, a, c), f && f.options.enabled && f.bubbleLegend && (f.render(), x(f, m(f)));\n      }\n\n      function g(b) {\n        b = b.series;\n\n        for (var a = 0; a < b.length;) {\n          if (b[a] && b[a].isBubble && b[a].visible && b[a].zData.length) return a;\n          a++;\n        }\n\n        return -1;\n      }\n\n      function m(b) {\n        b = b.allItems;\n        var a = [],\n            g = b.length,\n            f,\n            h = 0;\n\n        for (f = 0; f < g; f++) if (b[f].legendItemHeight && (b[f].itemHeight = b[f].legendItemHeight), b[f] === b[g - 1] || b[f + 1] && b[f]._legendItemPos[1] !== b[f + 1]._legendItemPos[1]) {\n          a.push({\n            height: 0\n          });\n          var u = a[a.length - 1];\n\n          for (h; h <= f; h++) b[h].itemHeight > u.height && (u.height = b[h].itemHeight);\n\n          u.step = f;\n        }\n\n        return a;\n      }\n\n      function n(b) {\n        var a = this.bubbleLegend,\n            c = this.options,\n            f = c.bubbleLegend,\n            h = g(this.chart);\n        a && a.ranges && a.ranges.length && (f.ranges.length && (f.autoRanges = !!f.ranges[0].autoRanges), this.destroyItem(a));\n        0 <= h && c.enabled && f.enabled && (f.seriesIndex = h, this.bubbleLegend = new e(f, this), this.bubbleLegend.addToLegend(b.allItems));\n      }\n\n      function l() {\n        var b = this.chart,\n            a = this.visible,\n            c = this.chart.legend;\n        c && c.bubbleLegend && (this.visible = !a, this.ignoreSeries = a, b = 0 <= g(b), c.bubbleLegend.visible !== b && (c.update({\n          bubbleLegend: {\n            enabled: b\n          }\n        }), c.bubbleLegend.visible = b), this.visible = a);\n      }\n\n      function x(b, a) {\n        var g = b.options.rtl,\n            f,\n            h,\n            u,\n            r = 0;\n        b.allItems.forEach(function (b, c) {\n          f = b.legendGroup.translateX;\n          h = b._legendItemPos[1];\n          if ((u = b.movementX) || g && b.ranges) u = g ? f - b.options.maxSize / 2 : f + u, b.legendGroup.attr({\n            translateX: u\n          });\n          c > a[r].step && r++;\n          b.legendGroup.attr({\n            translateY: Math.round(h + a[r].height / 2)\n          });\n          b._legendItemPos[1] = h + a[r].height / 2;\n        });\n      }\n\n      var w = [];\n\n      a.compose = function (a, g, e) {\n        -1 === w.indexOf(a) && (w.push(a), c({\n          legend: {\n            bubbleLegend: d\n          }\n        }), k(a.prototype, \"drawChartBox\", b));\n        -1 === w.indexOf(g) && (w.push(g), t(g, \"afterGetAllItems\", n));\n        -1 === w.indexOf(e) && (w.push(e), t(e, \"legendItemClick\", l));\n      };\n    })(x || (x = {}));\n\n    return x;\n  });\n  A(d, \"Series/Bubble/BubblePoint.js\", [d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);\n        };\n\n        return a(c, e);\n      };\n\n      return function (c, e) {\n        function k() {\n          this.constructor = c;\n        }\n\n        a(c, e);\n        c.prototype = null === e ? Object.create(e) : (k.prototype = e.prototype, new k());\n      };\n    }();\n\n    l = l.extend;\n\n    e = function (c) {\n      function e() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(e, c);\n\n      e.prototype.haloPath = function (a) {\n        return d.prototype.haloPath.call(this, 0 === a ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a);\n      };\n\n      return e;\n    }(e.seriesTypes.scatter.prototype.pointClass);\n\n    l(e.prototype, {\n      ttBelow: !1\n    });\n    return e;\n  });\n  A(d, \"Series/Bubble/BubbleSeries.js\", [d[\"Core/Axis/Axis.js\"], d[\"Series/Bubble/BubbleLegendComposition.js\"], d[\"Series/Bubble/BubblePoint.js\"], d[\"Core/Color/Color.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/Series.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a, c, t, p, k) {\n    var x = this && this.__extends || function () {\n      var b = function (f, h) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, h) {\n          b.__proto__ = h;\n        } || function (b, h) {\n          for (var f in h) h.hasOwnProperty(f) && (b[f] = h[f]);\n        };\n\n        return b(f, h);\n      };\n\n      return function (f, h) {\n        function a() {\n          this.constructor = f;\n        }\n\n        b(f, h);\n        f.prototype = null === h ? Object.create(h) : (a.prototype = h.prototype, new a());\n      };\n    }(),\n        w = a.parse;\n\n    a = c.noop;\n    var b = p.seriesTypes;\n    c = b.column;\n    var g = b.scatter;\n    b = k.addEvent;\n    var m = k.arrayMax,\n        n = k.arrayMin,\n        q = k.clamp,\n        H = k.extend,\n        K = k.isNumber,\n        I = k.merge,\n        y = k.pick;\n\n    k = function (b) {\n      function f() {\n        var h = null !== b && b.apply(this, arguments) || this;\n        h.data = void 0;\n        h.maxPxSize = void 0;\n        h.minPxSize = void 0;\n        h.options = void 0;\n        h.points = void 0;\n        h.radii = void 0;\n        h.yData = void 0;\n        h.zData = void 0;\n        return h;\n      }\n\n      x(f, b);\n\n      f.prototype.animate = function (b) {\n        !b && this.points.length < this.options.animationLimit && this.points.forEach(function (b) {\n          var h = b.graphic;\n          h && h.width && (this.hasRendered || h.attr({\n            x: b.plotX,\n            y: b.plotY,\n            width: 1,\n            height: 1\n          }), h.animate(this.markerAttribs(b), this.options.animation));\n        }, this);\n      };\n\n      f.prototype.getRadii = function () {\n        var b = this,\n            f = this.zData,\n            a = this.yData,\n            g = [],\n            c = this.chart.bubbleZExtremes;\n        var e = this.getPxExtremes();\n        var m = e.minPxSize,\n            k = e.maxPxSize;\n\n        if (!c) {\n          var n = Number.MAX_VALUE,\n              l = -Number.MAX_VALUE,\n              d;\n          this.chart.series.forEach(function (h) {\n            h.bubblePadding && (h.visible || !b.chart.options.chart.ignoreHiddenSeries) && (h = h.getZExtremes()) && (n = Math.min(n || h.zMin, h.zMin), l = Math.max(l || h.zMax, h.zMax), d = !0);\n          });\n          d ? (c = {\n            zMin: n,\n            zMax: l\n          }, this.chart.bubbleZExtremes = c) : c = {\n            zMin: 0,\n            zMax: 0\n          };\n        }\n\n        var p = 0;\n\n        for (e = f.length; p < e; p++) {\n          var q = f[p];\n          g.push(this.getRadius(c.zMin, c.zMax, m, k, q, a[p]));\n        }\n\n        this.radii = g;\n      };\n\n      f.prototype.getRadius = function (b, f, a, g, c, e) {\n        var h = this.options,\n            r = \"width\" !== h.sizeBy,\n            u = h.zThreshold,\n            v = f - b,\n            m = .5;\n        if (null === e || null === c) return null;\n\n        if (K(c)) {\n          h.sizeByAbsoluteValue && (c = Math.abs(c - u), v = Math.max(f - u, Math.abs(b - u)), b = 0);\n          if (c < b) return a / 2 - 1;\n          0 < v && (m = (c - b) / v);\n        }\n\n        r && 0 <= m && (m = Math.sqrt(m));\n        return Math.ceil(a + m * (g - a)) / 2;\n      };\n\n      f.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      f.prototype.pointAttribs = function (b, f) {\n        var h = this.options.marker.fillOpacity;\n        b = t.prototype.pointAttribs.call(this, b, f);\n        1 !== h && (b.fill = w(b.fill).setOpacity(h).get(\"rgba\"));\n        return b;\n      };\n\n      f.prototype.translate = function () {\n        b.prototype.translate.call(this);\n        this.getRadii();\n        this.translateBubble();\n      };\n\n      f.prototype.translateBubble = function () {\n        for (var b = this.data, f = this.radii, a = this.getPxExtremes().minPxSize, g = b.length; g--;) {\n          var c = b[g],\n              e = f ? f[g] : 0;\n          K(e) && e >= a / 2 ? (c.marker = H(c.marker, {\n            radius: e,\n            width: 2 * e,\n            height: 2 * e\n          }), c.dlBox = {\n            x: c.plotX - e,\n            y: c.plotY - e,\n            width: 2 * e,\n            height: 2 * e\n          }) : c.shapeArgs = c.plotY = c.dlBox = void 0;\n        }\n      };\n\n      f.prototype.getPxExtremes = function () {\n        var b = Math.min(this.chart.plotWidth, this.chart.plotHeight),\n            f = function (h) {\n          if (\"string\" === typeof h) {\n            var f = /%$/.test(h);\n            h = parseInt(h, 10);\n          }\n\n          return f ? b * h / 100 : h;\n        },\n            a = f(y(this.options.minSize, 8));\n\n        f = Math.max(f(y(this.options.maxSize, \"20%\")), a);\n        return {\n          minPxSize: a,\n          maxPxSize: f\n        };\n      };\n\n      f.prototype.getZExtremes = function () {\n        var b = this.options,\n            f = (this.zData || []).filter(K);\n\n        if (f.length) {\n          var a = y(b.zMin, q(n(f), !1 === b.displayNegative ? b.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));\n          b = y(b.zMax, m(f));\n          if (K(a) && K(b)) return {\n            zMin: a,\n            zMax: b\n          };\n        }\n      };\n\n      f.compose = e.compose;\n      f.defaultOptions = I(g.defaultOptions, {\n        dataLabels: {\n          formatter: function () {\n            var b = this.series.chart.numberFormatter,\n                f = this.point.z;\n            return K(f) ? b(f, -1) : \"\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        animationLimit: 250,\n        marker: {\n          lineColor: null,\n          lineWidth: 1,\n          fillOpacity: .5,\n          radius: null,\n          states: {\n            hover: {\n              radiusPlus: 0\n            }\n          },\n          symbol: \"circle\"\n        },\n        minSize: 8,\n        maxSize: \"20%\",\n        softThreshold: !1,\n        states: {\n          hover: {\n            halo: {\n              size: 5\n            }\n          }\n        },\n        tooltip: {\n          pointFormat: \"({point.x}, {point.y}), Size: {point.z}\"\n        },\n        turboThreshold: 0,\n        zThreshold: 0,\n        zoneAxis: \"z\"\n      });\n      return f;\n    }(g);\n\n    H(k.prototype, {\n      alignDataLabel: c.prototype.alignDataLabel,\n      applyZones: a,\n      bubblePadding: !0,\n      buildKDTree: a,\n      directTouch: !0,\n      isBubble: !0,\n      pointArrayMap: [\"y\", \"z\"],\n      pointClass: l,\n      parallelArrays: [\"x\", \"y\", \"z\"],\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      specialGroup: \"group\",\n      zoneAxis: \"z\"\n    });\n    b(k, \"updatedData\", function (b) {\n      delete b.target.chart.bubbleZExtremes;\n    });\n\n    d.prototype.beforePadding = function () {\n      var b = this,\n          f = this.len,\n          h = this.chart,\n          a = 0,\n          g = f,\n          c = this.isXAxis,\n          v = c ? \"xData\" : \"yData\",\n          e = this.min,\n          m = this.max - e,\n          k = f / m,\n          n;\n      this.series.forEach(function (f) {\n        if (f.bubblePadding && (f.visible || !h.options.chart.ignoreHiddenSeries)) {\n          n = b.allowZoomOutside = !0;\n          var r = f[v];\n          c && f.getRadii(0, 0, f);\n          if (0 < m) for (var u = r.length; u--;) if (K(r[u]) && b.dataMin <= r[u] && r[u] <= b.max) {\n            var B = f.radii && f.radii[u] || 0;\n            a = Math.min((r[u] - e) * k - B, a);\n            g = Math.max((r[u] - e) * k + B, g);\n          }\n        }\n      });\n      n && 0 < m && !this.logarithmic && (g -= f, k *= (f + Math.max(0, a) - Math.min(g, f)) / f, [[\"min\", \"userMin\", a], [\"max\", \"userMax\", g]].forEach(function (h) {\n        \"undefined\" === typeof y(b.options[h[0]], b[h[1]]) && (b[h[0]] += h[2] / k);\n      }));\n    };\n\n    p.registerSeriesType(\"bubble\", k);\n    \"\";\n    \"\";\n    return k;\n  });\n  A(d, \"Series/ColumnRange/ColumnRangePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e) {\n    var l = this && this.__extends || function () {\n      var a = function (c, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var g in b) b.hasOwnProperty(g) && (a[g] = b[g]);\n        };\n\n        return a(c, e);\n      };\n\n      return function (c, e) {\n        function k() {\n          this.constructor = c;\n        }\n\n        a(c, e);\n        c.prototype = null === e ? Object.create(e) : (k.prototype = e.prototype, new k());\n      };\n    }(),\n        a = d.seriesTypes;\n\n    d = a.column.prototype.pointClass;\n    var c = e.extend,\n        t = e.isNumber;\n\n    e = function (a) {\n      function c() {\n        var c = null !== a && a.apply(this, arguments) || this;\n        c.series = void 0;\n        c.options = void 0;\n        c.barX = void 0;\n        c.pointWidth = void 0;\n        c.shapeType = void 0;\n        return c;\n      }\n\n      l(c, a);\n\n      c.prototype.isValid = function () {\n        return t(this.low);\n      };\n\n      return c;\n    }(a.arearange.prototype.pointClass);\n\n    c(e.prototype, {\n      setState: d.prototype.setState\n    });\n    return e;\n  });\n  A(d, \"Series/ColumnRange/ColumnRangeSeries.js\", [d[\"Series/ColumnRange/ColumnRangePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = this && this.__extends || function () {\n      var b = function (a, g) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);\n        };\n\n        return b(a, g);\n      };\n\n      return function (a, g) {\n        function c() {\n          this.constructor = a;\n        }\n\n        b(a, g);\n        a.prototype = null === g ? Object.create(g) : (c.prototype = g.prototype, new c());\n      };\n    }();\n\n    e = e.noop;\n    var t = l.seriesTypes,\n        p = t.arearange,\n        k = t.column,\n        x = k.prototype,\n        w = p.prototype,\n        b = a.clamp,\n        g = a.merge,\n        m = a.pick;\n    a = a.extend;\n    var n = {\n      pointRange: null,\n      marker: null,\n      states: {\n        hover: {\n          halo: !1\n        }\n      }\n    };\n\n    t = function (a) {\n      function e() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.points = void 0;\n        b.options = void 0;\n        return b;\n      }\n\n      c(e, a);\n\n      e.prototype.setOptions = function () {\n        g(!0, arguments[0], {\n          stacking: void 0\n        });\n        return w.setOptions.apply(this, arguments);\n      };\n\n      e.prototype.translate = function () {\n        var a = this,\n            g = a.yAxis,\n            c = a.xAxis,\n            e = c.startAngleRad,\n            f,\n            h = a.chart,\n            u = a.xAxis.isRadial,\n            r = Math.max(h.chartWidth, h.chartHeight) + 999,\n            k;\n        x.translate.apply(a);\n        a.points.forEach(function (v) {\n          var n = v.shapeArgs || {},\n              B = a.options.minPointLength;\n          v.plotHigh = k = b(g.translate(v.high, 0, 1, 0, 1), -r, r);\n          v.plotLow = b(v.plotY, -r, r);\n          var l = k;\n          var d = m(v.rectPlotY, v.plotY) - k;\n          Math.abs(d) < B ? (B -= d, d += B, l -= B / 2) : 0 > d && (d *= -1, l -= d);\n          u ? (f = v.barX + e, v.shapeType = \"arc\", v.shapeArgs = a.polarArc(l + d, l, f, f + v.pointWidth)) : (n.height = d, n.y = l, B = n.x, B = void 0 === B ? 0 : B, n = n.width, n = void 0 === n ? 0 : n, v.tooltipPos = h.inverted ? [g.len + g.pos - h.plotLeft - l - d / 2, c.len + c.pos - h.plotTop - B - n / 2, d] : [c.left - h.plotLeft + B + n / 2, g.pos - h.plotTop + l + d / 2, d]);\n        });\n      };\n\n      e.prototype.crispCol = function () {\n        return x.crispCol.apply(this, arguments);\n      };\n\n      e.prototype.drawPoints = function () {\n        return x.drawPoints.apply(this, arguments);\n      };\n\n      e.prototype.drawTracker = function () {\n        return x.drawTracker.apply(this, arguments);\n      };\n\n      e.prototype.getColumnMetrics = function () {\n        return x.getColumnMetrics.apply(this, arguments);\n      };\n\n      e.prototype.pointAttribs = function () {\n        return x.pointAttribs.apply(this, arguments);\n      };\n\n      e.prototype.adjustForMissingColumns = function () {\n        return x.adjustForMissingColumns.apply(this, arguments);\n      };\n\n      e.prototype.animate = function () {\n        return x.animate.apply(this, arguments);\n      };\n\n      e.prototype.translate3dPoints = function () {\n        return x.translate3dPoints.apply(this, arguments);\n      };\n\n      e.prototype.translate3dShapes = function () {\n        return x.translate3dShapes.apply(this, arguments);\n      };\n\n      e.defaultOptions = g(k.defaultOptions, p.defaultOptions, n);\n      return e;\n    }(p);\n\n    a(t.prototype, {\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      drawGraph: e,\n      getSymbol: e,\n      polarArc: function () {\n        return x.polarArc.apply(this, arguments);\n      },\n      pointClass: d\n    });\n    l.registerSeriesType(\"columnrange\", t);\n    \"\";\n    return t;\n  });\n  A(d, \"Series/ColumnPyramid/ColumnPyramidSeries.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function g() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());\n      };\n    }(),\n        c = d.prototype,\n        t = l.clamp,\n        p = l.merge,\n        k = l.pick;\n\n    l = function (e) {\n      function l() {\n        var b = null !== e && e.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      a(l, e);\n\n      l.prototype.translate = function () {\n        var b = this,\n            a = b.chart,\n            e = b.options,\n            n = b.dense = 2 > b.closestPointRange * b.xAxis.transA;\n        n = b.borderWidth = k(e.borderWidth, n ? 0 : 1);\n        var d = b.yAxis,\n            l = e.threshold,\n            p = b.translatedThreshold = d.getThreshold(l),\n            x = k(e.minPointLength, 5),\n            w = b.getColumnMetrics(),\n            z = w.width,\n            f = b.barW = Math.max(z, 1 + 2 * n),\n            h = b.pointXOffset = w.offset;\n        a.inverted && (p -= .5);\n        e.pointPadding && (f = Math.ceil(f));\n        c.translate.apply(b);\n        b.points.forEach(function (g) {\n          var c = k(g.yBottom, p),\n              u = 999 + Math.abs(c),\n              v = t(g.plotY, -u, d.len + u);\n          u = g.plotX + h;\n          var m = f / 2,\n              n = Math.min(v, c);\n          c = Math.max(v, c) - n;\n          var q;\n          g.barX = u;\n          g.pointWidth = z;\n          g.tooltipPos = a.inverted ? [d.len + d.pos - a.plotLeft - v, b.xAxis.len - u - m, c] : [u + m, v + d.pos - a.plotTop, c];\n          v = l + (g.total || g.y);\n          \"percent\" === e.stacking && (v = l + (0 > g.y) ? -100 : 100);\n          v = d.toPixels(v, !0);\n          var w = (q = a.plotHeight - v - (a.plotHeight - p)) ? m * (n - v) / q : 0;\n          var y = q ? m * (n + c - v) / q : 0;\n          q = u - w + m;\n          w = u + w + m;\n          var C = u + y + m;\n          y = u - y + m;\n          var H = n - x;\n          var D = n + c;\n          0 > g.y && (H = n, D = n + c + x);\n          a.inverted && (C = d.width - n, q = v - (d.width - p), w = m * (v - C) / q, y = m * (v - (C - c)) / q, q = u + m + w, w = q - 2 * w, C = u - y + m, y = u + y + m, H = n, D = n + c - x, 0 > g.y && (D = n + c + x));\n          g.shapeType = \"path\";\n          g.shapeArgs = {\n            x: q,\n            y: H,\n            width: w - q,\n            height: c,\n            d: [[\"M\", q, H], [\"L\", w, H], [\"L\", C, D], [\"L\", y, D], [\"Z\"]]\n          };\n        });\n      };\n\n      l.defaultOptions = p(d.defaultOptions, {});\n      return l;\n    }(d);\n\n    e.registerSeriesType(\"columnpyramid\", l);\n    \"\";\n    return l;\n  });\n  A(d, \"Series/ErrorBar/ErrorBarSeries.js\", [d[\"Series/BoxPlot/BoxPlotSeries.js\"], d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = this && this.__extends || function () {\n      var a = function (c, b) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);\n        };\n\n        return a(c, b);\n      };\n\n      return function (c, b) {\n        function g() {\n          this.constructor = c;\n        }\n\n        a(c, b);\n        c.prototype = null === b ? Object.create(b) : (g.prototype = b.prototype, new g());\n      };\n    }(),\n        t = l.seriesTypes.arearange,\n        p = a.merge;\n\n    a = a.extend;\n\n    var k = function (a) {\n      function k() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      c(k, a);\n\n      k.prototype.getColumnMetrics = function () {\n        return this.linkedParent && this.linkedParent.columnMetrics || e.prototype.getColumnMetrics.call(this);\n      };\n\n      k.prototype.drawDataLabels = function () {\n        var b = this.pointValKey;\n        t && (t.prototype.drawDataLabels.call(this), this.data.forEach(function (a) {\n          a.y = a[b];\n        }));\n      };\n\n      k.prototype.toYData = function (b) {\n        return [b.low, b.high];\n      };\n\n      k.defaultOptions = p(d.defaultOptions, {\n        color: \"#000000\",\n        grouping: !1,\n        linkedTo: \":previous\",\n        tooltip: {\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n        },\n        whiskerWidth: null\n      });\n      return k;\n    }(d);\n\n    a(k.prototype, {\n      pointArrayMap: [\"low\", \"high\"],\n      pointValKey: \"high\",\n      doQuartiles: !1\n    });\n    l.registerSeriesType(\"errorbar\", k);\n    \"\";\n    return k;\n  });\n  A(d, \"Series/Gauge/GaugePoint.js\", [d[\"Core/Series/SeriesRegistry.js\"]], function (d) {\n    var e = this && this.__extends || function () {\n      var e = function (a, c) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);\n        };\n\n        return e(a, c);\n      };\n\n      return function (a, c) {\n        function d() {\n          this.constructor = a;\n        }\n\n        e(a, c);\n        a.prototype = null === c ? Object.create(c) : (d.prototype = c.prototype, new d());\n      };\n    }();\n\n    return function (d) {\n      function a() {\n        var a = null !== d && d.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        a.shapeArgs = void 0;\n        return a;\n      }\n\n      e(a, d);\n\n      a.prototype.setState = function (a) {\n        this.state = a;\n      };\n\n      return a;\n    }(d.series.prototype.pointClass);\n  });\n  A(d, \"Series/Gauge/GaugeSeries.js\", [d[\"Series/Gauge/GaugePoint.js\"], d[\"Core/Globals.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = this && this.__extends || function () {\n      var b = function (a, g) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, a) {\n          b.__proto__ = a;\n        } || function (b, a) {\n          for (var g in a) a.hasOwnProperty(g) && (b[g] = a[g]);\n        };\n\n        return b(a, g);\n      };\n\n      return function (a, g) {\n        function c() {\n          this.constructor = a;\n        }\n\n        b(a, g);\n        a.prototype = null === g ? Object.create(g) : (c.prototype = g.prototype, new c());\n      };\n    }();\n\n    e = e.noop;\n    var t = l.series,\n        p = l.seriesTypes.column,\n        k = a.clamp,\n        x = a.isNumber,\n        w = a.extend,\n        b = a.merge,\n        g = a.pick,\n        m = a.pInt;\n\n    a = function (a) {\n      function e() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.points = void 0;\n        b.options = void 0;\n        b.yAxis = void 0;\n        return b;\n      }\n\n      c(e, a);\n\n      e.prototype.translate = function () {\n        var a = this.yAxis,\n            c = this.options,\n            e = a.center;\n        this.generatePoints();\n        this.points.forEach(function (d) {\n          var n = b(c.dial, d.dial),\n              f = m(g(n.radius, \"80%\")) * e[2] / 200,\n              h = m(g(n.baseLength, \"70%\")) * f / 100,\n              u = m(g(n.rearLength, \"10%\")) * f / 100,\n              r = n.baseWidth || 3,\n              l = n.topWidth || 1,\n              v = c.overshoot,\n              p = a.startAngleRad + a.translate(d.y, null, null, null, !0);\n          if (x(v) || !1 === c.wrap) v = x(v) ? v / 180 * Math.PI : 0, p = k(p, a.startAngleRad - v, a.endAngleRad + v);\n          p = 180 * p / Math.PI;\n          d.shapeType = \"path\";\n          d.shapeArgs = {\n            d: n.path || [[\"M\", -u, -r / 2], [\"L\", h, -r / 2], [\"L\", f, -l / 2], [\"L\", f, l / 2], [\"L\", h, r / 2], [\"L\", -u, r / 2], [\"Z\"]],\n            translateX: e[0],\n            translateY: e[1],\n            rotation: p\n          };\n          d.plotX = e[0];\n          d.plotY = e[1];\n        });\n      };\n\n      e.prototype.drawPoints = function () {\n        var a = this,\n            c = a.chart,\n            e = a.yAxis.center,\n            d = a.pivot,\n            m = a.options,\n            f = m.pivot,\n            h = c.renderer;\n        a.points.forEach(function (f) {\n          var g = f.graphic,\n              e = f.shapeArgs,\n              u = e.d,\n              d = b(m.dial, f.dial);\n          g ? (g.animate(e), e.d = u) : f.graphic = h[f.shapeType](e).attr({\n            rotation: e.rotation,\n            zIndex: 1\n          }).addClass(\"highcharts-dial\").add(a.group);\n          if (!c.styledMode) f.graphic[g ? \"animate\" : \"attr\"]({\n            stroke: d.borderColor || \"none\",\n            \"stroke-width\": d.borderWidth || 0,\n            fill: d.backgroundColor || \"#000000\"\n          });\n        });\n        d ? d.animate({\n          translateX: e[0],\n          translateY: e[1]\n        }) : (a.pivot = h.circle(0, 0, g(f.radius, 5)).attr({\n          zIndex: 2\n        }).addClass(\"highcharts-pivot\").translate(e[0], e[1]).add(a.group), c.styledMode || a.pivot.attr({\n          \"stroke-width\": f.borderWidth || 0,\n          stroke: f.borderColor || \"#cccccc\",\n          fill: f.backgroundColor || \"#000000\"\n        }));\n      };\n\n      e.prototype.animate = function (b) {\n        var a = this;\n        b || a.points.forEach(function (b) {\n          var g = b.graphic;\n          g && (g.attr({\n            rotation: 180 * a.yAxis.startAngleRad / Math.PI\n          }), g.animate({\n            rotation: b.shapeArgs.rotation\n          }, a.options.animation));\n        });\n      };\n\n      e.prototype.render = function () {\n        this.group = this.plotGroup(\"group\", \"series\", this.visible ? \"visible\" : \"hidden\", this.options.zIndex, this.chart.seriesGroup);\n        t.prototype.render.call(this);\n        this.group.clip(this.chart.clipRect);\n      };\n\n      e.prototype.setData = function (b, a) {\n        t.prototype.setData.call(this, b, !1);\n        this.processData();\n        this.generatePoints();\n        g(a, !0) && this.chart.redraw();\n      };\n\n      e.prototype.hasData = function () {\n        return !!this.points.length;\n      };\n\n      e.defaultOptions = b(t.defaultOptions, {\n        dataLabels: {\n          borderColor: \"#cccccc\",\n          borderRadius: 3,\n          borderWidth: 1,\n          crop: !1,\n          defer: !1,\n          enabled: !0,\n          verticalAlign: \"top\",\n          y: 15,\n          zIndex: 2\n        },\n        dial: {},\n        pivot: {},\n        tooltip: {\n          headerFormat: \"\"\n        },\n        showInLegend: !1\n      });\n      return e;\n    }(t);\n\n    w(a.prototype, {\n      angular: !0,\n      directTouch: !0,\n      drawGraph: e,\n      drawTracker: p.prototype.drawTracker,\n      fixedBox: !0,\n      forceDL: !0,\n      noSharedTooltip: !0,\n      pointClass: d,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    l.registerSeriesType(\"gauge\", a);\n    \"\";\n    return a;\n  });\n  A(d, \"Series/PackedBubble/PackedBubblePoint.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Series/SeriesRegistry.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var e in c) c.hasOwnProperty(e) && (a[e] = c[e]);\n        };\n\n        return a(c, e);\n      };\n\n      return function (c, e) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, e);\n        c.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());\n      };\n    }();\n\n    return function (c) {\n      function l() {\n        var a = null !== c && c.apply(this, arguments) || this;\n        a.degree = NaN;\n        a.mass = NaN;\n        a.radius = NaN;\n        a.options = void 0;\n        a.series = void 0;\n        a.value = null;\n        return a;\n      }\n\n      a(l, c);\n\n      l.prototype.destroy = function () {\n        this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n        return e.prototype.destroy.apply(this, arguments);\n      };\n\n      l.prototype.firePointEvent = function () {\n        var a = this.series.options;\n\n        if (this.isParentNode && a.parentNode) {\n          var c = a.allowPointSelect;\n          a.allowPointSelect = a.parentNode.allowPointSelect;\n          e.prototype.firePointEvent.apply(this, arguments);\n          a.allowPointSelect = c;\n        } else e.prototype.firePointEvent.apply(this, arguments);\n      };\n\n      l.prototype.select = function () {\n        var a = this.series.chart;\n        this.isParentNode ? (a.getSelectedPoints = a.getSelectedParentNodes, e.prototype.select.apply(this, arguments), a.getSelectedPoints = d.prototype.getSelectedPoints) : e.prototype.select.apply(this, arguments);\n      };\n\n      return l;\n    }(l.seriesTypes.bubble.prototype.pointClass);\n  });\n  A(d, \"Series/Networkgraph/DraggableNodes.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = l.addEvent;\n    e.dragNodesMixin = {\n      onMouseDown: function (a, e) {\n        e = this.chart.pointer.normalize(e);\n        a.fixedPosition = {\n          chartX: e.chartX,\n          chartY: e.chartY,\n          plotX: a.plotX,\n          plotY: a.plotY\n        };\n        a.inDragMode = !0;\n      },\n      onMouseMove: function (a, e) {\n        if (a.fixedPosition && a.inDragMode) {\n          var c = this.chart,\n              d = c.pointer.normalize(e);\n          e = a.fixedPosition.chartX - d.chartX;\n          d = a.fixedPosition.chartY - d.chartY;\n          var l = void 0,\n              w = void 0,\n              b = c.graphLayoutsLookup;\n          if (5 < Math.abs(e) || 5 < Math.abs(d)) l = a.fixedPosition.plotX - e, w = a.fixedPosition.plotY - d, c.isInsidePlot(l, w) && (a.plotX = l, a.plotY = w, a.hasDragged = !0, this.redrawHalo(a), b.forEach(function (b) {\n            b.restartSimulation();\n          }));\n        }\n      },\n      onMouseUp: function (a, e) {\n        a.fixedPosition && (a.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a.inDragMode = a.hasDragged = !1, this.options.fixedDraggable || delete a.fixedPosition);\n      },\n      redrawHalo: function (a) {\n        a && this.halo && this.halo.attr({\n          d: a.haloPath(this.options.states.hover.halo.size)\n        });\n      }\n    };\n    a(d, \"load\", function () {\n      var c = this,\n          e,\n          d,\n          l;\n      c.container && (e = a(c.container, \"mousedown\", function (e) {\n        var k = c.hoverPoint;\n        k && k.series && k.series.hasDraggableNodes && k.series.options.draggable && (k.series.onMouseDown(k, e), d = a(c.container, \"mousemove\", function (b) {\n          return k && k.series && k.series.onMouseMove(k, b);\n        }), l = a(c.container.ownerDocument, \"mouseup\", function (b) {\n          d();\n          l();\n          return k && k.series && k.series.onMouseUp(k, b);\n        }));\n      }));\n      a(c, \"destroy\", function () {\n        e();\n      });\n    });\n  });\n  A(d, \"Series/Networkgraph/Integrations.js\", [d[\"Core/Globals.js\"]], function (d) {\n    d.networkgraphIntegrations = {\n      verlet: {\n        attractiveForceFunction: function (e, d) {\n          return (d - e) / e;\n        },\n        repulsiveForceFunction: function (e, d) {\n          return (d - e) / e * (d > e ? 1 : 0);\n        },\n        barycenter: function () {\n          var e = this.options.gravitationalConstant,\n              d = this.barycenter.xFactor,\n              a = this.barycenter.yFactor;\n          d = (d - (this.box.left + this.box.width) / 2) * e;\n          a = (a - (this.box.top + this.box.height) / 2) * e;\n          this.nodes.forEach(function (c) {\n            c.fixedPosition || (c.plotX -= d / c.mass / c.degree, c.plotY -= a / c.mass / c.degree);\n          });\n        },\n        repulsive: function (e, d, a) {\n          d = d * this.diffTemperature / e.mass / e.degree;\n          e.fixedPosition || (e.plotX += a.x * d, e.plotY += a.y * d);\n        },\n        attractive: function (e, d, a) {\n          var c = e.getMass(),\n              l = -a.x * d * this.diffTemperature;\n          d = -a.y * d * this.diffTemperature;\n          e.fromNode.fixedPosition || (e.fromNode.plotX -= l * c.fromNode / e.fromNode.degree, e.fromNode.plotY -= d * c.fromNode / e.fromNode.degree);\n          e.toNode.fixedPosition || (e.toNode.plotX += l * c.toNode / e.toNode.degree, e.toNode.plotY += d * c.toNode / e.toNode.degree);\n        },\n        integrate: function (e, d) {\n          var a = -e.options.friction,\n              c = e.options.maxSpeed,\n              l = (d.plotX + d.dispX - d.prevX) * a;\n          a *= d.plotY + d.dispY - d.prevY;\n          var p = Math.abs,\n              k = p(l) / (l || 1);\n          p = p(a) / (a || 1);\n          l = k * Math.min(c, Math.abs(l));\n          a = p * Math.min(c, Math.abs(a));\n          d.prevX = d.plotX + d.dispX;\n          d.prevY = d.plotY + d.dispY;\n          d.plotX += l;\n          d.plotY += a;\n          d.temperature = e.vectorLength({\n            x: l,\n            y: a\n          });\n        },\n        getK: function (e) {\n          return Math.pow(e.box.width * e.box.height / e.nodes.length, .5);\n        }\n      },\n      euler: {\n        attractiveForceFunction: function (e, d) {\n          return e * e / d;\n        },\n        repulsiveForceFunction: function (e, d) {\n          return d * d / e;\n        },\n        barycenter: function () {\n          var e = this.options.gravitationalConstant,\n              d = this.barycenter.xFactor,\n              a = this.barycenter.yFactor;\n          this.nodes.forEach(function (c) {\n            if (!c.fixedPosition) {\n              var l = c.getDegree();\n              l *= 1 + l / 2;\n              c.dispX += (d - c.plotX) * e * l / c.degree;\n              c.dispY += (a - c.plotY) * e * l / c.degree;\n            }\n          });\n        },\n        repulsive: function (e, d, a, c) {\n          e.dispX += a.x / c * d / e.degree;\n          e.dispY += a.y / c * d / e.degree;\n        },\n        attractive: function (e, d, a, c) {\n          var l = e.getMass(),\n              p = a.x / c * d;\n          d *= a.y / c;\n          e.fromNode.fixedPosition || (e.fromNode.dispX -= p * l.fromNode / e.fromNode.degree, e.fromNode.dispY -= d * l.fromNode / e.fromNode.degree);\n          e.toNode.fixedPosition || (e.toNode.dispX += p * l.toNode / e.toNode.degree, e.toNode.dispY += d * l.toNode / e.toNode.degree);\n        },\n        integrate: function (e, d) {\n          d.dispX += d.dispX * e.options.friction;\n          d.dispY += d.dispY * e.options.friction;\n          var a = d.temperature = e.vectorLength({\n            x: d.dispX,\n            y: d.dispY\n          });\n          0 !== a && (d.plotX += d.dispX / a * Math.min(Math.abs(d.dispX), e.temperature), d.plotY += d.dispY / a * Math.min(Math.abs(d.dispY), e.temperature));\n        },\n        getK: function (e) {\n          return Math.pow(e.box.width * e.box.height / e.nodes.length, .3);\n        }\n      }\n    };\n  });\n  A(d, \"Series/Networkgraph/QuadTree.js\", [d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e) {\n    e = e.extend;\n\n    var l = d.QuadTreeNode = function (a) {\n      this.box = a;\n      this.boxSize = Math.min(a.width, a.height);\n      this.nodes = [];\n      this.body = this.isInternal = !1;\n      this.isEmpty = !0;\n    };\n\n    e(l.prototype, {\n      insert: function (a, c) {\n        this.isInternal ? this.nodes[this.getBoxPosition(a)].insert(a, c - 1) : (this.isEmpty = !1, this.body ? c ? (this.isInternal = !0, this.divideBox(), !0 !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, c - 1), this.body = !0), this.nodes[this.getBoxPosition(a)].insert(a, c - 1)) : (c = new l({\n          top: a.plotX,\n          left: a.plotY,\n          width: .1,\n          height: .1\n        }), c.body = a, c.isInternal = !1, this.nodes.push(c)) : (this.isInternal = !1, this.body = a));\n      },\n      updateMassAndCenter: function () {\n        var a = 0,\n            c = 0,\n            e = 0;\n        this.isInternal ? (this.nodes.forEach(function (d) {\n          d.isEmpty || (a += d.mass, c += d.plotX * d.mass, e += d.plotY * d.mass);\n        }), c /= a, e /= a) : this.body && (a = this.body.mass, c = this.body.plotX, e = this.body.plotY);\n        this.mass = a;\n        this.plotX = c;\n        this.plotY = e;\n      },\n      divideBox: function () {\n        var a = this.box.width / 2,\n            c = this.box.height / 2;\n        this.nodes[0] = new l({\n          left: this.box.left,\n          top: this.box.top,\n          width: a,\n          height: c\n        });\n        this.nodes[1] = new l({\n          left: this.box.left + a,\n          top: this.box.top,\n          width: a,\n          height: c\n        });\n        this.nodes[2] = new l({\n          left: this.box.left + a,\n          top: this.box.top + c,\n          width: a,\n          height: c\n        });\n        this.nodes[3] = new l({\n          left: this.box.left,\n          top: this.box.top + c,\n          width: a,\n          height: c\n        });\n      },\n      getBoxPosition: function (a) {\n        var c = a.plotY < this.box.top + this.box.height / 2;\n        return a.plotX < this.box.left + this.box.width / 2 ? c ? 0 : 3 : c ? 1 : 2;\n      }\n    });\n\n    d = d.QuadTree = function (a, c, e, d) {\n      this.box = {\n        left: a,\n        top: c,\n        width: e,\n        height: d\n      };\n      this.maxDepth = 25;\n      this.root = new l(this.box, \"0\");\n      this.root.isInternal = !0;\n      this.root.isRoot = !0;\n      this.root.divideBox();\n    };\n\n    e(d.prototype, {\n      insertNodes: function (a) {\n        a.forEach(function (a) {\n          this.root.insert(a, this.maxDepth);\n        }, this);\n      },\n      visitNodeRecursive: function (a, c, e) {\n        var d;\n        a || (a = this.root);\n        a === this.root && c && (d = c(a));\n        !1 !== d && (a.nodes.forEach(function (a) {\n          if (a.isInternal) {\n            c && (d = c(a));\n            if (!1 === d) return;\n            this.visitNodeRecursive(a, c, e);\n          } else a.body && c && c(a.body);\n\n          e && e(a);\n        }, this), a === this.root && e && e(a));\n      },\n      calculateMassAndCenter: function () {\n        this.visitNodeRecursive(null, null, function (a) {\n          a.updateMassAndCenter();\n        });\n      }\n    });\n  });\n  A(d, \"Series/Networkgraph/Layouts.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = e.setAnimation;\n    e = a.addEvent;\n    var t = a.clamp,\n        p = a.defined,\n        k = a.extend,\n        x = a.isFunction,\n        w = a.pick;\n    l.layouts = {\n      \"reingold-fruchterman\": function () {}\n    };\n    k(l.layouts[\"reingold-fruchterman\"].prototype, {\n      init: function (b) {\n        this.options = b;\n        this.nodes = [];\n        this.links = [];\n        this.series = [];\n        this.box = {\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        };\n        this.setInitialRendering(!0);\n        this.integration = l.networkgraphIntegrations[b.integration];\n        this.enableSimulation = b.enableSimulation;\n        this.attractiveForce = w(b.attractiveForce, this.integration.attractiveForceFunction);\n        this.repulsiveForce = w(b.repulsiveForce, this.integration.repulsiveForceFunction);\n        this.approximation = b.approximation;\n      },\n      updateSimulation: function (b) {\n        this.enableSimulation = w(b, this.options.enableSimulation);\n      },\n      start: function () {\n        var b = this.series,\n            a = this.options;\n        this.currentStep = 0;\n        this.forces = b[0] && b[0].forces || [];\n        this.chart = b[0] && b[0].chart;\n        this.initialRendering && (this.initPositions(), b.forEach(function (b) {\n          b.finishedAnimating = !0;\n          b.render();\n        }));\n        this.setK();\n        this.resetSimulation(a);\n        this.enableSimulation && this.step();\n      },\n      step: function () {\n        var b = this,\n            a = this.series;\n        b.currentStep++;\n        \"barnes-hut\" === b.approximation && (b.createQuadTree(), b.quadTree.calculateMassAndCenter());\n        b.forces.forEach(function (a) {\n          b[a + \"Forces\"](b.temperature);\n        });\n        b.applyLimits(b.temperature);\n        b.temperature = b.coolDown(b.startTemperature, b.diffTemperature, b.currentStep);\n        b.prevSystemTemperature = b.systemTemperature;\n        b.systemTemperature = b.getSystemTemperature();\n        b.enableSimulation && (a.forEach(function (b) {\n          b.chart && b.render();\n        }), b.maxIterations-- && isFinite(b.temperature) && !b.isStable() ? (b.simulation && l.win.cancelAnimationFrame(b.simulation), b.simulation = l.win.requestAnimationFrame(function () {\n          b.step();\n        })) : b.simulation = !1);\n      },\n      stop: function () {\n        this.simulation && l.win.cancelAnimationFrame(this.simulation);\n      },\n      setArea: function (b, a, c, e) {\n        this.box = {\n          left: b,\n          top: a,\n          width: c,\n          height: e\n        };\n      },\n      setK: function () {\n        this.k = this.options.linkLength || this.integration.getK(this);\n      },\n      addElementsToCollection: function (b, a) {\n        b.forEach(function (b) {\n          -1 === a.indexOf(b) && a.push(b);\n        });\n      },\n      removeElementFromCollection: function (b, a) {\n        b = a.indexOf(b);\n        -1 !== b && a.splice(b, 1);\n      },\n      clear: function () {\n        this.nodes.length = 0;\n        this.links.length = 0;\n        this.series.length = 0;\n        this.resetSimulation();\n      },\n      resetSimulation: function () {\n        this.forcedStop = !1;\n        this.systemTemperature = 0;\n        this.setMaxIterations();\n        this.setTemperature();\n        this.setDiffTemperature();\n      },\n      restartSimulation: function () {\n        this.simulation ? this.resetSimulation() : (this.setInitialRendering(!1), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(!0));\n      },\n      setMaxIterations: function (b) {\n        this.maxIterations = w(b, this.options.maxIterations);\n      },\n      setTemperature: function () {\n        this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);\n      },\n      setDiffTemperature: function () {\n        this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);\n      },\n      setInitialRendering: function (b) {\n        this.initialRendering = b;\n      },\n      createQuadTree: function () {\n        this.quadTree = new l.QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n        this.quadTree.insertNodes(this.nodes);\n      },\n      initPositions: function () {\n        var b = this.options.initialPositions;\n        x(b) ? (b.call(this), this.nodes.forEach(function (b) {\n          p(b.prevX) || (b.prevX = b.plotX);\n          p(b.prevY) || (b.prevY = b.plotY);\n          b.dispX = 0;\n          b.dispY = 0;\n        })) : \"circle\" === b ? this.setCircularPositions() : this.setRandomPositions();\n      },\n      setCircularPositions: function () {\n        function b(a) {\n          a.linksFrom.forEach(function (a) {\n            l[a.toNode.id] || (l[a.toNode.id] = !0, k.push(a.toNode), b(a.toNode));\n          });\n        }\n\n        var a = this.box,\n            c = this.nodes,\n            e = 2 * Math.PI / (c.length + 1),\n            d = c.filter(function (b) {\n          return 0 === b.linksTo.length;\n        }),\n            k = [],\n            l = {},\n            p = this.options.initialPositionRadius;\n        d.forEach(function (a) {\n          k.push(a);\n          b(a);\n        });\n        k.length ? c.forEach(function (b) {\n          -1 === k.indexOf(b) && k.push(b);\n        }) : k = c;\n        k.forEach(function (b, c) {\n          b.plotX = b.prevX = w(b.plotX, a.width / 2 + p * Math.cos(c * e));\n          b.plotY = b.prevY = w(b.plotY, a.height / 2 + p * Math.sin(c * e));\n          b.dispX = 0;\n          b.dispY = 0;\n        });\n      },\n      setRandomPositions: function () {\n        function b(b) {\n          b = b * b / Math.PI;\n          return b -= Math.floor(b);\n        }\n\n        var a = this.box,\n            c = this.nodes,\n            e = c.length + 1;\n        c.forEach(function (c, g) {\n          c.plotX = c.prevX = w(c.plotX, a.width * b(g));\n          c.plotY = c.prevY = w(c.plotY, a.height * b(e + g));\n          c.dispX = 0;\n          c.dispY = 0;\n        });\n      },\n      force: function (b) {\n        this.integration[b].apply(this, Array.prototype.slice.call(arguments, 1));\n      },\n      barycenterForces: function () {\n        this.getBarycenter();\n        this.force(\"barycenter\");\n      },\n      getBarycenter: function () {\n        var b = 0,\n            a = 0,\n            c = 0;\n        this.nodes.forEach(function (g) {\n          a += g.plotX * g.mass;\n          c += g.plotY * g.mass;\n          b += g.mass;\n        });\n        return this.barycenter = {\n          x: a,\n          y: c,\n          xFactor: a / b,\n          yFactor: c / b\n        };\n      },\n      barnesHutApproximation: function (b, a) {\n        var c = this.getDistXY(b, a),\n            g = this.vectorLength(c);\n        if (b !== a && 0 !== g) if (a.isInternal) {\n          if (a.boxSize / g < this.options.theta && 0 !== g) {\n            var e = this.repulsiveForce(g, this.k);\n            this.force(\"repulsive\", b, e * a.mass, c, g);\n            var d = !1;\n          } else d = !0;\n        } else e = this.repulsiveForce(g, this.k), this.force(\"repulsive\", b, e * a.mass, c, g);\n        return d;\n      },\n      repulsiveForces: function () {\n        var b = this;\n        \"barnes-hut\" === b.approximation ? b.nodes.forEach(function (a) {\n          b.quadTree.visitNodeRecursive(null, function (c) {\n            return b.barnesHutApproximation(a, c);\n          });\n        }) : b.nodes.forEach(function (a) {\n          b.nodes.forEach(function (c) {\n            if (a !== c && !a.fixedPosition) {\n              var g = b.getDistXY(a, c);\n              var e = b.vectorLength(g);\n\n              if (0 !== e) {\n                var d = b.repulsiveForce(e, b.k);\n                b.force(\"repulsive\", a, d * c.mass, g, e);\n              }\n            }\n          });\n        });\n      },\n      attractiveForces: function () {\n        var b = this,\n            a,\n            c,\n            e;\n        b.links.forEach(function (g) {\n          g.fromNode && g.toNode && (a = b.getDistXY(g.fromNode, g.toNode), c = b.vectorLength(a), 0 !== c && (e = b.attractiveForce(c, b.k), b.force(\"attractive\", g, e, a, c)));\n        });\n      },\n      applyLimits: function () {\n        var b = this;\n        b.nodes.forEach(function (a) {\n          a.fixedPosition || (b.integration.integrate(b, a), b.applyLimitBox(a, b.box), a.dispX = 0, a.dispY = 0);\n        });\n      },\n      applyLimitBox: function (b, a) {\n        var c = b.radius;\n        b.plotX = t(b.plotX, a.left + c, a.width - c);\n        b.plotY = t(b.plotY, a.top + c, a.height - c);\n      },\n      coolDown: function (b, a, c) {\n        return b - a * c;\n      },\n      isStable: function () {\n        return .00001 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;\n      },\n      getSystemTemperature: function () {\n        return this.nodes.reduce(function (b, a) {\n          return b + a.temperature;\n        }, 0);\n      },\n      vectorLength: function (b) {\n        return Math.sqrt(b.x * b.x + b.y * b.y);\n      },\n      getDistR: function (b, a) {\n        b = this.getDistXY(b, a);\n        return this.vectorLength(b);\n      },\n      getDistXY: function (b, a) {\n        var c = b.plotX - a.plotX;\n        b = b.plotY - a.plotY;\n        return {\n          x: c,\n          y: b,\n          absX: Math.abs(c),\n          absY: Math.abs(b)\n        };\n      }\n    });\n    e(d, \"predraw\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (b) {\n        b.stop();\n      });\n    });\n    e(d, \"render\", function () {\n      function b(b) {\n        b.maxIterations-- && isFinite(b.temperature) && !b.isStable() && !b.enableSimulation && (b.beforeStep && b.beforeStep(), b.step(), e = !1, a = !0);\n      }\n\n      var a = !1;\n\n      if (this.graphLayoutsLookup) {\n        c(!1, this);\n\n        for (this.graphLayoutsLookup.forEach(function (b) {\n          b.start();\n        }); !e;) {\n          var e = !0;\n          this.graphLayoutsLookup.forEach(b);\n        }\n\n        a && this.series.forEach(function (b) {\n          b && b.layout && b.render();\n        });\n      }\n    });\n    e(d, \"beforePrint\", function () {\n      this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function (b) {\n        b.updateSimulation(!1);\n      }), this.redraw());\n    });\n    e(d, \"afterPrint\", function () {\n      this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function (b) {\n        b.updateSimulation();\n      });\n      this.redraw();\n    });\n  });\n  A(d, \"Series/PackedBubble/PackedBubbleComposition.js\", [d[\"Core/Chart/Chart.js\"], d[\"Core/Globals.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = e.layouts[\"reingold-fruchterman\"],\n        c = l.addEvent,\n        t = l.extendClass,\n        p = l.pick;\n\n    d.prototype.getSelectedParentNodes = function () {\n      var a = [];\n      this.series.forEach(function (c) {\n        c.parentNode && c.parentNode.selected && a.push(c.parentNode);\n      });\n      return a;\n    };\n\n    e.networkgraphIntegrations.packedbubble = {\n      repulsiveForceFunction: function (a, c, e, b) {\n        return Math.min(a, (e.marker.radius + b.marker.radius) / 2);\n      },\n      barycenter: function () {\n        var a = this,\n            c = a.options.gravitationalConstant,\n            e = a.box,\n            b = a.nodes,\n            d,\n            m;\n        b.forEach(function (g) {\n          a.options.splitSeries && !g.isParentNode ? (d = g.series.parentNode.plotX, m = g.series.parentNode.plotY) : (d = e.width / 2, m = e.height / 2);\n          g.fixedPosition || (g.plotX -= (g.plotX - d) * c / (g.mass * Math.sqrt(b.length)), g.plotY -= (g.plotY - m) * c / (g.mass * Math.sqrt(b.length)));\n        });\n      },\n      repulsive: function (a, c, e, b) {\n        var g = c * this.diffTemperature / a.mass / a.degree;\n        c = e.x * g;\n        e = e.y * g;\n        a.fixedPosition || (a.plotX += c, a.plotY += e);\n        b.fixedPosition || (b.plotX -= c, b.plotY -= e);\n      },\n      integrate: e.networkgraphIntegrations.verlet.integrate,\n      getK: e.noop\n    };\n    e.layouts.packedbubble = t(a, {\n      beforeStep: function () {\n        this.options.marker && this.series.forEach(function (a) {\n          a && a.calculateParentRadius();\n        });\n      },\n      isStable: function () {\n        var a = Math.abs(this.prevSystemTemperature - this.systemTemperature);\n        return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && .00001 > a || 0 >= this.temperature;\n      },\n      setCircularPositions: function () {\n        var a = this,\n            c = a.box,\n            e = a.nodes,\n            b = 2 * Math.PI / (e.length + 1),\n            g,\n            d,\n            n = a.options.initialPositionRadius;\n        e.forEach(function (e, k) {\n          a.options.splitSeries && !e.isParentNode ? (g = e.series.parentNode.plotX, d = e.series.parentNode.plotY) : (g = c.width / 2, d = c.height / 2);\n          e.plotX = e.prevX = p(e.plotX, g + n * Math.cos(e.index || k * b));\n          e.plotY = e.prevY = p(e.plotY, d + n * Math.sin(e.index || k * b));\n          e.dispX = 0;\n          e.dispY = 0;\n        });\n      },\n      repulsiveForces: function () {\n        var a = this,\n            c,\n            e,\n            b,\n            g = a.options.bubblePadding;\n        a.nodes.forEach(function (d) {\n          d.degree = d.mass;\n          d.neighbours = 0;\n          a.nodes.forEach(function (k) {\n            c = 0;\n            d === k || d.fixedPosition || !a.options.seriesInteraction && d.series !== k.series || (b = a.getDistXY(d, k), e = a.vectorLength(b) - (d.marker.radius + k.marker.radius + g), 0 > e && (d.degree += .01, d.neighbours++, c = a.repulsiveForce(-e / Math.sqrt(d.neighbours), a.k, d, k)), a.force(\"repulsive\", d, c * k.mass, b, k, e));\n          });\n        });\n      },\n      applyLimitBox: function (c) {\n        if (this.options.splitSeries && !c.isParentNode && this.options.parentNodeLimit) {\n          var e = this.getDistXY(c, c.series.parentNode);\n          var d = c.series.parentNodeRadius - c.marker.radius - this.vectorLength(e);\n          0 > d && d > -2 * c.marker.radius && (c.plotX -= .01 * e.x, c.plotY -= .01 * e.y);\n        }\n\n        a.prototype.applyLimitBox.apply(this, arguments);\n      }\n    });\n    c(d, \"beforeRedraw\", function () {\n      this.allDataPoints && delete this.allDataPoints;\n    });\n  });\n  A(d, \"Series/PackedBubble/PackedBubbleSeries.js\", [d[\"Core/Color/Color.js\"], d[\"Core/Globals.js\"], d[\"Series/PackedBubble/PackedBubblePoint.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a, c) {\n    var t = this && this.__extends || function () {\n      var a = function (b, h) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var h in b) b.hasOwnProperty(h) && (a[h] = b[h]);\n        };\n\n        return a(b, h);\n      };\n\n      return function (b, h) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, h);\n        b.prototype = null === h ? Object.create(h) : (f.prototype = h.prototype, new f());\n      };\n    }(),\n        p = d.parse,\n        k = a.series,\n        x = a.seriesTypes.bubble,\n        w = c.addEvent,\n        b = c.clamp,\n        g = c.defined,\n        m = c.extend,\n        n = c.fireEvent,\n        q = c.isArray,\n        H = c.isNumber,\n        A = c.merge,\n        I = c.pick,\n        y = e.dragNodesMixin;\n\n    d = function (a) {\n      function f() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.layout = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.xData = void 0;\n        return b;\n      }\n\n      t(f, a);\n\n      f.prototype.accumulateAllPoints = function (a) {\n        var b = a.chart,\n            h = [],\n            f,\n            c;\n\n        for (f = 0; f < b.series.length; f++) if (a = b.series[f], a.is(\"packedbubble\") && a.visible || !b.options.chart.ignoreHiddenSeries) for (c = 0; c < a.yData.length; c++) h.push([null, null, a.yData[c], a.index, c, {\n          id: c,\n          marker: {\n            radius: 0\n          }\n        }]);\n\n        return h;\n      };\n\n      f.prototype.addLayout = function () {\n        var a = this.options.layoutAlgorithm,\n            b = this.chart.graphLayoutsStorage,\n            f = this.chart.graphLayoutsLookup,\n            c = this.chart.options.chart;\n        b || (this.chart.graphLayoutsStorage = b = {}, this.chart.graphLayoutsLookup = f = []);\n        var d = b[a.type];\n        d || (a.enableSimulation = g(c.forExport) ? !c.forExport : a.enableSimulation, b[a.type] = d = new e.layouts[a.type](), d.init(a), f.splice(d.index, 0, d));\n        this.layout = d;\n        this.points.forEach(function (a) {\n          a.mass = 2;\n          a.degree = 1;\n          a.collisionNmb = 1;\n        });\n        d.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n        d.addElementsToCollection([this], d.series);\n        d.addElementsToCollection(this.points, d.nodes);\n      };\n\n      f.prototype.addSeriesLayout = function () {\n        var a = this.options.layoutAlgorithm,\n            b = this.chart.graphLayoutsStorage,\n            f = this.chart.graphLayoutsLookup,\n            c = A(a, a.parentNodeOptions, {\n          enableSimulation: this.layout.options.enableSimulation\n        });\n        var d = b[a.type + \"-series\"];\n        d || (b[a.type + \"-series\"] = d = new e.layouts[a.type](), d.init(c), f.splice(d.index, 0, d));\n        this.parentNodeLayout = d;\n        this.createParentNodes();\n      };\n\n      f.prototype.calculateParentRadius = function () {\n        var a = this.seriesBox();\n        this.parentNodeRadius = b(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a ? Math.max(Math.sqrt(Math.pow(a.width, 2) + Math.pow(a.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);\n        this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);\n      };\n\n      f.prototype.calculateZExtremes = function () {\n        var a = this.options.zMin,\n            b = this.options.zMax,\n            f = Infinity,\n            c = -Infinity;\n        if (a && b) return [a, b];\n        this.chart.series.forEach(function (a) {\n          a.yData.forEach(function (a) {\n            g(a) && (a > c && (c = a), a < f && (f = a));\n          });\n        });\n        a = I(a, f);\n        b = I(b, c);\n        return [a, b];\n      };\n\n      f.prototype.checkOverlap = function (a, b) {\n        var h = a[0] - b[0],\n            f = a[1] - b[1];\n        return -.001 > Math.sqrt(h * h + f * f) - Math.abs(a[2] + b[2]);\n      };\n\n      f.prototype.createParentNodes = function () {\n        var a = this,\n            b = a.chart,\n            f = a.parentNodeLayout,\n            c,\n            e = a.parentNode,\n            d = a.pointClass,\n            g = a.layout.options,\n            k = {\n          radius: a.parentNodeRadius,\n          lineColor: a.color,\n          fillColor: p(a.color).brighten(.4).get()\n        };\n        g.parentNodeOptions && (k = A(g.parentNodeOptions.marker || {}, k));\n        a.parentNodeMass = 0;\n        a.points.forEach(function (b) {\n          a.parentNodeMass += Math.PI * Math.pow(b.marker.radius, 2);\n        });\n        a.calculateParentRadius();\n        f.nodes.forEach(function (b) {\n          b.seriesIndex === a.index && (c = !0);\n        });\n        f.setArea(0, 0, b.plotWidth, b.plotHeight);\n        c || (e || (e = new d().init(this, {\n          mass: a.parentNodeRadius / 2,\n          marker: k,\n          dataLabels: {\n            inside: !1\n          },\n          states: {\n            normal: {\n              marker: k\n            },\n            hover: {\n              marker: k\n            }\n          },\n          dataLabelOnNull: !0,\n          degree: a.parentNodeRadius,\n          isParentNode: !0,\n          seriesIndex: a.index\n        })), a.parentNode && (e.plotX = a.parentNode.plotX, e.plotY = a.parentNode.plotY), a.parentNode = e, f.addElementsToCollection([a], f.series), f.addElementsToCollection([e], f.nodes));\n      };\n\n      f.prototype.deferLayout = function () {\n        var a = this.options.layoutAlgorithm;\n        this.visible && (this.addLayout(), a.splitSeries && this.addSeriesLayout());\n      };\n\n      f.prototype.destroy = function () {\n        this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function (a) {\n          a.removeElementFromCollection(this, a.series);\n        }, this);\n        this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));\n        k.prototype.destroy.apply(this, arguments);\n      };\n\n      f.prototype.drawDataLabels = function () {\n        var a = this.options.dataLabels.textPath,\n            b = this.points;\n        k.prototype.drawDataLabels.apply(this, arguments);\n        this.parentNode && (this.parentNode.formatPrefix = \"parentNode\", this.points = [this.parentNode], this.options.dataLabels.textPath = this.options.dataLabels.parentNodeTextPath, k.prototype.drawDataLabels.apply(this, arguments), this.points = b, this.options.dataLabels.textPath = a);\n      };\n\n      f.prototype.drawGraph = function () {\n        if (this.layout && this.layout.options.splitSeries) {\n          var a = this.chart;\n          var b = this.layout.options.parentNodeOptions.marker;\n          var f = {\n            fill: b.fillColor || p(this.color).brighten(.4).get(),\n            opacity: b.fillOpacity,\n            stroke: b.lineColor || this.color,\n            \"stroke-width\": I(b.lineWidth, this.options.lineWidth)\n          };\n          this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup(\"parentNodesGroup\", \"parentNode\", this.visible ? \"inherit\" : \"hidden\", .1, a.seriesGroup), this.group.attr({\n            zIndex: 2\n          }));\n          this.calculateParentRadius();\n          b = A({\n            x: this.parentNode.plotX - this.parentNodeRadius,\n            y: this.parentNode.plotY - this.parentNodeRadius,\n            width: 2 * this.parentNodeRadius,\n            height: 2 * this.parentNodeRadius\n          }, f);\n          this.parentNode.graphic || (this.graph = this.parentNode.graphic = a.renderer.symbol(f.symbol).add(this.parentNodesGroup));\n          this.parentNode.graphic.attr(b);\n        }\n      };\n\n      f.prototype.drawTracker = function () {\n        var b = this.parentNode;\n        a.prototype.drawTracker.call(this);\n\n        if (b) {\n          var f = q(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : [];\n          b.graphic && (b.graphic.element.point = b);\n          f.forEach(function (a) {\n            a.div ? a.div.point = b : a.element.point = b;\n          });\n        }\n      };\n\n      f.prototype.getPointRadius = function () {\n        var a = this,\n            f = a.chart,\n            c = a.options,\n            e = c.useSimulation,\n            d = Math.min(f.plotWidth, f.plotHeight),\n            g = {},\n            k = [],\n            l = f.allDataPoints,\n            n,\n            m,\n            p,\n            z;\n        [\"minSize\", \"maxSize\"].forEach(function (a) {\n          var b = parseInt(c[a], 10),\n              f = /%$/.test(c[a]);\n          g[a] = f ? d * b / 100 : b * Math.sqrt(l.length);\n        });\n        f.minRadius = n = g.minSize / Math.sqrt(l.length);\n        f.maxRadius = m = g.maxSize / Math.sqrt(l.length);\n        var q = e ? a.calculateZExtremes() : [n, m];\n        (l || []).forEach(function (f, h) {\n          p = e ? b(f[2], q[0], q[1]) : f[2];\n          z = a.getRadius(q[0], q[1], n, m, p);\n          0 === z && (z = null);\n          l[h][2] = z;\n          k.push(z);\n        });\n        a.radii = k;\n      };\n\n      f.prototype.init = function () {\n        k.prototype.init.apply(this, arguments);\n        this.eventsToUnbind.push(w(this, \"updatedData\", function () {\n          this.chart.series.forEach(function (a) {\n            a.type === this.type && (a.isDirty = !0);\n          }, this);\n        }));\n        return this;\n      };\n\n      f.prototype.onMouseUp = function (a) {\n        if (a.fixedPosition && !a.removed) {\n          var b,\n              f,\n              h = this.layout,\n              c = this.parentNodeLayout;\n          c && h.options.dragBetweenSeries && c.nodes.forEach(function (c) {\n            a && a.marker && c !== a.series.parentNode && (b = h.getDistXY(a, c), f = h.vectorLength(b) - c.marker.radius - a.marker.radius, 0 > f && (c.series.addPoint(A(a.options, {\n              plotX: a.plotX,\n              plotY: a.plotY\n            }), !1), h.removeElementFromCollection(a, h.nodes), a.remove()));\n          });\n          y.onMouseUp.apply(this, arguments);\n        }\n      };\n\n      f.prototype.placeBubbles = function (a) {\n        var b = this.checkOverlap,\n            f = this.positionBubble,\n            c = [],\n            h = 1,\n            e = 0,\n            d = 0;\n        var g = [];\n        var k;\n        a = a.sort(function (a, b) {\n          return b[2] - a[2];\n        });\n\n        if (a.length) {\n          c.push([[0, 0, a[0][2], a[0][3], a[0][4]]]);\n          if (1 < a.length) for (c.push([[0, 0 - a[1][2] - a[0][2], a[1][2], a[1][3], a[1][4]]]), k = 2; k < a.length; k++) a[k][2] = a[k][2] || 1, g = f(c[h][e], c[h - 1][d], a[k]), b(g, c[h][0]) ? (c.push([]), d = 0, c[h + 1].push(f(c[h][e], c[h][0], a[k])), h++, e = 0) : 1 < h && c[h - 1][d + 1] && b(g, c[h - 1][d + 1]) ? (d++, c[h].push(f(c[h][e], c[h - 1][d], a[k])), e++) : (e++, c[h].push(g));\n          this.chart.stages = c;\n          this.chart.rawPositions = [].concat.apply([], c);\n          this.resizeRadius();\n          g = this.chart.rawPositions;\n        }\n\n        return g;\n      };\n\n      f.prototype.pointAttribs = function (a, b) {\n        var f = this.options,\n            c = f.marker;\n        a && a.isParentNode && f.layoutAlgorithm && f.layoutAlgorithm.parentNodeOptions && (c = f.layoutAlgorithm.parentNodeOptions.marker);\n        f = c.fillOpacity;\n        a = k.prototype.pointAttribs.call(this, a, b);\n        1 !== f && (a[\"fill-opacity\"] = f);\n        return a;\n      };\n\n      f.prototype.positionBubble = function (a, b, f) {\n        var c = Math.sqrt,\n            h = Math.asin,\n            e = Math.acos,\n            d = Math.pow,\n            g = Math.abs;\n        c = c(d(a[0] - b[0], 2) + d(a[1] - b[1], 2));\n        e = e((d(c, 2) + d(f[2] + b[2], 2) - d(f[2] + a[2], 2)) / (2 * (f[2] + b[2]) * c));\n        h = h(g(a[0] - b[0]) / c);\n        a = (0 > a[1] - b[1] ? 0 : Math.PI) + e + h * (0 > (a[0] - b[0]) * (a[1] - b[1]) ? 1 : -1);\n        return [b[0] + (b[2] + f[2]) * Math.sin(a), b[1] - (b[2] + f[2]) * Math.cos(a), f[2], f[3], f[4]];\n      };\n\n      f.prototype.render = function () {\n        var a = [];\n        k.prototype.render.apply(this, arguments);\n        this.options.dataLabels.allowOverlap || (this.data.forEach(function (b) {\n          q(b.dataLabels) && b.dataLabels.forEach(function (b) {\n            a.push(b);\n          });\n        }), this.options.useSimulation && this.chart.hideOverlappingLabels(a));\n      };\n\n      f.prototype.resizeRadius = function () {\n        var a = this.chart,\n            b = a.rawPositions,\n            f = Math.min,\n            c = Math.max,\n            e = a.plotLeft,\n            d = a.plotTop,\n            g = a.plotHeight,\n            k = a.plotWidth,\n            l,\n            n,\n            m;\n        var p = l = Number.POSITIVE_INFINITY;\n        var z = n = Number.NEGATIVE_INFINITY;\n\n        for (m = 0; m < b.length; m++) {\n          var q = b[m][2];\n          p = f(p, b[m][0] - q);\n          z = c(z, b[m][0] + q);\n          l = f(l, b[m][1] - q);\n          n = c(n, b[m][1] + q);\n        }\n\n        m = [z - p, n - l];\n        f = f.apply([], [(k - e) / m[0], (g - d) / m[1]]);\n\n        if (1e-10 < Math.abs(f - 1)) {\n          for (m = 0; m < b.length; m++) b[m][2] *= f;\n\n          this.placeBubbles(b);\n        } else a.diffY = g / 2 + d - l - (n - l) / 2, a.diffX = k / 2 + e - p - (z - p) / 2;\n      };\n\n      f.prototype.seriesBox = function () {\n        var a = this.chart,\n            b = Math.max,\n            f = Math.min,\n            c,\n            e = [a.plotLeft, a.plotLeft + a.plotWidth, a.plotTop, a.plotTop + a.plotHeight];\n        this.data.forEach(function (a) {\n          g(a.plotX) && g(a.plotY) && a.marker.radius && (c = a.marker.radius, e[0] = f(e[0], a.plotX - c), e[1] = b(e[1], a.plotX + c), e[2] = f(e[2], a.plotY - c), e[3] = b(e[3], a.plotY + c));\n        });\n        return H(e.width / e.height) ? e : null;\n      };\n\n      f.prototype.setVisible = function () {\n        var a = this;\n        k.prototype.setVisible.apply(a, arguments);\n        a.parentNodeLayout && a.graph ? a.visible ? (a.graph.show(), a.parentNode.dataLabel && a.parentNode.dataLabel.show()) : (a.graph.hide(), a.parentNodeLayout.removeElementFromCollection(a.parentNode, a.parentNodeLayout.nodes), a.parentNode.dataLabel && a.parentNode.dataLabel.hide()) : a.layout && (a.visible ? a.layout.addElementsToCollection(a.points, a.layout.nodes) : a.points.forEach(function (b) {\n          a.layout.removeElementFromCollection(b, a.layout.nodes);\n        }));\n      };\n\n      f.prototype.translate = function () {\n        var a = this.chart,\n            b = this.data,\n            f = this.index,\n            c,\n            e = this.options.useSimulation;\n        this.processedXData = this.xData;\n        this.generatePoints();\n        g(a.allDataPoints) || (a.allDataPoints = this.accumulateAllPoints(this), this.getPointRadius());\n        if (e) var d = a.allDataPoints;else d = this.placeBubbles(a.allDataPoints), this.options.draggable = !1;\n\n        for (c = 0; c < d.length; c++) if (d[c][3] === f) {\n          var k = b[d[c][4]];\n          var l = I(d[c][2], void 0);\n          e || (k.plotX = d[c][0] - a.plotLeft + a.diffX, k.plotY = d[c][1] - a.plotTop + a.diffY);\n          H(l) && (k.marker = m(k.marker, {\n            radius: l,\n            width: 2 * l,\n            height: 2 * l\n          }), k.radius = l);\n        }\n\n        e && this.deferLayout();\n        n(this, \"afterTranslate\");\n      };\n\n      f.defaultOptions = A(x.defaultOptions, {\n        minSize: \"10%\",\n        maxSize: \"50%\",\n        sizeBy: \"area\",\n        zoneAxis: \"y\",\n        crisp: !1,\n        tooltip: {\n          pointFormat: \"Value: {point.value}\"\n        },\n        draggable: !0,\n        useSimulation: !0,\n        parentNode: {\n          allowPointSelect: !1\n        },\n        dataLabels: {\n          formatter: function () {\n            var a = this.series.chart.numberFormatter,\n                b = this.point.value;\n            return H(b) ? a(b, -1) : \"\";\n          },\n          parentNodeFormatter: function () {\n            return this.name;\n          },\n          parentNodeTextPath: {\n            enabled: !0\n          },\n          padding: 0,\n          style: {\n            transition: \"opacity 2000ms\"\n          }\n        },\n        layoutAlgorithm: {\n          initialPositions: \"circle\",\n          initialPositionRadius: 20,\n          bubblePadding: 5,\n          parentNodeLimit: !1,\n          seriesInteraction: !0,\n          dragBetweenSeries: !1,\n          parentNodeOptions: {\n            maxIterations: 400,\n            gravitationalConstant: .03,\n            maxSpeed: 50,\n            initialPositionRadius: 100,\n            seriesInteraction: !0,\n            marker: {\n              fillColor: null,\n              fillOpacity: 1,\n              lineWidth: null,\n              lineColor: null,\n              symbol: \"circle\"\n            }\n          },\n          enableSimulation: !0,\n          type: \"packedbubble\",\n          integration: \"packedbubble\",\n          maxIterations: 1E3,\n          splitSeries: !1,\n          maxSpeed: 5,\n          gravitationalConstant: .01,\n          friction: -.981\n        }\n      });\n      return f;\n    }(x);\n\n    m(d.prototype, {\n      alignDataLabel: k.prototype.alignDataLabel,\n      axisTypes: [],\n      directTouch: !0,\n      forces: [\"barycenter\", \"repulsive\"],\n      hasDraggableNodes: !0,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      onMouseDown: y.onMouseDown,\n      onMouseMove: y.onMouseMove,\n      pointArrayMap: [\"value\"],\n      pointClass: l,\n      pointValKey: \"value\",\n      redrawHalo: y.redrawHalo,\n      requireSorting: !1,\n      searchPoint: e.noop,\n      trackerGroups: [\"group\", \"dataLabelsGroup\", \"parentNodesGroup\"]\n    });\n    a.registerSeriesType(\"packedbubble\", d);\n    \"\";\n    \"\";\n    return d;\n  });\n  A(d, \"Series/Polygon/PolygonSeries.js\", [d[\"Core/Globals.js\"], d[\"Core/Legend/LegendSymbol.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a) {\n    var c = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function e() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (e.prototype = c.prototype, new e());\n      };\n    }();\n\n    d = d.noop;\n    var t = l.series,\n        p = l.seriesTypes,\n        k = p.area,\n        x = p.line,\n        w = p.scatter;\n    p = a.extend;\n    var b = a.merge;\n\n    a = function (a) {\n      function e() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      c(e, a);\n\n      e.prototype.getGraphPath = function () {\n        for (var a = x.prototype.getGraphPath.call(this), b = a.length + 1; b--;) (b === a.length || \"M\" === a[b][0]) && 0 < b && a.splice(b, 0, [\"Z\"]);\n\n        return this.areaPath = a;\n      };\n\n      e.prototype.drawGraph = function () {\n        this.options.fillColor = this.color;\n        k.prototype.drawGraph.call(this);\n      };\n\n      e.defaultOptions = b(w.defaultOptions, {\n        marker: {\n          enabled: !1,\n          states: {\n            hover: {\n              enabled: !1\n            }\n          }\n        },\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0,\n          pointFormat: \"\"\n        },\n        trackByArea: !0\n      });\n      return e;\n    }(w);\n\n    p(a.prototype, {\n      type: \"polygon\",\n      drawLegendSymbol: e.drawRectangle,\n      drawTracker: t.prototype.drawTracker,\n      setStackedPoints: d\n    });\n    l.registerSeriesType(\"polygon\", a);\n    \"\";\n    return a;\n  });\n  A(d, \"Core/Axis/WaterfallAxis.js\", [d[\"Extensions/Stacking.js\"], d[\"Core/Utilities.js\"]], function (d, e) {\n    var l = e.addEvent,\n        a = e.objectEach,\n        c;\n\n    (function (c) {\n      function e() {\n        var a = this.waterfall.stacks;\n        a && (a.changed = !1, delete a.alreadyChanged);\n      }\n\n      function k() {\n        var a = this.options.stackLabels;\n        a && a.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();\n      }\n\n      function x() {\n        for (var a = this.axes, b = this.series, c = b.length; c--;) b[c].options.stacking && (a.forEach(function (a) {\n          a.isXAxis || (a.waterfall.stacks.changed = !0);\n        }), c = 0);\n      }\n\n      function w() {\n        this.waterfall || (this.waterfall = new b(this));\n      }\n\n      var b = function () {\n        function b(a) {\n          this.axis = a;\n          this.stacks = {\n            changed: !1\n          };\n        }\n\n        b.prototype.renderStackTotals = function () {\n          var b = this.axis,\n              c = b.waterfall.stacks,\n              e = b.stacking && b.stacking.stackTotalGroup,\n              g = new d(b, b.options.stackLabels, !1, 0, void 0);\n          this.dummyStackItem = g;\n          a(c, function (b) {\n            a(b, function (a) {\n              g.total = a.stackTotal;\n              a.label && (g.label = a.label);\n              d.prototype.render.call(g, e);\n              a.label = g.label;\n              delete g.label;\n            });\n          });\n          g.total = null;\n        };\n\n        return b;\n      }();\n\n      c.Composition = b;\n\n      c.compose = function (a, b) {\n        l(a, \"init\", w);\n        l(a, \"afterBuildStacks\", e);\n        l(a, \"afterRender\", k);\n        l(b, \"beforeRedraw\", x);\n      };\n    })(c || (c = {}));\n\n    return c;\n  });\n  A(d, \"Series/Waterfall/WaterfallPoint.js\", [d[\"Series/Column/ColumnSeries.js\"], d[\"Core/Series/Point.js\"], d[\"Core/Utilities.js\"]], function (d, e, l) {\n    var a = this && this.__extends || function () {\n      var a = function (c, e) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return a(c, e);\n      };\n\n      return function (c, e) {\n        function d() {\n          this.constructor = c;\n        }\n\n        a(c, e);\n        c.prototype = null === e ? Object.create(e) : (d.prototype = e.prototype, new d());\n      };\n    }(),\n        c = l.isNumber;\n\n    return function (d) {\n      function l() {\n        var a = null !== d && d.apply(this, arguments) || this;\n        a.options = void 0;\n        a.series = void 0;\n        return a;\n      }\n\n      a(l, d);\n\n      l.prototype.getClassName = function () {\n        var a = e.prototype.getClassName.call(this);\n        this.isSum ? a += \" highcharts-sum\" : this.isIntermediateSum && (a += \" highcharts-intermediate-sum\");\n        return a;\n      };\n\n      l.prototype.isValid = function () {\n        return c(this.y) || this.isSum || !!this.isIntermediateSum;\n      };\n\n      return l;\n    }(d.prototype.pointClass);\n  });\n  A(d, \"Series/Waterfall/WaterfallSeries.js\", [d[\"Core/Axis/Axis.js\"], d[\"Core/Chart/Chart.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Utilities.js\"], d[\"Core/Axis/WaterfallAxis.js\"], d[\"Series/Waterfall/WaterfallPoint.js\"]], function (d, e, l, a, c, t) {\n    var p = this && this.__extends || function () {\n      var a = function (b, c) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, b) {\n          a.__proto__ = b;\n        } || function (a, b) {\n          for (var c in b) b.hasOwnProperty(c) && (a[c] = b[c]);\n        };\n\n        return a(b, c);\n      };\n\n      return function (b, c) {\n        function f() {\n          this.constructor = b;\n        }\n\n        a(b, c);\n        b.prototype = null === c ? Object.create(c) : (f.prototype = c.prototype, new f());\n      };\n    }(),\n        k = l.seriesTypes,\n        x = k.column,\n        w = k.line,\n        b = a.arrayMax,\n        g = a.arrayMin,\n        m = a.correctFloat;\n\n    k = a.extend;\n    var n = a.isNumber,\n        q = a.merge,\n        A = a.objectEach,\n        J = a.pick;\n\n    a = function (a) {\n      function c() {\n        var b = null !== a && a.apply(this, arguments) || this;\n        b.chart = void 0;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        b.stackedYNeg = void 0;\n        b.stackedYPos = void 0;\n        b.stackKey = void 0;\n        b.xData = void 0;\n        b.yAxis = void 0;\n        b.yData = void 0;\n        return b;\n      }\n\n      p(c, a);\n\n      c.prototype.generatePoints = function () {\n        var a;\n        x.prototype.generatePoints.apply(this);\n        var b = 0;\n\n        for (a = this.points.length; b < a; b++) {\n          var c = this.points[b];\n          var e = this.processedYData[b];\n          if (c.isIntermediateSum || c.isSum) c.y = m(e);\n        }\n      };\n\n      c.prototype.translate = function () {\n        var a = this.options,\n            b = this.yAxis,\n            c = J(a.minPointLength, 5),\n            e = c / 2,\n            d = a.threshold || 0,\n            g = d,\n            k = d;\n        a = a.stacking;\n        var l = b.waterfall.stacks[this.stackKey];\n        x.prototype.translate.apply(this);\n\n        for (var m = this.points, p = 0; p < m.length; p++) {\n          var q = m[p];\n          var w = this.processedYData[p];\n          var C = q.shapeArgs;\n\n          if (C && n(w)) {\n            var t = [0, w];\n            var D = q.y;\n\n            if (a) {\n              if (l) {\n                t = l[p];\n\n                if (\"overlap\" === a) {\n                  var y = t.stackState[t.stateIndex--];\n                  y = 0 <= D ? y : y - D;\n                  Object.hasOwnProperty.call(t, \"absolutePos\") && delete t.absolutePos;\n                  Object.hasOwnProperty.call(t, \"absoluteNeg\") && delete t.absoluteNeg;\n                } else 0 <= D ? (y = t.threshold + t.posTotal, t.posTotal -= D) : (y = t.threshold + t.negTotal, t.negTotal -= D, y -= D), !t.posTotal && Object.hasOwnProperty.call(t, \"absolutePos\") && (t.posTotal = t.absolutePos, delete t.absolutePos), !t.negTotal && Object.hasOwnProperty.call(t, \"absoluteNeg\") && (t.negTotal = t.absoluteNeg, delete t.absoluteNeg);\n\n                q.isSum || (t.connectorThreshold = t.threshold + t.stackTotal);\n                b.reversed ? (w = 0 <= D ? y - D : y + D, D = y) : (w = y, D = y - D);\n                q.below = w <= d;\n                C.y = b.translate(w, !1, !0, !1, !0) || 0;\n                C.height = Math.abs(C.y - (b.translate(D, !1, !0, !1, !0) || 0));\n                if (D = b.waterfall.dummyStackItem) D.x = p, D.label = l[p].label, D.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[p], this.stackedYPos[p]);\n              }\n            } else y = Math.max(g, g + D) + t[0], C.y = b.translate(y, !1, !0, !1, !0) || 0, q.isSum ? (C.y = b.translate(t[1], !1, !0, !1, !0) || 0, C.height = Math.min(b.translate(t[0], !1, !0, !1, !0) || 0, b.len) - C.y, q.below = t[1] <= d) : q.isIntermediateSum ? (0 <= D ? (w = t[1] + k, D = k) : (w = k, D = t[1] + k), b.reversed && (w ^= D, D ^= w, w ^= D), C.y = b.translate(w, !1, !0, !1, !0) || 0, C.height = Math.abs(C.y - Math.min(b.translate(D, !1, !0, !1, !0) || 0, b.len)), k += t[1], q.below = w <= d) : (C.height = 0 < w ? (b.translate(g, !1, !0, !1, !0) || 0) - C.y : (b.translate(g, !1, !0, !1, !0) || 0) - (b.translate(g - w, !1, !0, !1, !0) || 0), g += w, q.below = g < d), 0 > C.height && (C.y += C.height, C.height *= -1);\n\n            q.plotY = C.y = Math.round(C.y || 0) - this.borderWidth % 2 / 2;\n            C.height = Math.max(Math.round(C.height || 0), .001);\n            q.yBottom = C.y + C.height;\n            C.height <= c && !q.isNull ? (C.height = c, C.y -= e, q.plotY = C.y, q.minPointLengthOffset = 0 > q.y ? -e : e) : (q.isNull && (C.width = 0), q.minPointLengthOffset = 0);\n            D = q.plotY + (q.negative ? C.height : 0);\n            q.below && (q.plotY += C.height);\n            q.tooltipPos && (this.chart.inverted ? q.tooltipPos[0] = b.len - D : q.tooltipPos[1] = D);\n            q.isInside = this.isPointInside(q);\n          }\n        }\n      };\n\n      c.prototype.processData = function (b) {\n        var c = this.options,\n            e = this.yData,\n            d = c.data,\n            g = e.length,\n            k = c.threshold || 0,\n            l,\n            n,\n            p,\n            q,\n            t;\n\n        for (t = n = l = p = q = 0; t < g; t++) {\n          var z = e[t];\n          var w = d && d[t] ? d[t] : {};\n          \"sum\" === z || w.isSum ? e[t] = m(n) : \"intermediateSum\" === z || w.isIntermediateSum ? (e[t] = m(l), l = 0) : (n += z, l += z);\n          p = Math.min(n, p);\n          q = Math.max(n, q);\n        }\n\n        a.prototype.processData.call(this, b);\n        c.stacking || (this.dataMin = p + k, this.dataMax = q);\n      };\n\n      c.prototype.toYData = function (a) {\n        return a.isSum ? \"sum\" : a.isIntermediateSum ? \"intermediateSum\" : a.y;\n      };\n\n      c.prototype.updateParallelArrays = function (b, c) {\n        a.prototype.updateParallelArrays.call(this, b, c);\n        if (\"sum\" === this.yData[0] || \"intermediateSum\" === this.yData[0]) this.yData[0] = null;\n      };\n\n      c.prototype.pointAttribs = function (a, b) {\n        var c = this.options.upColor;\n        c && !a.options.color && (a.color = 0 < a.y ? c : null);\n        a = x.prototype.pointAttribs.call(this, a, b);\n        delete a.dashstyle;\n        return a;\n      };\n\n      c.prototype.getGraphPath = function () {\n        return [[\"M\", 0, 0]];\n      };\n\n      c.prototype.getCrispPath = function () {\n        var a = this.data,\n            b = this.yAxis,\n            c = a.length,\n            e = Math.round(this.graph.strokeWidth()) % 2 / 2,\n            d = Math.round(this.borderWidth) % 2 / 2,\n            g = this.xAxis.reversed,\n            k = this.yAxis.reversed,\n            l = this.options.stacking,\n            m = [],\n            n;\n\n        for (n = 1; n < c; n++) {\n          var p = a[n].shapeArgs;\n          var q = a[n - 1];\n          var t = a[n - 1].shapeArgs;\n          var w = b.waterfall.stacks[this.stackKey];\n          var x = 0 < q.y ? -t.height : 0;\n          w && t && p && (w = w[n - 1], l ? (w = w.connectorThreshold, x = Math.round(b.translate(w, 0, 1, 0, 1) + (k ? x : 0)) - e) : x = t.y + q.minPointLengthOffset + d - e, m.push([\"M\", (t.x || 0) + (g ? 0 : t.width || 0), x], [\"L\", (p.x || 0) + (g ? p.width || 0 : 0), x]));\n          t && m.length && (!l && 0 > q.y && !k || 0 < q.y && k) && ((q = m[m.length - 2]) && \"number\" === typeof q[2] && (q[2] += t.height || 0), (q = m[m.length - 1]) && \"number\" === typeof q[2] && (q[2] += t.height || 0));\n        }\n\n        return m;\n      };\n\n      c.prototype.drawGraph = function () {\n        w.prototype.drawGraph.call(this);\n        this.graph.attr({\n          d: this.getCrispPath()\n        });\n      };\n\n      c.prototype.setStackedPoints = function () {\n        function a(a, b, c, f) {\n          if (J) for (c; c < J; c++) A.stackState[c] += f;else A.stackState[0] = a, J = A.stackState.length;\n          A.stackState.push(A.stackState[J - 1] + b);\n        }\n\n        var b = this.options,\n            c = this.yAxis.waterfall.stacks,\n            e = b.threshold,\n            d = e || 0,\n            g = d,\n            k = this.stackKey,\n            l = this.xData,\n            m = l.length,\n            n,\n            p,\n            q;\n        this.yAxis.stacking.usePercentage = !1;\n        var t = p = q = d;\n\n        if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {\n          var w = c.changed;\n          (n = c.alreadyChanged) && 0 > n.indexOf(k) && (w = !0);\n          c[k] || (c[k] = {});\n          n = c[k];\n\n          for (var x = 0; x < m; x++) {\n            var y = l[x];\n            if (!n[y] || w) n[y] = {\n              negTotal: 0,\n              posTotal: 0,\n              stackTotal: 0,\n              threshold: 0,\n              stateIndex: 0,\n              stackState: [],\n              label: w && n[y] ? n[y].label : void 0\n            };\n            var A = n[y];\n            var G = this.yData[x];\n            0 <= G ? A.posTotal += G : A.negTotal += G;\n            var F = b.data[x];\n            y = A.absolutePos = A.posTotal;\n            var H = A.absoluteNeg = A.negTotal;\n            A.stackTotal = y + H;\n            var J = A.stackState.length;\n            F && F.isIntermediateSum ? (a(q, p, 0, q), q = p, p = e, d ^= g, g ^= d, d ^= g) : F && F.isSum ? (a(e, t, J), d = e) : (a(d, G, 0, t), F && (t += G, p += G));\n            A.stateIndex++;\n            A.threshold = d;\n            d += A.stackTotal;\n          }\n\n          c.changed = !1;\n          c.alreadyChanged || (c.alreadyChanged = []);\n          c.alreadyChanged.push(k);\n        }\n      };\n\n      c.prototype.getExtremes = function () {\n        var a = this.options.stacking;\n\n        if (a) {\n          var c = this.yAxis;\n          c = c.waterfall.stacks;\n          var e = this.stackedYNeg = [];\n          var d = this.stackedYPos = [];\n          \"overlap\" === a ? A(c[this.stackKey], function (a) {\n            e.push(g(a.stackState));\n            d.push(b(a.stackState));\n          }) : A(c[this.stackKey], function (a) {\n            e.push(a.negTotal + a.threshold);\n            d.push(a.posTotal + a.threshold);\n          });\n          return {\n            dataMin: g(e),\n            dataMax: b(d)\n          };\n        }\n\n        return {\n          dataMin: this.dataMin,\n          dataMax: this.dataMax\n        };\n      };\n\n      c.defaultOptions = q(x.defaultOptions, {\n        dataLabels: {\n          inside: !0\n        },\n        lineWidth: 1,\n        lineColor: \"#333333\",\n        dashStyle: \"Dot\",\n        borderColor: \"#333333\",\n        states: {\n          hover: {\n            lineWidthPlus: 0\n          }\n        }\n      });\n      return c;\n    }(x);\n\n    k(a.prototype, {\n      getZonesGraphs: w.prototype.getZonesGraphs,\n      pointValKey: \"y\",\n      showLine: !0,\n      pointClass: t\n    });\n    l.registerSeriesType(\"waterfall\", a);\n    c.compose(d, e);\n    \"\";\n    return a;\n  });\n  A(d, \"Extensions/Polar.js\", [d[\"Core/Animation/AnimationUtilities.js\"], d[\"Core/Chart/Chart.js\"], d[\"Core/Globals.js\"], d[\"Extensions/Pane.js\"], d[\"Core/Pointer.js\"], d[\"Core/Series/Series.js\"], d[\"Core/Series/SeriesRegistry.js\"], d[\"Core/Renderer/SVG/SVGRenderer.js\"], d[\"Core/Utilities.js\"]], function (d, e, l, a, c, t, p, k, x) {\n    var w = d.animObject;\n    p = p.seriesTypes;\n    var b = x.addEvent,\n        g = x.defined,\n        m = x.find,\n        n = x.isNumber,\n        q = x.pick,\n        A = x.splat,\n        J = x.uniqueKey;\n    d = x.wrap;\n    var I = t.prototype;\n    c = c.prototype;\n\n    I.searchPointByAngle = function (a) {\n      var b = this.chart,\n          c = this.xAxis.pane.center;\n      return this.searchKDTree({\n        clientX: 180 + -180 / Math.PI * Math.atan2(a.chartX - c[0] - b.plotLeft, a.chartY - c[1] - b.plotTop)\n      });\n    };\n\n    I.getConnectors = function (a, b, c, e) {\n      var f = e ? 1 : 0;\n      var d = 0 <= b && b <= a.length - 1 ? b : 0 > b ? a.length - 1 + b : 0;\n      b = 0 > d - 1 ? a.length - (1 + f) : d - 1;\n      f = d + 1 > a.length - 1 ? f : d + 1;\n      var g = a[b];\n      f = a[f];\n      var h = g.plotX;\n      g = g.plotY;\n      var k = f.plotX;\n      var l = f.plotY;\n      f = a[d].plotX;\n      d = a[d].plotY;\n      h = (1.5 * f + h) / 2.5;\n      g = (1.5 * d + g) / 2.5;\n      k = (1.5 * f + k) / 2.5;\n      var r = (1.5 * d + l) / 2.5;\n      l = Math.sqrt(Math.pow(h - f, 2) + Math.pow(g - d, 2));\n      var n = Math.sqrt(Math.pow(k - f, 2) + Math.pow(r - d, 2));\n      h = Math.atan2(g - d, h - f);\n      r = Math.PI / 2 + (h + Math.atan2(r - d, k - f)) / 2;\n      Math.abs(h - r) > Math.PI / 2 && (r -= Math.PI);\n      h = f + Math.cos(r) * l;\n      g = d + Math.sin(r) * l;\n      k = f + Math.cos(Math.PI + r) * n;\n      r = d + Math.sin(Math.PI + r) * n;\n      f = {\n        rightContX: k,\n        rightContY: r,\n        leftContX: h,\n        leftContY: g,\n        plotX: f,\n        plotY: d\n      };\n      c && (f.prevPointCont = this.getConnectors(a, b, !1, e));\n      return f;\n    };\n\n    I.toXY = function (a) {\n      var b = this.chart,\n          c = this.xAxis,\n          f = this.yAxis,\n          d = a.plotX,\n          e = a.plotY,\n          g = a.series,\n          k = b.inverted,\n          l = a.y,\n          m = k ? d : f.len - e;\n      k && g && !g.isRadialBar && (a.plotY = e = \"number\" === typeof l ? f.translate(l) || 0 : 0);\n      a.rectPlotX = d;\n      a.rectPlotY = e;\n      f.center && (m += f.center[3] / 2);\n      n(e) && (f = k ? f.postTranslate(e, m) : c.postTranslate(d, m), a.plotX = a.polarPlotX = f.x - b.plotLeft, a.plotY = a.polarPlotY = f.y - b.plotTop);\n      this.kdByAngle ? (b = (d / Math.PI * 180 + c.pane.options.startAngle) % 360, 0 > b && (b += 360), a.clientX = b) : a.clientX = a.plotX;\n    };\n\n    p.spline && (d(p.spline.prototype, \"getPointSpline\", function (a, b, c, d) {\n      this.chart.polar ? d ? (a = this.getConnectors(b, d, !0, this.connectEnds), b = a.prevPointCont && a.prevPointCont.rightContX, c = a.prevPointCont && a.prevPointCont.rightContY, a = [\"C\", n(b) ? b : a.plotX, n(c) ? c : a.plotY, n(a.leftContX) ? a.leftContX : a.plotX, n(a.leftContY) ? a.leftContY : a.plotY, a.plotX, a.plotY]) : a = [\"M\", c.plotX, c.plotY] : a = a.call(this, b, c, d);\n      return a;\n    }), p.areasplinerange && (p.areasplinerange.prototype.getPointSpline = p.spline.prototype.getPointSpline));\n    b(t, \"afterTranslate\", function () {\n      var a = this.chart;\n\n      if (a.polar && this.xAxis) {\n        (this.kdByAngle = a.tooltip && a.tooltip.shared) ? this.searchPoint = this.searchPointByAngle : this.options.findNearestPointBy = \"xy\";\n        if (!this.preventPostTranslate) for (var c = this.points, d = c.length; d--;) this.toXY(c[d]), !a.hasParallelCoordinates && !this.yAxis.reversed && c[d].y < this.yAxis.min && (c[d].isNull = !0);\n        this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(b(this, \"afterRender\", function () {\n          if (a.polar) {\n            var b = this.yAxis.pane.center;\n            this.clipCircle ? this.clipCircle.animate({\n              x: b[0],\n              y: b[1],\n              r: b[2] / 2,\n              innerR: b[3] / 2\n            }) : this.clipCircle = a.renderer.clipCircle(b[0], b[1], b[2] / 2, b[3] / 2);\n            this.group.clip(this.clipCircle);\n            this.setClip = l.noop;\n          }\n        })));\n      }\n    }, {\n      order: 2\n    });\n    d(p.line.prototype, \"getGraphPath\", function (a, b) {\n      var c = this,\n          d;\n\n      if (this.chart.polar) {\n        b = b || this.points;\n\n        for (d = 0; d < b.length; d++) if (!b[d].isNull) {\n          var e = d;\n          break;\n        }\n\n        if (!1 !== this.options.connectEnds && \"undefined\" !== typeof e) {\n          this.connectEnds = !0;\n          b.splice(b.length, 0, b[e]);\n          var f = !0;\n        }\n\n        b.forEach(function (a) {\n          \"undefined\" === typeof a.polarPlotY && c.toXY(a);\n        });\n      }\n\n      d = a.apply(this, [].slice.call(arguments, 1));\n      f && b.pop();\n      return d;\n    });\n\n    var y = function (a, b) {\n      var c = this,\n          d = this.chart,\n          e = this.options.animation,\n          f = this.group,\n          g = this.markerGroup,\n          h = this.xAxis && this.xAxis.center,\n          k = d.plotLeft,\n          n = d.plotTop,\n          m,\n          p,\n          t,\n          x;\n      if (d.polar) {\n        if (c.isRadialBar) b || (c.startAngleRad = q(c.translatedThreshold, c.xAxis.startAngleRad), l.seriesTypes.pie.prototype.animate.call(c, b));else {\n          if (d.renderer.isSVG) if (e = w(e), c.is(\"column\")) {\n            if (!b) {\n              var y = h[3] / 2;\n              c.points.forEach(function (a) {\n                m = a.graphic;\n                t = (p = a.shapeArgs) && p.r;\n                x = p && p.innerR;\n                m && p && (m.attr({\n                  r: y,\n                  innerR: y\n                }), m.animate({\n                  r: t,\n                  innerR: x\n                }, c.options.animation));\n              });\n            }\n          } else b ? (a = {\n            translateX: h[0] + k,\n            translateY: h[1] + n,\n            scaleX: .001,\n            scaleY: .001\n          }, f.attr(a), g && g.attr(a)) : (a = {\n            translateX: k,\n            translateY: n,\n            scaleX: 1,\n            scaleY: 1\n          }, f.animate(a, e), g && g.animate(a, e));\n        }\n      } else a.call(this, b);\n    };\n\n    d(I, \"animate\", y);\n\n    if (p.column) {\n      var z = p.arearange.prototype;\n      p = p.column.prototype;\n\n      p.polarArc = function (a, b, c, d) {\n        var e = this.xAxis.center,\n            f = this.yAxis.len,\n            g = e[3] / 2;\n        b = f - b + g;\n        a = f - q(a, f) + g;\n        this.yAxis.reversed && (0 > b && (b = g), 0 > a && (a = g));\n        return {\n          x: e[0],\n          y: e[1],\n          r: b,\n          innerR: a,\n          start: c,\n          end: d\n        };\n      };\n\n      d(p, \"animate\", y);\n      d(p, \"translate\", function (a) {\n        var b = this.options,\n            c = b.stacking,\n            d = this.chart,\n            e = this.xAxis,\n            f = this.yAxis,\n            k = f.reversed,\n            l = f.center,\n            m = e.startAngleRad,\n            p = e.endAngleRad - m;\n        this.preventPostTranslate = !0;\n        a.call(this);\n\n        if (e.isRadial) {\n          a = this.points;\n          e = a.length;\n          var q = f.translate(f.min);\n          var t = f.translate(f.max);\n          b = b.threshold || 0;\n\n          if (d.inverted && n(b)) {\n            var w = f.translate(b);\n            g(w) && (0 > w ? w = 0 : w > p && (w = p), this.translatedThreshold = w + m);\n          }\n\n          for (; e--;) {\n            b = a[e];\n            var y = b.barX;\n            var z = b.x;\n            var A = b.y;\n            b.shapeType = \"arc\";\n\n            if (d.inverted) {\n              b.plotY = f.translate(A);\n\n              if (c && f.stacking) {\n                if (A = f.stacking.stacks[(0 > A ? \"-\" : \"\") + this.stackKey], this.visible && A && A[z] && !b.isNull) {\n                  var G = A[z].points[this.getStackIndicator(void 0, z, this.index).key];\n                  var F = f.translate(G[0]);\n                  G = f.translate(G[1]);\n                  g(F) && (F = x.clamp(F, 0, p));\n                }\n              } else F = w, G = b.plotY;\n\n              F > G && (G = [F, F = G][0]);\n              if (!k) {\n                if (F < q) F = q;else if (G > t) G = t;else {\n                  if (G < q || F > t) F = G = 0;\n                }\n              } else if (G > q) G = q;else if (F < t) F = t;else if (F > q || G < t) F = G = p;\n              f.min > f.max && (F = G = k ? p : 0);\n              F += m;\n              G += m;\n              l && (b.barX = y += l[3] / 2);\n              z = Math.max(y, 0);\n              A = Math.max(y + b.pointWidth, 0);\n              b.shapeArgs = {\n                x: l && l[0],\n                y: l && l[1],\n                r: A,\n                innerR: z,\n                start: F,\n                end: G\n              };\n              b.opacity = F === G ? 0 : void 0;\n              b.plotY = (g(this.translatedThreshold) && (F < this.translatedThreshold ? F : G)) - m;\n            } else F = y + m, b.shapeArgs = this.polarArc(b.yBottom, b.plotY, F, F + b.pointWidth);\n\n            this.toXY(b);\n            d.inverted ? (y = f.postTranslate(b.rectPlotY, y + b.pointWidth / 2), b.tooltipPos = [y.x - d.plotLeft, y.y - d.plotTop]) : b.tooltipPos = [b.plotX, b.plotY];\n            l && (b.ttBelow = b.plotY > l[1]);\n          }\n        }\n      });\n\n      p.findAlignments = function (a, b) {\n        null === b.align && (b.align = 20 < a && 160 > a ? \"left\" : 200 < a && 340 > a ? \"right\" : \"center\");\n        null === b.verticalAlign && (b.verticalAlign = 45 > a || 315 < a ? \"bottom\" : 135 < a && 225 > a ? \"top\" : \"middle\");\n        return b;\n      };\n\n      z && (z.findAlignments = p.findAlignments);\n      d(p, \"alignDataLabel\", function (a, b, c, d, e, g) {\n        var f = this.chart,\n            h = q(d.inside, !!this.options.stacking);\n        f.polar ? (a = b.rectPlotX / Math.PI * 180, f.inverted ? (this.forceDL = f.isInsidePlot(b.plotX, Math.round(b.plotY)), h && b.shapeArgs ? (e = b.shapeArgs, e = this.yAxis.postTranslate(((e.start || 0) + (e.end || 0)) / 2 - this.xAxis.startAngleRad, b.barX + b.pointWidth / 2), e = {\n          x: e.x - f.plotLeft,\n          y: e.y - f.plotTop\n        }) : b.tooltipPos && (e = {\n          x: b.tooltipPos[0],\n          y: b.tooltipPos[1]\n        }), d.align = q(d.align, \"center\"), d.verticalAlign = q(d.verticalAlign, \"middle\")) : this.findAlignments && (d = this.findAlignments(a, d)), I.alignDataLabel.call(this, b, c, d, e, g), this.isRadialBar && b.shapeArgs && b.shapeArgs.start === b.shapeArgs.end && c.hide(!0)) : a.call(this, b, c, d, e, g);\n      });\n    }\n\n    d(c, \"getCoordinates\", function (a, b) {\n      var c = this.chart,\n          d = {\n        xAxis: [],\n        yAxis: []\n      };\n      c.polar ? c.axes.forEach(function (a) {\n        var e = a.isXAxis,\n            f = a.center;\n\n        if (\"colorAxis\" !== a.coll) {\n          var g = b.chartX - f[0] - c.plotLeft;\n          f = b.chartY - f[1] - c.plotTop;\n          d[e ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.translate(e ? Math.PI - Math.atan2(g, f) : Math.sqrt(Math.pow(g, 2) + Math.pow(f, 2)), !0)\n          });\n        }\n      }) : d = a.call(this, b);\n      return d;\n    });\n\n    k.prototype.clipCircle = function (a, b, c, d) {\n      var e = J(),\n          f = this.createElement(\"clipPath\").attr({\n        id: e\n      }).add(this.defs);\n      a = d ? this.arc(a, b, c, d, 0, 2 * Math.PI).add(f) : this.circle(a, b, c).add(f);\n      a.id = e;\n      a.clipPath = f;\n      return a;\n    };\n\n    b(e, \"getAxes\", function () {\n      this.pane || (this.pane = []);\n      this.options.pane = A(this.options.pane);\n      this.options.pane.forEach(function (b) {\n        new a(b, this);\n      }, this);\n    });\n    b(e, \"afterDrawChartBox\", function () {\n      this.pane.forEach(function (a) {\n        a.render();\n      });\n    });\n    b(t, \"afterInit\", function () {\n      var a = this.chart;\n      a.inverted && a.polar && (this.isRadialSeries = !0, this.is(\"column\") && (this.isRadialBar = !0));\n    });\n    d(e.prototype, \"get\", function (a, b) {\n      return m(this.pane || [], function (a) {\n        return a.options.id === b;\n      }) || a.call(this, b);\n    });\n  });\n  A(d, \"masters/highcharts-more.src.js\", [d[\"Core/Globals.js\"], d[\"Core/Axis/RadialAxis.js\"], d[\"Series/Bubble/BubbleSeries.js\"]], function (d, e, l) {\n    e.compose(d.Axis, d.Tick);\n    l.compose(d.Chart, d.Legend, d.Series);\n  });\n}); //# sourceMappingURL=highcharts-more.js.map","map":null,"metadata":{},"sourceType":"script"}